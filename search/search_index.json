{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Eclipse Epsilon \u00b6 Epsilon is a family of scripting languages and tools for automating common model-based software engineering tasks such as code generation , model-to-model transformation , model validation and model visualisation , that work out of the box with EMF (including Xtext and Sirius ), UML (including Cameo/MagicDraw), Simulink, XML and other types of models . Epsilon can be used as a standard Java library , and also provides Apache Ant tasks that can be embedded in Maven/Gradle builds . Editing support for Epsilon programs is available in Eclipse , VS Code and Sublime . Online Playground If you prefer not to download/install anything just quite yet, you can fiddle with EMF models and metamodels, and with some of the Epsilon languages in the online Epsilon Playground . Installation \u00b6 Download the Eclipse Installer and select Epsilon, as shown below. Note that you will need a Java Runtime Environment installed on your system. More options for downloading Epsilon (update sites, Maven) are available here . Why Epsilon? \u00b6 One syntax to rule them all: All languages in Epsilon build on top of a common expression language which means that you can reuse code across your model-to-model transformations, code generators, validation constraints etc. Integrated development tools: All languages in Epsilon are supported by editors providing syntax and error highlighting, code templates, and graphical tools for configuring, running, debugging and profiling Epsilon programs. Documentation, Documentation, Documentation: More than 60 articles , 15 screencasts and 40 examples are available to help you get from novice to expert. Strong support for EMF: Epsilon supports all flavours of EMF, including reflective, generated and non-XMI (textual) models such as these specified using Xtext or EMFText-based DSLs. No EMF? No problem: While Epsilon provides strong support for EMF, it is not bound to EMF at all. In fact, support for EMF is implemented as a driver for the model connectivity layer of Epsilon. Other drivers provide support for XML, CSV, Simulink and you can even roll out your own driver! No Eclipse? No problem either: While Epsilon provides strong support for Eclipse, we also provide standalone JARs through Maven Central that you can use to embed Epsilon in your plain Java or Android application. Mix and match: Epsilon poses no constraints on the number/type of models you can use in the same program. For example, you can write a transformation that transforms an XML-based and an EMF-based model into a Simulink model and also modifies the source EMF model. Plumbing included: You can use the ANT Epsilon tasks to compose Epsilon programs into complex workflows. Programs executed in the same workflow can share models and even pass parameters to each other. Extensible: Almost every aspect of Epsilon is extensible. You can add support for your own type of models , extend the Eclipse-based development tools, add a new method to the String type, or even implement your own model management language on top of EOL. Java is your friend: You can call methods of Java classes from all Epsilon programs to reuse code you have already written or to perform tasks that Epsilon languages do not support natively. Parallel execution: Since 2.0, Epsilon is multi-threaded, which includes first-order operations and some of the rule-based languages, making it faster than other interpreted tools. All questions answered: The Epsilon forum contains more than 9,500 posts and we're proud that no question has ever gone unanswered. We're working on it: Epsilon has been an Eclipse project since 2006 and it's not going away any time soon. License \u00b6 Epsilon is licensed under the Eclipse Public License 2.0 . Trademarks \u00b6 Eclipse Epsilon and the Eclipse Epsilon project logo are trademarks of the Eclipse Foundation. Eclipse and the Eclipse logo are registered trademarks of the Eclipse Foundation. Java and all Java-based trademarks are trademarks of Oracle Corporation in the United States, other countries, or both. Acknowledgements \u00b6 We would like to thank ej-technologies for providing us with free licenses of their powerful JProfiler Java profiler .","title":"Home"},{"location":"#eclipse-epsilon","text":"Epsilon is a family of scripting languages and tools for automating common model-based software engineering tasks such as code generation , model-to-model transformation , model validation and model visualisation , that work out of the box with EMF (including Xtext and Sirius ), UML (including Cameo/MagicDraw), Simulink, XML and other types of models . Epsilon can be used as a standard Java library , and also provides Apache Ant tasks that can be embedded in Maven/Gradle builds . Editing support for Epsilon programs is available in Eclipse , VS Code and Sublime . Online Playground If you prefer not to download/install anything just quite yet, you can fiddle with EMF models and metamodels, and with some of the Epsilon languages in the online Epsilon Playground .","title":"Eclipse Epsilon "},{"location":"#installation","text":"Download the Eclipse Installer and select Epsilon, as shown below. Note that you will need a Java Runtime Environment installed on your system. More options for downloading Epsilon (update sites, Maven) are available here .","title":"Installation"},{"location":"#why-epsilon","text":"One syntax to rule them all: All languages in Epsilon build on top of a common expression language which means that you can reuse code across your model-to-model transformations, code generators, validation constraints etc. Integrated development tools: All languages in Epsilon are supported by editors providing syntax and error highlighting, code templates, and graphical tools for configuring, running, debugging and profiling Epsilon programs. Documentation, Documentation, Documentation: More than 60 articles , 15 screencasts and 40 examples are available to help you get from novice to expert. Strong support for EMF: Epsilon supports all flavours of EMF, including reflective, generated and non-XMI (textual) models such as these specified using Xtext or EMFText-based DSLs. No EMF? No problem: While Epsilon provides strong support for EMF, it is not bound to EMF at all. In fact, support for EMF is implemented as a driver for the model connectivity layer of Epsilon. Other drivers provide support for XML, CSV, Simulink and you can even roll out your own driver! No Eclipse? No problem either: While Epsilon provides strong support for Eclipse, we also provide standalone JARs through Maven Central that you can use to embed Epsilon in your plain Java or Android application. Mix and match: Epsilon poses no constraints on the number/type of models you can use in the same program. For example, you can write a transformation that transforms an XML-based and an EMF-based model into a Simulink model and also modifies the source EMF model. Plumbing included: You can use the ANT Epsilon tasks to compose Epsilon programs into complex workflows. Programs executed in the same workflow can share models and even pass parameters to each other. Extensible: Almost every aspect of Epsilon is extensible. You can add support for your own type of models , extend the Eclipse-based development tools, add a new method to the String type, or even implement your own model management language on top of EOL. Java is your friend: You can call methods of Java classes from all Epsilon programs to reuse code you have already written or to perform tasks that Epsilon languages do not support natively. Parallel execution: Since 2.0, Epsilon is multi-threaded, which includes first-order operations and some of the rule-based languages, making it faster than other interpreted tools. All questions answered: The Epsilon forum contains more than 9,500 posts and we're proud that no question has ever gone unanswered. We're working on it: Epsilon has been an Eclipse project since 2006 and it's not going away any time soon.","title":"Why Epsilon?"},{"location":"#license","text":"Epsilon is licensed under the Eclipse Public License 2.0 .","title":"License"},{"location":"#trademarks","text":"Eclipse Epsilon and the Eclipse Epsilon project logo are trademarks of the Eclipse Foundation. Eclipse and the Eclipse logo are registered trademarks of the Eclipse Foundation. Java and all Java-based trademarks are trademarks of Oracle Corporation in the United States, other countries, or both.","title":"Trademarks"},{"location":"#acknowledgements","text":"We would like to thank ej-technologies for providing us with free licenses of their powerful JProfiler Java profiler .","title":"Acknowledgements"},{"location":"examples/","text":"Examples \u00b6 Looking for in-depth articles? This page contains links to a selection of example projects in Epsilon's Git repository. If you are looking for more in-depth articles describing different features of Epsilon, please visit the articles section of the website. Online Playground If you prefer not to download/install anything just quite yet, you can fiddle with EMF models and metamodels, and with some of the Epsilon languages in the online Epsilon Playground . Each example in this page comes in the form of an Eclipse project, which is stored under the examples dirctory of Epsilon's Git repository. To run an example, you need to: Clone the repository Import the project in question into your Eclipse workspace Register any Ecore metamodels in it Right click the .launch file in it Select Run as... and click the first item in the menu that pops up Warning To avoid copying the same metamodels across different example projects, some projects reuse Ecore metamodels stored in the org.eclipse.epsilon.examples.metamodels project. If you are unable to run any of the examples below, please give us a shout . Epsilon Object Language \u00b6 Create an OO model with EOL : In this example we use EOL to programmatically construct a model that conforms to an object-oriented metamodel. Modify a Tree model with EOL : In this example we use EOL to programmatically modify a model that conforms to a Tree metamodel and store the modified version as a new model. Call Java code from Epsilon : In this example, we create a JFrame from EOL. The aim of this example is to show how to call Java code from within Epsilon languages. Creating custom Java tools for Epsilon : In this example, we create a custom tool for Epsilon. Building and querying plain XML documents with EOL : In this example, we use the plain XML driver of Epsilon to build and query an XML document that is not backed by a XSD/DTD. Cloning and copying XML elements across documents with EOL : In this example, we use the plain XML driver of Epsilon to clone and copy XML elements across different documents with EOL. Cloning EMF model elements with EOL : In this example, we demonstrate how the EmfTool built-in tool can be used to perform deep-copy (cloning) of EMF model elements using EOL. Profiling and caching in EOL : This example demonstrates the caching capabilities and the profiling tools provided by Epsilon. Manage XSD-backed XML files with EOL : In this example we demonstrate using EOL to query an XSD-backed XML file. Manage Matlab Simulink/Stateflow blocks from Epsilon : In this example we show how to manage Matlab Simulink/Stateflow blocks with EOL. Epsilon Transformation Language \u00b6 Transform a Tree model to a Graph model with ETL : In this example, we use ETL to transform a model that conforms to a Tree metamodel to a model that conforms to a Graph metamodel. Transform an RSS feed to an Atom feed using ETL : In this example, we use ETL and the plain XML driver to transform an RSS feed to an Atom feed. Experiment with the different types of transformation rule in ETL using a Flowchart-to-HTML transformation. : In this example, we show the different types of transformation rule that are provided by ETL, including plain, abstract, lazy, primary and greedy rules. We also explore rule inheritance and rules that generate more than model element. We transform from a Flowchart model to an HTML model. Transform an OO model to a DB model with ETL : In this example, we use ETL to transform a model that conforms to an Object-Oriented metamodel to a model that conforms to the Database metamodel. Epsilon Generation Language \u00b6 Experiment with the different features of EGL using a Flowchart-to-HTML transformation. : In this example, we explore the main features of EGL by generating HTML text from an EMF model of a flowchart. We demonstrate the EGX coordination language, code formatters, preserving hand-written text with protected regions and generating a fine-grained trace model. Generating HTML pages from an XML document : In this example, we use the plain XML driver of Epsilon in the context of an EGL model-to-text transformation. Generate HTML documentation from an Ecore metamodel with EGL : In this example, we demonstrate how EGL can be used to generate HTML documentation from an Ecore metamodel. Epsilon Validation Language \u00b6 Validate an OO model with EVL : In this example, we use EVL, to express constraints for models that conform to an Object-Oriented metamodel. Validate an OO model against a DB model with EVL : In this example, we use EVL to expressing inter-model constraints. Dijkstra's shortest path algorithm with EOL/EVL : In this example, we use EOL and EVL to implement Dijkstra's shortest path algorithm. Epsilon Merging Language \u00b6 Heterogeneous Model Merging with ECL/EML : In this example, we demonstrate merging heterogeneous models using ECL and EML. Epsilon Flock \u00b6 Migrate Petri net models with Epsilon Flock : In this example we demonstrate how to migrate a model in response to metamodel changes with Epsilon Flock. Epsilon Model Generation Language \u00b6 Generate PetriNet models using EMG : In this example we demonstrate how to generate PetriNet elements and how to define relations between them. Epsilon Pattern Language \u00b6 Find pattern matches in railway models using EPL : In this example we demonstrate how to find matches of the patterns in the Train Benchmark models with EPL. Combining the Epsilon Languages \u00b6 Use Epsilon in standalone Java applications : In this example, we demonstrate how Epsilon languages can be used in standalone, non-Eclipse-based Java applications. MDD-TIF complete case study : In this example, we demonstrate how different languages in Epsilon (EVL, EGL, EML, ETL and ECL) can be combined to implement more complex operations. Compare, validate and merge OO models : In this example, we use ECL to compare two OO models, then use EVL to check the identified matches for consistency and finally EML to merge them. Construct a workflow to orchestrate several Epsilon programs with Ant : In this example we demonstrate how to use the built-in Epsilon Ant tasks to define a workflow by combining several Epsilon programs. Here, we validate, transform and generate HTML from a flowchart model. Provide custom/extended tasks for the workflow : In this example we demonstrate how you can define your own ANT tasks that extend the Epsilon workflow tasks. Use model transactions in a workflow : In this example we demonstrate using the ant-contrib try/catch tasks and the Epsilon model transactions tasks to conditionally rollback changes in models modified in a workflow. Eugenia \u00b6 Implement a GMF editor with image nodes using Eugenia : In this example we use Eugenia to implement a GMF editor with images instead of shapes for nodes. Implement a GMF editor with end labels in connections using Eugenia : In this example we use Eugenia to implement a GMF editor with end labels in connections. Implement a flowchart GMF editor using Eugenia : In this example we use Eugenia to implement a flowchart GMF editor, and EOL to polish its appearance. EUnit \u00b6 Test EOL scripts with EUnit : In this example we show the basic structure of an EUnit test, some useful assertions for the basic types and how to test for errors and define our own assertions. Reuse EUnit tests with model and data bindings : In this example we show how the same EUnit test can be reused for several models, and how EUnit supports several levels of parametric tests. Test a model validation script with EUnit : In this example we show how a model validation script written in EVL can be tested with EUnit, using the exportAsModel attribute of the EVL workflow task. Test a model-to-text transformation with EUnit : In this example we show how a model-to-text transformation written in EGL can be tested with EUnit and HUTN. Integrate EUnit into a standard JUnit plug-in test : In this example we show how to write an EUnit/JUnit plug-in test of an ETL transformation. Even more examples \u00b6 More examples are available in the examples folder of the Git repository.","title":"Examples"},{"location":"examples/#examples","text":"Looking for in-depth articles? This page contains links to a selection of example projects in Epsilon's Git repository. If you are looking for more in-depth articles describing different features of Epsilon, please visit the articles section of the website. Online Playground If you prefer not to download/install anything just quite yet, you can fiddle with EMF models and metamodels, and with some of the Epsilon languages in the online Epsilon Playground . Each example in this page comes in the form of an Eclipse project, which is stored under the examples dirctory of Epsilon's Git repository. To run an example, you need to: Clone the repository Import the project in question into your Eclipse workspace Register any Ecore metamodels in it Right click the .launch file in it Select Run as... and click the first item in the menu that pops up Warning To avoid copying the same metamodels across different example projects, some projects reuse Ecore metamodels stored in the org.eclipse.epsilon.examples.metamodels project. If you are unable to run any of the examples below, please give us a shout .","title":"Examples"},{"location":"examples/#epsilon-object-language","text":"Create an OO model with EOL : In this example we use EOL to programmatically construct a model that conforms to an object-oriented metamodel. Modify a Tree model with EOL : In this example we use EOL to programmatically modify a model that conforms to a Tree metamodel and store the modified version as a new model. Call Java code from Epsilon : In this example, we create a JFrame from EOL. The aim of this example is to show how to call Java code from within Epsilon languages. Creating custom Java tools for Epsilon : In this example, we create a custom tool for Epsilon. Building and querying plain XML documents with EOL : In this example, we use the plain XML driver of Epsilon to build and query an XML document that is not backed by a XSD/DTD. Cloning and copying XML elements across documents with EOL : In this example, we use the plain XML driver of Epsilon to clone and copy XML elements across different documents with EOL. Cloning EMF model elements with EOL : In this example, we demonstrate how the EmfTool built-in tool can be used to perform deep-copy (cloning) of EMF model elements using EOL. Profiling and caching in EOL : This example demonstrates the caching capabilities and the profiling tools provided by Epsilon. Manage XSD-backed XML files with EOL : In this example we demonstrate using EOL to query an XSD-backed XML file. Manage Matlab Simulink/Stateflow blocks from Epsilon : In this example we show how to manage Matlab Simulink/Stateflow blocks with EOL.","title":"Epsilon Object Language"},{"location":"examples/#epsilon-transformation-language","text":"Transform a Tree model to a Graph model with ETL : In this example, we use ETL to transform a model that conforms to a Tree metamodel to a model that conforms to a Graph metamodel. Transform an RSS feed to an Atom feed using ETL : In this example, we use ETL and the plain XML driver to transform an RSS feed to an Atom feed. Experiment with the different types of transformation rule in ETL using a Flowchart-to-HTML transformation. : In this example, we show the different types of transformation rule that are provided by ETL, including plain, abstract, lazy, primary and greedy rules. We also explore rule inheritance and rules that generate more than model element. We transform from a Flowchart model to an HTML model. Transform an OO model to a DB model with ETL : In this example, we use ETL to transform a model that conforms to an Object-Oriented metamodel to a model that conforms to the Database metamodel.","title":"Epsilon Transformation Language"},{"location":"examples/#epsilon-generation-language","text":"Experiment with the different features of EGL using a Flowchart-to-HTML transformation. : In this example, we explore the main features of EGL by generating HTML text from an EMF model of a flowchart. We demonstrate the EGX coordination language, code formatters, preserving hand-written text with protected regions and generating a fine-grained trace model. Generating HTML pages from an XML document : In this example, we use the plain XML driver of Epsilon in the context of an EGL model-to-text transformation. Generate HTML documentation from an Ecore metamodel with EGL : In this example, we demonstrate how EGL can be used to generate HTML documentation from an Ecore metamodel.","title":"Epsilon Generation Language"},{"location":"examples/#epsilon-validation-language","text":"Validate an OO model with EVL : In this example, we use EVL, to express constraints for models that conform to an Object-Oriented metamodel. Validate an OO model against a DB model with EVL : In this example, we use EVL to expressing inter-model constraints. Dijkstra's shortest path algorithm with EOL/EVL : In this example, we use EOL and EVL to implement Dijkstra's shortest path algorithm.","title":"Epsilon Validation Language"},{"location":"examples/#epsilon-merging-language","text":"Heterogeneous Model Merging with ECL/EML : In this example, we demonstrate merging heterogeneous models using ECL and EML.","title":"Epsilon Merging Language"},{"location":"examples/#epsilon-flock","text":"Migrate Petri net models with Epsilon Flock : In this example we demonstrate how to migrate a model in response to metamodel changes with Epsilon Flock.","title":"Epsilon Flock"},{"location":"examples/#epsilon-model-generation-language","text":"Generate PetriNet models using EMG : In this example we demonstrate how to generate PetriNet elements and how to define relations between them.","title":"Epsilon Model Generation Language"},{"location":"examples/#epsilon-pattern-language","text":"Find pattern matches in railway models using EPL : In this example we demonstrate how to find matches of the patterns in the Train Benchmark models with EPL.","title":"Epsilon Pattern Language"},{"location":"examples/#combining-the-epsilon-languages","text":"Use Epsilon in standalone Java applications : In this example, we demonstrate how Epsilon languages can be used in standalone, non-Eclipse-based Java applications. MDD-TIF complete case study : In this example, we demonstrate how different languages in Epsilon (EVL, EGL, EML, ETL and ECL) can be combined to implement more complex operations. Compare, validate and merge OO models : In this example, we use ECL to compare two OO models, then use EVL to check the identified matches for consistency and finally EML to merge them. Construct a workflow to orchestrate several Epsilon programs with Ant : In this example we demonstrate how to use the built-in Epsilon Ant tasks to define a workflow by combining several Epsilon programs. Here, we validate, transform and generate HTML from a flowchart model. Provide custom/extended tasks for the workflow : In this example we demonstrate how you can define your own ANT tasks that extend the Epsilon workflow tasks. Use model transactions in a workflow : In this example we demonstrate using the ant-contrib try/catch tasks and the Epsilon model transactions tasks to conditionally rollback changes in models modified in a workflow.","title":"Combining the Epsilon Languages"},{"location":"examples/#eugenia","text":"Implement a GMF editor with image nodes using Eugenia : In this example we use Eugenia to implement a GMF editor with images instead of shapes for nodes. Implement a GMF editor with end labels in connections using Eugenia : In this example we use Eugenia to implement a GMF editor with end labels in connections. Implement a flowchart GMF editor using Eugenia : In this example we use Eugenia to implement a flowchart GMF editor, and EOL to polish its appearance.","title":"Eugenia"},{"location":"examples/#eunit","text":"Test EOL scripts with EUnit : In this example we show the basic structure of an EUnit test, some useful assertions for the basic types and how to test for errors and define our own assertions. Reuse EUnit tests with model and data bindings : In this example we show how the same EUnit test can be reused for several models, and how EUnit supports several levels of parametric tests. Test a model validation script with EUnit : In this example we show how a model validation script written in EVL can be tested with EUnit, using the exportAsModel attribute of the EVL workflow task. Test a model-to-text transformation with EUnit : In this example we show how a model-to-text transformation written in EGL can be tested with EUnit and HUTN. Integrate EUnit into a standard JUnit plug-in test : In this example we show how to write an EUnit/JUnit plug-in test of an ETL transformation.","title":"EUnit"},{"location":"examples/#even-more-examples","text":"More examples are available in the examples folder of the Git repository.","title":"Even more examples"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 In this page we provide answers to common questions about Epsilon. If your question is not answered here, please feel free to ask in the forum . What is the relationship between Epsilon and EMF? \u00b6 Briefly, with EMF you can specify metamodels and construct models that conform to these metamodels, while with Epsilon you can process these EMF models and metamodels (e.g. validate them, transform them, generate code from them etc.). Is Epsilon a model transformation language? \u00b6 No. Epsilon is a family of languages, one of which targets model-to-model transformation (ETL). Who is using Epsilon? \u00b6 With more than 9,000 posts in the Epsilon forum , it appears that quite a few people are currently using different parts of Epsilon. A list of companies and open-source projects that use Epsilon is available here . How do I get help? \u00b6 Epsilon has a dedicated forum where you can ask questions about the tools and languages it provides. Whenever possible, please use the forum instead of direct email. We're monitoring the forum very closely and there is practically no difference in terms of response time. Also, answered questions in the forum form a knowledge base, which other users can consult in case they face similar issues in the future, and an active forum is an indication of a healthy and actively maintained project (properties that the Eclipse Foundation takes very seriously). When posting messages to the forum we recommend that you use your full (or at least a realistic) name instead of a nickname (e.g. \"ABC\", \"SomeGuy\") as the latter can lead to pretty awkward sentences. How do I get notified when a new version of Epsilon becomes available? \u00b6 To get notified when a new version of Epsilon becomes available you can configure Eclipse to check for updates automatically by going to Window \u2192 Preferences \u2192 Install/Update/Automatic Updates and checking the Automatically find new updates and notify me option. Can I use Epsilon in a non-Eclipse-based standalone Java application? \u00b6 Yes. There are several examples of doing just that in the examples/org.eclipse.epsilon.examples.standalone project in the Git repository. Just grab your JARs through Maven Central . How does Epsilon compare to the OMG family of languages? \u00b6 There are two main differences: First, QVT, OCL and MTL are standards while languages in Epsilon are not. While having standards is arguably a good thing , by not having to conform to standardized specifications, Epsilon provides the agility to explore interesting new features and extensions of model management languages, and contribute to advancing the state of the art in the field. Examples of such interesting and novel features in Epsilon include interactive transformation , tight Java integration , extended properties , and support for transactions . Second, Epsilon provides specialized languages for tasks that are currently not explicitly targeted by the OMG standards. Examples of such tasks include interactive in-place model transformation, model comparison, and model merging. What is the difference between E*L and language X? \u00b6 If the available documentation doesn't provide enough information for figuring this out, please feel free to ask in the Epsilon forum . Are Epsilon languages compiled or interpreted? \u00b6 All Epsilon languages are interpreted. With the exception of EGL templates which are transformed into EOL before execution, all other languages are supported by bespoke interpreters. How can I contribute to Epsilon? \u00b6 There are several ways to contribute to Epsilon. In the first phase you can ask questions in the forum and help with maintaining the vibrant community around Epsilon. You may also want to let other developers know about Epsilon by sharing your experiences online. If you are interested in contributing code to Epsilon, you should start by submitting bug reports, feature requests - and hopefully patches that fix/implement them. This will demonstrate your commitment and long-term interest in the project - which is required by the Eclipse Foundation in order to later on be nominated for a committer account. Where is the metamodel of ETL/EVL etc.? \u00b6 Epsilon languages do not have Ecore-based metamodels. How do I enable code-completion/assistance in the Epsilon editors? \u00b6 Epsilon does not provide support for type-aware code completion as Epsilon languages are dynamically typed. However, ctrl+space provides a list of previously typed tokens to speed up typing.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"In this page we provide answers to common questions about Epsilon. If your question is not answered here, please feel free to ask in the forum .","title":"Frequently Asked Questions"},{"location":"faq/#what-is-the-relationship-between-epsilon-and-emf","text":"Briefly, with EMF you can specify metamodels and construct models that conform to these metamodels, while with Epsilon you can process these EMF models and metamodels (e.g. validate them, transform them, generate code from them etc.).","title":"What is the relationship between Epsilon and EMF?"},{"location":"faq/#is-epsilon-a-model-transformation-language","text":"No. Epsilon is a family of languages, one of which targets model-to-model transformation (ETL).","title":"Is Epsilon a model transformation language?"},{"location":"faq/#who-is-using-epsilon","text":"With more than 9,000 posts in the Epsilon forum , it appears that quite a few people are currently using different parts of Epsilon. A list of companies and open-source projects that use Epsilon is available here .","title":"Who is using Epsilon?"},{"location":"faq/#how-do-i-get-help","text":"Epsilon has a dedicated forum where you can ask questions about the tools and languages it provides. Whenever possible, please use the forum instead of direct email. We're monitoring the forum very closely and there is practically no difference in terms of response time. Also, answered questions in the forum form a knowledge base, which other users can consult in case they face similar issues in the future, and an active forum is an indication of a healthy and actively maintained project (properties that the Eclipse Foundation takes very seriously). When posting messages to the forum we recommend that you use your full (or at least a realistic) name instead of a nickname (e.g. \"ABC\", \"SomeGuy\") as the latter can lead to pretty awkward sentences.","title":"How do I get help?"},{"location":"faq/#how-do-i-get-notified-when-a-new-version-of-epsilon-becomes-available","text":"To get notified when a new version of Epsilon becomes available you can configure Eclipse to check for updates automatically by going to Window \u2192 Preferences \u2192 Install/Update/Automatic Updates and checking the Automatically find new updates and notify me option.","title":"How do I get notified when a new version of Epsilon becomes available?"},{"location":"faq/#can-i-use-epsilon-in-a-non-eclipse-based-standalone-java-application","text":"Yes. There are several examples of doing just that in the examples/org.eclipse.epsilon.examples.standalone project in the Git repository. Just grab your JARs through Maven Central .","title":"Can I use Epsilon in a non-Eclipse-based standalone Java application?"},{"location":"faq/#how-does-epsilon-compare-to-the-omg-family-of-languages","text":"There are two main differences: First, QVT, OCL and MTL are standards while languages in Epsilon are not. While having standards is arguably a good thing , by not having to conform to standardized specifications, Epsilon provides the agility to explore interesting new features and extensions of model management languages, and contribute to advancing the state of the art in the field. Examples of such interesting and novel features in Epsilon include interactive transformation , tight Java integration , extended properties , and support for transactions . Second, Epsilon provides specialized languages for tasks that are currently not explicitly targeted by the OMG standards. Examples of such tasks include interactive in-place model transformation, model comparison, and model merging.","title":"How does Epsilon compare to the OMG family of languages?"},{"location":"faq/#what-is-the-difference-between-el-and-language-x","text":"If the available documentation doesn't provide enough information for figuring this out, please feel free to ask in the Epsilon forum .","title":"What is the difference between E*L and language X?"},{"location":"faq/#are-epsilon-languages-compiled-or-interpreted","text":"All Epsilon languages are interpreted. With the exception of EGL templates which are transformed into EOL before execution, all other languages are supported by bespoke interpreters.","title":"Are Epsilon languages compiled or interpreted?"},{"location":"faq/#how-can-i-contribute-to-epsilon","text":"There are several ways to contribute to Epsilon. In the first phase you can ask questions in the forum and help with maintaining the vibrant community around Epsilon. You may also want to let other developers know about Epsilon by sharing your experiences online. If you are interested in contributing code to Epsilon, you should start by submitting bug reports, feature requests - and hopefully patches that fix/implement them. This will demonstrate your commitment and long-term interest in the project - which is required by the Eclipse Foundation in order to later on be nominated for a committer account.","title":"How can I contribute to Epsilon?"},{"location":"faq/#where-is-the-metamodel-of-etlevl-etc","text":"Epsilon languages do not have Ecore-based metamodels.","title":"Where is the metamodel of ETL/EVL etc.?"},{"location":"faq/#how-do-i-enable-code-completionassistance-in-the-epsilon-editors","text":"Epsilon does not provide support for type-aware code completion as Epsilon languages are dynamically typed. However, ctrl+space provides a list of previously typed tokens to speed up typing.","title":"How do I enable code-completion/assistance in the Epsilon editors?"},{"location":"getting-started/","text":"Getting Started with Epsilon \u00b6 Epsilon provides a set of languages and tools for tasks such as model-to-text transformation , model-to-model transformation , model validation (all of which extend the same core language ), model editing , weaving and visualisation . While some Epsilon tools are Eclipse IDE plugins , most of Epsilon does not depend on the Eclipse IDE and can be used from standard Java applications and from Maven/Gradle builds. New to Model-Based Software Engineering? If you are a newcomer to model-based software engineering and the Eclipse modelling ecosystem, you may find this series of lectures useful. Trying Epsilon in the Playground \u00b6 You can try most Epsilon languages in the online Epsilon Playground , without needing to download or install anything. Using Epsilon as a Java library \u00b6 The execution engines of Epsilon's languages, the Flexmi parser, and drivers for EMF , UML , XML and Excel are available as standard Java libraries through Maven Central . To get started with parsing and executing Epsilon programs from your Java application: Go to the Epsilon Playground and select one of the examples; Click the Download button and select Java (Maven) or Java (Gradle) from the window that pops up to download a zipped copy of the example. The downloaded zip file includes an Example Java class as well as a pom.xml / build.gradle file with all the Epsilon dependencies; Import the example in your favourite Java IDE (e.g. Eclipse, IntelliJ, VS Code) and run the Example class; Alternatively, follow the instructions in the readme.txt to run the example from command line (you only need to have Java and Maven/Gradle installed); Read this article that introduces Epsilon's Java API. Epsilon in Maven/Gradle Builds \u00b6 On some occasions you may need to include model management tasks in your build/CI pipeline (e.g. to validate a model and generate code from it). For such scenarios, Epsilon provides Ant tasks that can be used in the context of Maven and Gradle builds. To get started with running Epsilon from Maven/Gradle builds: Go to the Epsilon Playground and select one of the examples; Click the Download button and select Maven or Gradle from the window that pops up to download a zipped copy of the example. The downloaded zip file includes a pom.xml / build.gradle file with all the Epsilon dependencies and the respective Epsilon Ant tasks; Follow the instructions in the readme.txt to run the example from command line (you only need to have Java and Maven/Gradle installed). Epsilon in Eclipse \u00b6 Epsilon provides a rich set of Eclipse plugins for editing, running, profiling and debugging model management programs. It also includes tools for editing , weaving and visualising models. You can install these tools through Epsilon's update site or through the Eclipse Installer. Epsilon in other IDEs/Editors \u00b6 Support for syntax highlighting Epsilon programs, Flexmi models and Emfatic metamodels is available for the following IDEs and editors, beyond Eclipse. VS Code Sublime","title":"Getting Started"},{"location":"getting-started/#getting-started-with-epsilon","text":"Epsilon provides a set of languages and tools for tasks such as model-to-text transformation , model-to-model transformation , model validation (all of which extend the same core language ), model editing , weaving and visualisation . While some Epsilon tools are Eclipse IDE plugins , most of Epsilon does not depend on the Eclipse IDE and can be used from standard Java applications and from Maven/Gradle builds. New to Model-Based Software Engineering? If you are a newcomer to model-based software engineering and the Eclipse modelling ecosystem, you may find this series of lectures useful.","title":"Getting Started with Epsilon"},{"location":"getting-started/#trying-epsilon-in-the-playground","text":"You can try most Epsilon languages in the online Epsilon Playground , without needing to download or install anything.","title":"Trying Epsilon in the Playground"},{"location":"getting-started/#using-epsilon-as-a-java-library","text":"The execution engines of Epsilon's languages, the Flexmi parser, and drivers for EMF , UML , XML and Excel are available as standard Java libraries through Maven Central . To get started with parsing and executing Epsilon programs from your Java application: Go to the Epsilon Playground and select one of the examples; Click the Download button and select Java (Maven) or Java (Gradle) from the window that pops up to download a zipped copy of the example. The downloaded zip file includes an Example Java class as well as a pom.xml / build.gradle file with all the Epsilon dependencies; Import the example in your favourite Java IDE (e.g. Eclipse, IntelliJ, VS Code) and run the Example class; Alternatively, follow the instructions in the readme.txt to run the example from command line (you only need to have Java and Maven/Gradle installed); Read this article that introduces Epsilon's Java API.","title":"Using Epsilon as a Java library"},{"location":"getting-started/#epsilon-in-mavengradle-builds","text":"On some occasions you may need to include model management tasks in your build/CI pipeline (e.g. to validate a model and generate code from it). For such scenarios, Epsilon provides Ant tasks that can be used in the context of Maven and Gradle builds. To get started with running Epsilon from Maven/Gradle builds: Go to the Epsilon Playground and select one of the examples; Click the Download button and select Maven or Gradle from the window that pops up to download a zipped copy of the example. The downloaded zip file includes a pom.xml / build.gradle file with all the Epsilon dependencies and the respective Epsilon Ant tasks; Follow the instructions in the readme.txt to run the example from command line (you only need to have Java and Maven/Gradle installed).","title":"Epsilon in Maven/Gradle Builds"},{"location":"getting-started/#epsilon-in-eclipse","text":"Epsilon provides a rich set of Eclipse plugins for editing, running, profiling and debugging model management programs. It also includes tools for editing , weaving and visualising models. You can install these tools through Epsilon's update site or through the Eclipse Installer.","title":"Epsilon in Eclipse"},{"location":"getting-started/#epsilon-in-other-ideseditors","text":"Support for syntax highlighting Epsilon programs, Flexmi models and Emfatic metamodels is available for the following IDEs and editors, beyond Eclipse. VS Code Sublime","title":"Epsilon in other IDEs/Editors"},{"location":"labs/","text":"Epsilon Labs \u00b6 EpsilonLabs is a satellite project of Epsilon on GitHub that hosts experimental stuff which may (or may not) end up being part of Epsilon in the future. It also hosts contributions that are incompatible with EPL and therefore cannot be hosted under eclipse.org. Warning Please be aware that the code contributed under EpsilonLabs is not part of (or in any other way formally related to) Eclipse, and has not been IP-checked by the Eclipse legal team.","title":"Epsilon Labs"},{"location":"labs/#epsilon-labs","text":"EpsilonLabs is a satellite project of Epsilon on GitHub that hosts experimental stuff which may (or may not) end up being part of Epsilon in the future. It also hosts contributions that are incompatible with EPL and therefore cannot be hosted under eclipse.org. Warning Please be aware that the code contributed under EpsilonLabs is not part of (or in any other way formally related to) Eclipse, and has not been IP-checked by the Eclipse legal team.","title":"Epsilon Labs"},{"location":"branding/","text":"td { width: 300px; } td img { width: 150px; margin-left: auto; margin-right: auto; display: block; vertical-align: middle;} Branding \u00b6 Below are different versions of the Epsilon logo to use in posters, presentations, demos etc. To download a copy of a logo, right-click on it and select Save Image As... in your browser. The SVG versions are infinitely scalable and the PNG versions are much larger than their thumbnails on this page. The font of the text in the logo is Lucida Grande . Description SVG PNG Sphere and text Sphere only Text only What do the name and the logo mean? \u00b6 Epsilon (pronounced \u025bps\u026al\u0252n ) stands for E xtensible P latform for S pecification of I nteroperable L anguages for M o del Ma n agement. The dark blue jigsaw pieces in the logo represent the different languages in Epsilon , while the purple pieces represent the different modelling technologies that Epsilon programs can operate on. License \u00b6 As with everything else in Epsilon, the logos are licensed under the Eclipse Public License 2.0 .","title":"Branding"},{"location":"branding/#branding","text":"Below are different versions of the Epsilon logo to use in posters, presentations, demos etc. To download a copy of a logo, right-click on it and select Save Image As... in your browser. The SVG versions are infinitely scalable and the PNG versions are much larger than their thumbnails on this page. The font of the text in the logo is Lucida Grande . Description SVG PNG Sphere and text Sphere only Text only","title":"Branding"},{"location":"branding/#what-do-the-name-and-the-logo-mean","text":"Epsilon (pronounced \u025bps\u026al\u0252n ) stands for E xtensible P latform for S pecification of I nteroperable L anguages for M o del Ma n agement. The dark blue jigsaw pieces in the logo represent the different languages in Epsilon , while the purple pieces represent the different modelling technologies that Epsilon programs can operate on.","title":"What do the name and the logo mean?"},{"location":"branding/#license","text":"As with everything else in Epsilon, the logos are licensed under the Eclipse Public License 2.0 .","title":"License"},{"location":"doc/","text":"Documentation \u00b6 Epsilon is a family of languages and tools implemented in Java, for automating common model-based software engineering tasks. Languages \u00b6 At the core of Epsilon is the Epsilon Object Language (EOL) , a scripting language that combines the imperative style of languages like Java/JavaScript with the powerful functional model querying capabilities of OCL . On top of EOL, Epsilon provides a number of interoperable task-specific languages for tasks such as code generation, model-to-model transformation and model validation. Epsilon languages are underpinnd by a model connectivity layer that shields them from the specifics of individual modeling technologies and allows them to query and modify models that conform to different technologies in a uniform way (e.g. transform an EMF model into Simulink, cross-validate an XML document and a UML model). graph TD ECL[\"Model<br/>comparison<br/>(ECL)\"] Flock[\"Model<br/>migration<br/>(Flock)\"] EGL[\"Code<br/>generation<br/>(EGL)\"] EVL[\"Model<br/>validation<br/>(EVL)\"] EPL[\"Pattern<br/>Matching<br/>(EPL)\"] EML[\"Model<br/>Merging<br/>(EML)\"] ETL[\"M2M<br/>Transformation<br/>(ETL)\"] EOL[\"Epsilon Object Language (EOL)\"] ETL --> |extends|EOL EML --> |uses for matching|ECL EML --> |extends|ETL EPL --> |extends|EOL ECL --> |extends|EOL EGL --> |preprocessed into|EOL EVL --> |extends|EOL Flock --> |extends|EOL Pinset --> |extends|EOL EMC[\"Epsilon Model Connectivity (EMC)\"] EMF[\"Eclipse Modeling<br/> Framework (EMF)\"] Simulink[\"MATLAB<br/>Simulink\"] Excel[\"Excel<br/>Speadsheets\"] PTC[\"PTC Integrity<br/>Modeller\"] Dots[\"...\"] EOL -->|accesses models through| EMC EMC --- EMF EMC --- Simulink EMC --- XML EMC --- Excel EMC --- PTC EMC --- CSV EMC --- Dots classDef eol fill:#CCCCCC; class EOL eol; classDef emc fill:#AFAFAF; class EMC emc; classDef language fill:#ffffff; class ETL,Flock,EGL,EVL,ECL,EPL,EML,Pinset language; classDef driver fill:#E8E8E8; class EMF,XML,CSV,Simulink,Excel,PTC,Dots driver; Task-Specific Languages \u00b6 Epsilon provides the following task-specific languages, which use EOL as their core expression language. Each task-specific language provides constructs and syntax that are tailored to the specific task it targets: Epsilon Generation Language (EGL) : A template-based model-to-text language for generating code, documentation and other textual artefacts from models. EGL supports content-destination decoupling, protected regions for mixing generated with hand-written code. EGL also provides a rule-based coordination language ( EGX ), that allows specific EGL templates to be executed for a specific model element type, with the ability to guard rule execution and specify generation target location by type/element. Epsilon Transformation Language (ETL) : A rule-based model-to-model transformation language that supports transforming many input to many output models, rule inheritance, lazy and greedy rules, and the ability to query and modify both input and output models. Epsilon Validation Language (EVL) : A model validation language that supports both intra and inter-model consistency checking, constraint dependency management and specifying fixes that users can invoke to repair identified inconsistencies. EVL is integrated with EMF/GMF and as such, EVL constraints can be evaluated from within EMF/GMF editors and generate error markers for failed constraints. Epsilon Wizard Language (EWL) : A language tailored to interactive in-place model transformations on model elements selected by the user. EWL is integrated with EMF/GMF and as such, wizards can be executed from within EMF and GMF editors. Epsilon Comparison Language (ECL) : A rule-based language for discovering correspondences (matches) between elements of models of diverse metamodels. Epsilon Merging Language (EML) : A rule-based language for merging models of diverse metamodels, after first identifying their correspondences with ECL (or otherwise). Epsilon Pattern Language (EPL) : A pattern language for matching model elements based on element relations and characteristics. Epsilon Model Generation Language (EMG) : A language for semi-automated model generation. Epsilon Flock : A rule-based transformation language for updating models in response to metamodel changes. EUnit : EUnit is a unit testing framework specialized on testing model management tasks, such as model-to-model transformations, model-to-text transformations or model validation. It is based on Epsilon, but it can be used for model technologies external to Epsilon. Tests are written by combining an EOL script and an ANT buildfile. Pinset : A rule-based domain-specific transformation language that allows extracting tabular datasets (i.e. CSVs) from input models. Tools \u00b6 In addition to the languages above, Epsilon also provides several tools and utilities for working with models. Graphical Modelling \u00b6 Picto : Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. Compared to existing graphical modelling frameworks such as Sirius and GMF, the main appeal of Picto is that model visualisation takes place in an embedded browser and therefore you can leverage any HTML/SVG/JavaScript-based technology such as D3.js, mxGraph and JointJS. Picto also provides built-in support for the powerful Graphviz and PlantUML textual syntaxes (which are transformed to SVG via the respective tools). A distinguishing feature of Picto is does not require running multiple Eclipse instances as the metamodels, models and visualisation transformations can all reside in the same workspace. Eugenia : Eugenia is a front-end for GMF. Its aim is to speed up the process of developing a GMF editor and lower the entrance barrier for new developers. To this end, Eugenia enables developers to generate a fully-functional GMF editor only by specifying a few high-level annotations in the Ecore metamodel. Textual Modelling \u00b6 Flexmi : Flexmi is a flexible, reflective textual syntax for creating models conforming to Ecore (EMF) metamodels. Flexmi is XML-based and offers features such as fuzzy matching of XML tags and attributes to Ecore class/feature names, support for embedding EOL expressions in models and for defining and instantiating model element templates. Human Usable Textual Notation : An implementation of the OMG standard for representing models in a human understandable format. HUTN allows models to be written using a text editor in a C-like syntax. EMF Utilities \u00b6 Exeed : Exeed is an enhanced version of the built-in EMF reflective tree-based editor that enables developers to customize the labels and icons of model elements simply by attaching a few simple annotations to the respective EClasses in the Ecore metamodel. Exeed also supports setting the values of references using drag-and-drop instead of using the combo boxes in the properties view. ModeLink : ModeLink is an editor consisting of 2-3 side-by-side EMF tree-based editors, and is very convenient for establishing (weaving) links between different models using drag-and-drop. Workflow \u00b6 Workflow : Epsilon provides a set of ANT tasks to enable developers assemble complex workflows that involve both MDE and non-MDE tasks.","title":"Overview"},{"location":"doc/#documentation","text":"Epsilon is a family of languages and tools implemented in Java, for automating common model-based software engineering tasks.","title":"Documentation"},{"location":"doc/#languages","text":"At the core of Epsilon is the Epsilon Object Language (EOL) , a scripting language that combines the imperative style of languages like Java/JavaScript with the powerful functional model querying capabilities of OCL . On top of EOL, Epsilon provides a number of interoperable task-specific languages for tasks such as code generation, model-to-model transformation and model validation. Epsilon languages are underpinnd by a model connectivity layer that shields them from the specifics of individual modeling technologies and allows them to query and modify models that conform to different technologies in a uniform way (e.g. transform an EMF model into Simulink, cross-validate an XML document and a UML model). graph TD ECL[\"Model<br/>comparison<br/>(ECL)\"] Flock[\"Model<br/>migration<br/>(Flock)\"] EGL[\"Code<br/>generation<br/>(EGL)\"] EVL[\"Model<br/>validation<br/>(EVL)\"] EPL[\"Pattern<br/>Matching<br/>(EPL)\"] EML[\"Model<br/>Merging<br/>(EML)\"] ETL[\"M2M<br/>Transformation<br/>(ETL)\"] EOL[\"Epsilon Object Language (EOL)\"] ETL --> |extends|EOL EML --> |uses for matching|ECL EML --> |extends|ETL EPL --> |extends|EOL ECL --> |extends|EOL EGL --> |preprocessed into|EOL EVL --> |extends|EOL Flock --> |extends|EOL Pinset --> |extends|EOL EMC[\"Epsilon Model Connectivity (EMC)\"] EMF[\"Eclipse Modeling<br/> Framework (EMF)\"] Simulink[\"MATLAB<br/>Simulink\"] Excel[\"Excel<br/>Speadsheets\"] PTC[\"PTC Integrity<br/>Modeller\"] Dots[\"...\"] EOL -->|accesses models through| EMC EMC --- EMF EMC --- Simulink EMC --- XML EMC --- Excel EMC --- PTC EMC --- CSV EMC --- Dots classDef eol fill:#CCCCCC; class EOL eol; classDef emc fill:#AFAFAF; class EMC emc; classDef language fill:#ffffff; class ETL,Flock,EGL,EVL,ECL,EPL,EML,Pinset language; classDef driver fill:#E8E8E8; class EMF,XML,CSV,Simulink,Excel,PTC,Dots driver;","title":"Languages"},{"location":"doc/#task-specific-languages","text":"Epsilon provides the following task-specific languages, which use EOL as their core expression language. Each task-specific language provides constructs and syntax that are tailored to the specific task it targets: Epsilon Generation Language (EGL) : A template-based model-to-text language for generating code, documentation and other textual artefacts from models. EGL supports content-destination decoupling, protected regions for mixing generated with hand-written code. EGL also provides a rule-based coordination language ( EGX ), that allows specific EGL templates to be executed for a specific model element type, with the ability to guard rule execution and specify generation target location by type/element. Epsilon Transformation Language (ETL) : A rule-based model-to-model transformation language that supports transforming many input to many output models, rule inheritance, lazy and greedy rules, and the ability to query and modify both input and output models. Epsilon Validation Language (EVL) : A model validation language that supports both intra and inter-model consistency checking, constraint dependency management and specifying fixes that users can invoke to repair identified inconsistencies. EVL is integrated with EMF/GMF and as such, EVL constraints can be evaluated from within EMF/GMF editors and generate error markers for failed constraints. Epsilon Wizard Language (EWL) : A language tailored to interactive in-place model transformations on model elements selected by the user. EWL is integrated with EMF/GMF and as such, wizards can be executed from within EMF and GMF editors. Epsilon Comparison Language (ECL) : A rule-based language for discovering correspondences (matches) between elements of models of diverse metamodels. Epsilon Merging Language (EML) : A rule-based language for merging models of diverse metamodels, after first identifying their correspondences with ECL (or otherwise). Epsilon Pattern Language (EPL) : A pattern language for matching model elements based on element relations and characteristics. Epsilon Model Generation Language (EMG) : A language for semi-automated model generation. Epsilon Flock : A rule-based transformation language for updating models in response to metamodel changes. EUnit : EUnit is a unit testing framework specialized on testing model management tasks, such as model-to-model transformations, model-to-text transformations or model validation. It is based on Epsilon, but it can be used for model technologies external to Epsilon. Tests are written by combining an EOL script and an ANT buildfile. Pinset : A rule-based domain-specific transformation language that allows extracting tabular datasets (i.e. CSVs) from input models.","title":"Task-Specific Languages"},{"location":"doc/#tools","text":"In addition to the languages above, Epsilon also provides several tools and utilities for working with models.","title":"Tools"},{"location":"doc/#graphical-modelling","text":"Picto : Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. Compared to existing graphical modelling frameworks such as Sirius and GMF, the main appeal of Picto is that model visualisation takes place in an embedded browser and therefore you can leverage any HTML/SVG/JavaScript-based technology such as D3.js, mxGraph and JointJS. Picto also provides built-in support for the powerful Graphviz and PlantUML textual syntaxes (which are transformed to SVG via the respective tools). A distinguishing feature of Picto is does not require running multiple Eclipse instances as the metamodels, models and visualisation transformations can all reside in the same workspace. Eugenia : Eugenia is a front-end for GMF. Its aim is to speed up the process of developing a GMF editor and lower the entrance barrier for new developers. To this end, Eugenia enables developers to generate a fully-functional GMF editor only by specifying a few high-level annotations in the Ecore metamodel.","title":"Graphical Modelling"},{"location":"doc/#textual-modelling","text":"Flexmi : Flexmi is a flexible, reflective textual syntax for creating models conforming to Ecore (EMF) metamodels. Flexmi is XML-based and offers features such as fuzzy matching of XML tags and attributes to Ecore class/feature names, support for embedding EOL expressions in models and for defining and instantiating model element templates. Human Usable Textual Notation : An implementation of the OMG standard for representing models in a human understandable format. HUTN allows models to be written using a text editor in a C-like syntax.","title":"Textual Modelling"},{"location":"doc/#emf-utilities","text":"Exeed : Exeed is an enhanced version of the built-in EMF reflective tree-based editor that enables developers to customize the labels and icons of model elements simply by attaching a few simple annotations to the respective EClasses in the Ecore metamodel. Exeed also supports setting the values of references using drag-and-drop instead of using the combo boxes in the properties view. ModeLink : ModeLink is an editor consisting of 2-3 side-by-side EMF tree-based editors, and is very convenient for establishing (weaving) links between different models using drag-and-drop.","title":"EMF Utilities"},{"location":"doc/#workflow","text":"Workflow : Epsilon provides a set of ANT tasks to enable developers assemble complex workflows that involve both MDE and non-MDE tasks.","title":"Workflow"},{"location":"doc/ecl/","text":"The Epsilon Comparison Language (ECL) \u00b6 Model comparison is the task of identifying matching elements between models. In general, matching elements are elements that are involved in a relationship of interest. For example, before merging homogeneous models, it is essential to identify overlapping (common) elements so that they do not appear in duplicate in the merged model. Similarly, in heterogeneous model merging, it is a prerequisite to identify the elements on which the two models will be merged. Finally, in transformation testing, matching elements are pairs consisting of elements in the input model and their generated counterparts in the output model. The aim of the Epsilon Comparison Language (ECL) is to enable users to specify comparison algorithms in a rule-based manner to identify pairs of matching elements between two models of potentially different metamodels and modelling technologies. In this section, the abstract and concrete syntax, as well as the execution semantics of the language, are discussed in detail. Abstract Syntax \u00b6 In ECL, comparison specifications are organized in modules ( EcLModule ). As illustrated below, EclModule (indirectly) extends EolModule which means that it can contain user-defined operations and import other library modules and ECL modules. Apart from operations, an ECL module contains a set of match-rules ( MatchRule ) and a set of pre and post blocks than run before and after all comparisons, respectively. MatchRules enable users to perform comparison of model elements at a high level of abstraction. Each match-rule declares a name, and two parameters ( leftParameter and rightParameter ) that specify the types of elements it can compare. It also optionally defines a number of rules it inherits ( extends ) and if it is abstract , lazy and/or greedy . The semantics of the latter are discussed shortly. classDiagram class MatchRule { -name: String -abstract: Boolean -lazy: Boolean -unique: Boolean -greedy: Boolean -guard: ExecutableBlock<Boolean> -compare: ExecutableBlock<Boolean> -do: ExecutableBlock<Void> } class Parameter { -name: String -type: EolType } class NamedStatementBlockRule { -name: String -body: StatementBlock } EolModule <|-- ErlModule EclModule --|> ErlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EclModule -- MatchRule: rules * MatchRule -- Parameter: left MatchRule -- Parameter: right MatchRule -- MatchRule: extends * A match rule has three parts. The guard part is an EOL expression or statement block that further limits the applicability of the rule to an even narrower range of elements than that specified by the left and right parameters. The compare part is an EOL expression or statement block that is responsible for comparing a pair of elements and deciding if they match or not. Finally, the do part is an EOL expression or block that is executed if the compare part returns true to perform any additional actions required. Pre and post blocks are named blocks of EOL statements which as discussed in the sequel are executed before and after the match-rules have been executed respectively. Concrete Syntax \u00b6 The concrete syntax of a match-rule is displayed below. (@lazy)? (@greedy)? (@abstract)? rule <name> match <leftParameterName>:<leftParameterType> with <rightParameterName>:<rightParameterType> (extends <ruleName>(, <ruleName>)*)? { (guard (:expression)|({statementBlock}))? compare (:expression)|({statementBlock}) (do {statementBlock})? } Pre and post blocks have a simple syntax that, as shown below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ } Execution Semantics \u00b6 Rule and Block Overriding \u00b6 An ECL module can import a number of other ECL modules. In such a case, the importing ECL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively. Comparison Outcome \u00b6 As illustrated below, the result of comparing two models with ECL is a trace ( MatchTrace ) that consists of a number of matches ( Match ). Each match holds a reference to the objects from the two models that have been compared ( left and right ), a boolean value that indicates if they have been found to be matching or not, a reference to the rule that has made the decision, and a Map ( info ) that is used to hold any additional information required by the user (accessible at runtime through the matchInfo implicit variable). During the matching process, a second, temporary, match trace is also used to detect and resolve cyclic invocation of match-rules as discussed in the sequel. classDiagram class Match { -left: Object -right: Object -matching: Boolean } class EclContext { -matchTrace: MatchTrace -tempMatchTrace: MatchTrace } MatchRule -- Match: rule MatchTrace -- Match: matches * EclContext --|> EolContext EclContext -- MatchTrace Map -- Match: info Rule Execution Scheduling \u00b6 Non-abstract, non-lazy match-rules are evaluated automatically by the execution engine in a top-down fashion - with respect to their order of appearance - in two passes. In the first pass, each rule is evaluated for all the pairs of instances in the two models that have a type-of relationship with the types specified by the leftParameter and rightParameter of the rule. In the second pass, each rule that is marked as greedy is executed for all pairs that have not been compared in the first pass, and which have a kind-of relationship with the types specified by the rule. In both passes, to evaluate the compare part of the rule, the guard must be satisfied. Before the compare part of a rule is executed, the compare parts of all of the rules it extends (super-rules) must be executed (recursively). Before executing the compare part of a super-rule, the engine verifies that the super-rule is actually applicable to the elements under comparison by checking for type conformance and evaluating the guard part of the super-rule. If the compare part of a rule evaluates to true, the optional do part is executed. In the do part the user can specify any actions that need to be performed for the identified matching elements, such as to populate the info map of the established match with additional information. Finally, a new match is added to the match trace that has its matching property set to the logical conjunction of the results of the evaluation of the compare parts of the rule and its super-rules. The matches() built-in operation \u00b6 To refrain from performing duplicate comparisons and to de-couple match-rules from each other, ECL provides the built-in matches(opposite : Any) operation for model elements and collections. When the matches() operation is invoked on a pair of objects, it queries the main and temporary match-traces to discover if the two elements have already been matched and if so it returns the cached result of the comparison. Otherwise, it attempts to find an appropriate match rule to compare the two elements and if such a rule is found, it returns the result of the comparison, otherwise it returns false. Unlike the top-level execution scheme, the matches() operation invokes both lazy and non-lazy rules. In addition to objects, the matches operations can also be invoked to match pairs of collections of the same type (e.g. a Sequence against a Sequence). When invoked on ordered collections (i.e. Sequence and OrderedSet ), it examines if the collections have the same size and each item of the source collection matches with the item of the same index in the target collection. Finally, when invoked on unordered collections (i.e. Bag and Set ), it examines if for each item in the source collection, there is a matching item in the target collection irrespective of its index. Users can also override the built-in matches operation using user-defined operations with the same name, that loosen or strengthen the built-in semantics. Cyclic invocation of matches() \u00b6 Providing the built-in matches operation significantly simplifies comparison specifications. It also enhances decoupling between match-rules from each other as when a rule needs to compare two elements that are outside its scope, it does not need to know/specify which other rule can compare those elements explicitly. On the other hand, it is possible - and quite common indeed - for two rules to implicitly invoke each other. For example consider the match rule below that attempts to match nodes of the simple Tree metamodel. classDiagram class Tree { +label: String +parent: Tree +children: Tree[*] } Tree -- Tree rule Tree2Tree match l : T1!Tree with r : T2!Tree { compare : l.label = r.label and l.parent.matches(r.parent) and l.children.matches(r.children) } The rule specifies that for two Tree nodes ( l and r ) to match, they should have the same label, belong to matching parents and have matching children. In the absence of a dedicated mechanism for cycle detection and resolution, the rule would end up in an infinite loop. To address this problem, ECL provides a temporary match-trace which is used to detect and resolve cyclic invocations of the match() built-in operation. As discussed above, a match is added to the primary match-trace as soon as the compare part of the rule has been executed to completion. By contrast, a temporary match (with its matching property set to true ) is added to the temporary trace before the compare part is executed. In this way, any subsequent attempts to match the two elements from invoked rules will not re-invoke the rule. Finally, when a top-level rule returns, the temporary match trace is reset. Fuzzy and Dictionary-based String Matching \u00b6 In the example above, the rule specifies that to match, two trees must - among other criteria - have the same label. However, there are cases when a less-strict approach to matching string properties of model elements is desired. For instance, when comparing two UML models originating from different organizations, it is common to encounter ontologically equivalent classes which however have different names (e.g. Client and Customer). In this case, to achieve a more sound matching, the use of a dictionary or a lexical database (e.g. WordNet) is necessary. Alternatively, fuzzy string matching algorithms can be used. As several such tools and algorithms have been implemented in various programming languages, it is a sensible approach to reuse them instead of re-implementing them. For example, in the listing below a wrapper for the Simmetrics fuzzy string comparison tool is used to compare the labels of the trees using the Levenshtein algorithm. To achieve this, line 11 invokes the fuzzyMatch() operation defined in lines 16-18 which uses the simmterics native tool (instantiated in lines 2-4) to match the two labels using their Levenshtein distance with a threshold of 0.5. pre { var simmetrics = new Native(\"org.epsilon.ecl.tools. textcomparison.simmetrics.SimMetricsTool\"); } rule FuzzyTree2Tree match l : T1!Tree with r : T2!Tree { compare : l.label.fuzzyMatch(r.label) and l.parent.matches(r.parent) and l.children.matches(r.children) } operation String fuzzyMatch(other : String) : Boolean { return simmetrics.similarity(self,other,\"Levenshtein\") > 0.5; } The Match Trace \u00b6 Users can query and modify the match trace calculated during the comparison process in the post sections of the module or export it into another application or Epsilon program. For example, in a post section, the trace can be printed to the default output stream or serialized into a model of an arbitrary metamodel. In another use case, the trace may be exported to be used in the context of a validation module that will use the identified matches to evaluate inter-model constraints, or in a merging module that will use the matches to identify the elements on which the two models will be merged. Querying Match Traces Please note that match traces computed by ECL contain both successful and unsuccessful matches, and can therefore become slow to query as compared models grow in size. If you are only interested in successful matches when querying your match trace, you can use matchTrace.getReduced() to produce a reduced trace that only contains successful matches.","title":"Model Comparison (ECL)"},{"location":"doc/ecl/#the-epsilon-comparison-language-ecl","text":"Model comparison is the task of identifying matching elements between models. In general, matching elements are elements that are involved in a relationship of interest. For example, before merging homogeneous models, it is essential to identify overlapping (common) elements so that they do not appear in duplicate in the merged model. Similarly, in heterogeneous model merging, it is a prerequisite to identify the elements on which the two models will be merged. Finally, in transformation testing, matching elements are pairs consisting of elements in the input model and their generated counterparts in the output model. The aim of the Epsilon Comparison Language (ECL) is to enable users to specify comparison algorithms in a rule-based manner to identify pairs of matching elements between two models of potentially different metamodels and modelling technologies. In this section, the abstract and concrete syntax, as well as the execution semantics of the language, are discussed in detail.","title":"The Epsilon Comparison Language (ECL)"},{"location":"doc/ecl/#abstract-syntax","text":"In ECL, comparison specifications are organized in modules ( EcLModule ). As illustrated below, EclModule (indirectly) extends EolModule which means that it can contain user-defined operations and import other library modules and ECL modules. Apart from operations, an ECL module contains a set of match-rules ( MatchRule ) and a set of pre and post blocks than run before and after all comparisons, respectively. MatchRules enable users to perform comparison of model elements at a high level of abstraction. Each match-rule declares a name, and two parameters ( leftParameter and rightParameter ) that specify the types of elements it can compare. It also optionally defines a number of rules it inherits ( extends ) and if it is abstract , lazy and/or greedy . The semantics of the latter are discussed shortly. classDiagram class MatchRule { -name: String -abstract: Boolean -lazy: Boolean -unique: Boolean -greedy: Boolean -guard: ExecutableBlock<Boolean> -compare: ExecutableBlock<Boolean> -do: ExecutableBlock<Void> } class Parameter { -name: String -type: EolType } class NamedStatementBlockRule { -name: String -body: StatementBlock } EolModule <|-- ErlModule EclModule --|> ErlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EclModule -- MatchRule: rules * MatchRule -- Parameter: left MatchRule -- Parameter: right MatchRule -- MatchRule: extends * A match rule has three parts. The guard part is an EOL expression or statement block that further limits the applicability of the rule to an even narrower range of elements than that specified by the left and right parameters. The compare part is an EOL expression or statement block that is responsible for comparing a pair of elements and deciding if they match or not. Finally, the do part is an EOL expression or block that is executed if the compare part returns true to perform any additional actions required. Pre and post blocks are named blocks of EOL statements which as discussed in the sequel are executed before and after the match-rules have been executed respectively.","title":"Abstract Syntax"},{"location":"doc/ecl/#concrete-syntax","text":"The concrete syntax of a match-rule is displayed below. (@lazy)? (@greedy)? (@abstract)? rule <name> match <leftParameterName>:<leftParameterType> with <rightParameterName>:<rightParameterType> (extends <ruleName>(, <ruleName>)*)? { (guard (:expression)|({statementBlock}))? compare (:expression)|({statementBlock}) (do {statementBlock})? } Pre and post blocks have a simple syntax that, as shown below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ }","title":"Concrete Syntax"},{"location":"doc/ecl/#execution-semantics","text":"","title":"Execution Semantics"},{"location":"doc/ecl/#rule-and-block-overriding","text":"An ECL module can import a number of other ECL modules. In such a case, the importing ECL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.","title":"Rule and Block Overriding"},{"location":"doc/ecl/#comparison-outcome","text":"As illustrated below, the result of comparing two models with ECL is a trace ( MatchTrace ) that consists of a number of matches ( Match ). Each match holds a reference to the objects from the two models that have been compared ( left and right ), a boolean value that indicates if they have been found to be matching or not, a reference to the rule that has made the decision, and a Map ( info ) that is used to hold any additional information required by the user (accessible at runtime through the matchInfo implicit variable). During the matching process, a second, temporary, match trace is also used to detect and resolve cyclic invocation of match-rules as discussed in the sequel. classDiagram class Match { -left: Object -right: Object -matching: Boolean } class EclContext { -matchTrace: MatchTrace -tempMatchTrace: MatchTrace } MatchRule -- Match: rule MatchTrace -- Match: matches * EclContext --|> EolContext EclContext -- MatchTrace Map -- Match: info","title":"Comparison Outcome"},{"location":"doc/ecl/#rule-execution-scheduling","text":"Non-abstract, non-lazy match-rules are evaluated automatically by the execution engine in a top-down fashion - with respect to their order of appearance - in two passes. In the first pass, each rule is evaluated for all the pairs of instances in the two models that have a type-of relationship with the types specified by the leftParameter and rightParameter of the rule. In the second pass, each rule that is marked as greedy is executed for all pairs that have not been compared in the first pass, and which have a kind-of relationship with the types specified by the rule. In both passes, to evaluate the compare part of the rule, the guard must be satisfied. Before the compare part of a rule is executed, the compare parts of all of the rules it extends (super-rules) must be executed (recursively). Before executing the compare part of a super-rule, the engine verifies that the super-rule is actually applicable to the elements under comparison by checking for type conformance and evaluating the guard part of the super-rule. If the compare part of a rule evaluates to true, the optional do part is executed. In the do part the user can specify any actions that need to be performed for the identified matching elements, such as to populate the info map of the established match with additional information. Finally, a new match is added to the match trace that has its matching property set to the logical conjunction of the results of the evaluation of the compare parts of the rule and its super-rules.","title":"Rule Execution Scheduling"},{"location":"doc/ecl/#the-matches-built-in-operation","text":"To refrain from performing duplicate comparisons and to de-couple match-rules from each other, ECL provides the built-in matches(opposite : Any) operation for model elements and collections. When the matches() operation is invoked on a pair of objects, it queries the main and temporary match-traces to discover if the two elements have already been matched and if so it returns the cached result of the comparison. Otherwise, it attempts to find an appropriate match rule to compare the two elements and if such a rule is found, it returns the result of the comparison, otherwise it returns false. Unlike the top-level execution scheme, the matches() operation invokes both lazy and non-lazy rules. In addition to objects, the matches operations can also be invoked to match pairs of collections of the same type (e.g. a Sequence against a Sequence). When invoked on ordered collections (i.e. Sequence and OrderedSet ), it examines if the collections have the same size and each item of the source collection matches with the item of the same index in the target collection. Finally, when invoked on unordered collections (i.e. Bag and Set ), it examines if for each item in the source collection, there is a matching item in the target collection irrespective of its index. Users can also override the built-in matches operation using user-defined operations with the same name, that loosen or strengthen the built-in semantics.","title":"The matches() built-in operation"},{"location":"doc/ecl/#cyclic-invocation-of-matches","text":"Providing the built-in matches operation significantly simplifies comparison specifications. It also enhances decoupling between match-rules from each other as when a rule needs to compare two elements that are outside its scope, it does not need to know/specify which other rule can compare those elements explicitly. On the other hand, it is possible - and quite common indeed - for two rules to implicitly invoke each other. For example consider the match rule below that attempts to match nodes of the simple Tree metamodel. classDiagram class Tree { +label: String +parent: Tree +children: Tree[*] } Tree -- Tree rule Tree2Tree match l : T1!Tree with r : T2!Tree { compare : l.label = r.label and l.parent.matches(r.parent) and l.children.matches(r.children) } The rule specifies that for two Tree nodes ( l and r ) to match, they should have the same label, belong to matching parents and have matching children. In the absence of a dedicated mechanism for cycle detection and resolution, the rule would end up in an infinite loop. To address this problem, ECL provides a temporary match-trace which is used to detect and resolve cyclic invocations of the match() built-in operation. As discussed above, a match is added to the primary match-trace as soon as the compare part of the rule has been executed to completion. By contrast, a temporary match (with its matching property set to true ) is added to the temporary trace before the compare part is executed. In this way, any subsequent attempts to match the two elements from invoked rules will not re-invoke the rule. Finally, when a top-level rule returns, the temporary match trace is reset.","title":"Cyclic invocation of matches()"},{"location":"doc/ecl/#fuzzy-and-dictionary-based-string-matching","text":"In the example above, the rule specifies that to match, two trees must - among other criteria - have the same label. However, there are cases when a less-strict approach to matching string properties of model elements is desired. For instance, when comparing two UML models originating from different organizations, it is common to encounter ontologically equivalent classes which however have different names (e.g. Client and Customer). In this case, to achieve a more sound matching, the use of a dictionary or a lexical database (e.g. WordNet) is necessary. Alternatively, fuzzy string matching algorithms can be used. As several such tools and algorithms have been implemented in various programming languages, it is a sensible approach to reuse them instead of re-implementing them. For example, in the listing below a wrapper for the Simmetrics fuzzy string comparison tool is used to compare the labels of the trees using the Levenshtein algorithm. To achieve this, line 11 invokes the fuzzyMatch() operation defined in lines 16-18 which uses the simmterics native tool (instantiated in lines 2-4) to match the two labels using their Levenshtein distance with a threshold of 0.5. pre { var simmetrics = new Native(\"org.epsilon.ecl.tools. textcomparison.simmetrics.SimMetricsTool\"); } rule FuzzyTree2Tree match l : T1!Tree with r : T2!Tree { compare : l.label.fuzzyMatch(r.label) and l.parent.matches(r.parent) and l.children.matches(r.children) } operation String fuzzyMatch(other : String) : Boolean { return simmetrics.similarity(self,other,\"Levenshtein\") > 0.5; }","title":"Fuzzy and Dictionary-based String Matching"},{"location":"doc/ecl/#the-match-trace","text":"Users can query and modify the match trace calculated during the comparison process in the post sections of the module or export it into another application or Epsilon program. For example, in a post section, the trace can be printed to the default output stream or serialized into a model of an arbitrary metamodel. In another use case, the trace may be exported to be used in the context of a validation module that will use the identified matches to evaluate inter-model constraints, or in a merging module that will use the matches to identify the elements on which the two models will be merged. Querying Match Traces Please note that match traces computed by ECL contain both successful and unsuccessful matches, and can therefore become slow to query as compared models grow in size. If you are only interested in successful matches when querying your match trace, you can use matchTrace.getReduced() to produce a reduced trace that only contains successful matches.","title":"The Match Trace"},{"location":"doc/egl/","text":"The Epsilon Generation Language (EGL) \u00b6 EGL is a model-to-text transformation (M2T) language that can be used to transform models into various types of textual artefact, including code (e.g. Java), reports (e.g. in HTML/LaTeX), images (e.g. using Graphviz ), formal specifications, or even entire applications comprising code in multiple languages (e.g. HTML, Javascript and CSS). EGL is a template-based language (i.e. EGL programs resemble the text that they generate), and provides several features that simplify and support the generation of text from models, including: a sophisticated and language-independent merging engine (for preserving hand-written sections of generated text), an extensible template system (for generating text to a variety of sources, such as a file on disk, a database server, or even as a response issued by a web server), formatting algorithms (for producing generated text that is well-formatted and hence readable), and traceability mechanisms (for linking generated text with source models). Try EGL online You can run and fiddle with an EGL template that generates an ASCII-based Gantt chart from a project scheduling model in the online Epsilon Playground . Abstract Syntax \u00b6 The figure below shows the abstract syntax of EGL's core functionality. Info As with most languages in Epsilon, EGL uses EOL as its expression language. This page only documents the additional syntax and semantics that EGL provides on top of EOL. classDiagram class EglSection { +getChildren(): List +getText(): String } class EglDynamicSection { +getText(): String } class EglStaticSection { +getText(): String } class EglShortcutSection { +getText(): String } EglSection <|-- EglDynamicSection EglSection <|-- EglStaticSection EglSection <|-- EglShortcutSection Conceptually, an EGL program comprises one or more sections . The contents of static sections are emitted verbatim and appear directly in the generated text. The contents of dynamic sections are executed and are used to control the text that is generated. In its dynamic sections, EGL re-uses EOL's syntax for structuring program control flow, performing model inspection and navigation, and defining custom operations. In addition, EGL provides an EOL object, out , which is used in dynamic sections to perform operations on the generated text, such as appending and removing strings; and specifying the type of text to be generated. EGL also provides syntax for defining dynamic output sections, which provide a convenient shorthand for outputting text from within dynamic sections. Similar syntax is often provided by template-based code generators. Concrete Syntax \u00b6 The concrete syntax of EGL closely resembles the style of other template-based code generation languages, such as PHP. The tag pair [% %] is used to delimit a dynamic section. Any text not enclosed in such a tag pair is contained in a static section. The listing below illustrates the use of dynamic and static sections to form a basic EGL template. [% for (i in Sequence{1..5}) { %] i is [%=i%] [% } %] Executing the EGL template above would produce the generated text below. The [%=expr%] construct (line 2) is shorthand for [% out.print(expr); %] , which appends expr to the output generated by the transformation. i is 1 i is 2 i is 3 i is 4 i is 5 Any EOL statement can be contained in the dynamic sections of an EGL template. For example, the EGL template shown below generates text from a model that conforms to a metamodel that describes an object-oriented system. [% for (c in Class.all) { %] [%=c.name%] [% } %] Comments and Markers \u00b6 Inside an EGL dynamic section, EOL's comment syntax can be used. Additionally, EGL adds syntax for comment blocks [* this is a comment *] and marker blocks [*- this is a marker *] . Marker blocks are highlighted by the EGL editor and EGL outline view in Eclipse. User-Defined Operations \u00b6 Like EOL, EGL permits users to define re-usable units of code via operations. [% c.declaration(); %] [% operation Class declaration() { %] [%=self.visibility%] class [%=self.name%] {} [% } %] In EGL, user-defined operations are defined in dynamic sections, but may mix static and dynamic sections in their bodies. Consider, for example, the EGL code in the listing above, which emits a declaration for a Java class (e.g. public class Foo {} ). Lines 2-4 declare the operation. Note that the start and the end of the operation's declaration (on lines 2 and 4, respectively) are contained in dynamic sections. The body of the operation (line 3), however, mixes static and dynamic output sections. Finally, note that the operation is invoked from a dynamic section (line 1). It is worth noting that any loose (i.e. not contained in other operations) dynamic or static sections below the first operation of a template will be ignored at runtime. When a user-defined operation is invoked, any static or dynamic sections contained in the body of the operation are immediately appended to the generated text. Sometimes, however, it is desirable to manipulate the text produced by an operation before it is appended to the generated text. To this end, EGL defines the @template annotation which can applied to operations to indicate that any text generated by the operation must be returned from the operation and not appended to the generated text. For example, the EGL program in the listing above could be rewritten using a @template annotation, as demonstrated below. [%=c.declaration()%] [% @template operation Class declaration() { %] [%=self.visibility%] class [%=self.name%] {} [% } %] There is a subtle difference between the way in which standard (i.e. unannotated) operations and @template operations are invoked. Compare the first line of the two listings above. The former uses a dynamic section, because invoking the operation causes the evaluation of its body to be appended to the text generated by this program. By contrast, the latter uses a dynamic output section to append the result returned by the @template operation to the text generated by this program. In general, @template operations afford more flexibility than standard operations. For example, line 1 of the listing above could perform some manipulation of the text returned by the declaration() operation before the text is outputted. Therefore, @template operations provide a mechanism for re-using common pieces of a code generator, without sacrificing the flexibility to slightly alter text before it is emitted. Standard (unannotated) operations also permit re-use, but in a less flexible manner. Finally, it is worth noting that user-defined operations in EGL do not have to generate text. For example, the following listing illustrates two operations defined in an EGL program that do not generate any text. The former is a query that returns a Boolean value, while the latter alters the model, and does not return a value. [% operation Class isAnonymous() : Boolean { return self.name.isUndefined(); } operation removeOneClass() { delete Class.all.random(); } %] The OutputBuffer \u00b6 As an EGL program is executed, text is appended to a data structure termed the OutputBuffer . In every EGL program, the OutputBuffer is accessible via the out built-in variable. The OutputBuffer provides operations for appending to and removing from the buffer, and for merging generated text with existing text. For many EGL programs, interacting directly with the OutputBuffer is unnecessary. The contents of static and dynamic output sections are sent directly to the OutputBuffer , and no operation of the OutputBuffer need be invoked directly. However, in cases when generated text must be sent to the OutputBuffer from dynamic sections, or when generated text must be merged with existing text, the operations of OutputBuffer are provided in the table below. The [merge engine section]](#merge-engine) discusses merging generated and existing text, and presents several examples of invoking the operations of OutputBuffer . Signature Description chop(numberOfChars : Integer) Removes the specified number of characters from the end of the buffer print(object : Any) Appends a string representation of the specified object to the buffer println(object : Any) Appends a string representation of the specified object and a new line to the buffer println() Appends a new line to the buffer setContentType(contentType : String) Updates the content type of this template. Subsequent calls to preserve or startPreserve that do not specify a style of comment will use the style of comment defined by the specified content type. preserve(id : String, enabled : Boolean, contents : String) Appends a protected region to the buffer with the given identifier, enabled state and contents. Uses the current content type to determine how to format the start and end markers. preserve(startComment : String, endComment : String, id : String, enabled : Boolean, contents : String) Appends a protected region to the buffer with the given identifier, enabled state and contents. Uses the first two parameters as start and end markers. startPreserve(id : String, enabled : Boolean) Begins a protected region by appending the start marker for a protected region to the buffer with the given identifier and enabled state. Uses the current content type to determine how to format the start and end markers startPreserve(startComment : String, endComment : String, id : String, enabled : Boolean) Begins a protected region by appending the start marker to the buffer with the given identifier and enabled state. Uses the first two parameters as start and end markers. stopPreserve() Ends the current protected region by appending the end marker to the buffer. This operation should be invoked only if there a protected region is currently open (i.e. has been started by invoking startPreserve but not yet stopped by invoking stopPreserve ). setIndenters(indenters : Collection<String>) Sets the indentation characters for the buffer (default is \\t and four spaces). Co-ordination \u00b6 Warning The recommended way to coordinate the execution of EGL templates is using the EGX rule-based language . This section describes an imperative way to invoke EGL templates which pre-dates EGX and should only be used as a fall-back in case the semantics of EGX are not sufficient for the task at hand. In the large, M2T transformations are used to generate text to various destinations. For example, code generators often produce files on disk, and web applications often generate text as part of the response for a resource on the web server. Text might be generated to a network socket during interprocess communication, or as a query that runs on a database. Furthermore, (parts of) a single M2T transformation might be re-used in different contexts. A M2T transformation that generates files on disk today might be re-purposed to generate the response from a web server tomorrow. Given these concerns, EGL provides a co-ordination engine that provides mechanisms for modularising M2T transformations, and for controlling the destinations to which text is generated. The EGL co-ordination engine fulfils three requirements: Reusability : the co-ordination engine allows EGL programs to be decomposed into one or more templates, which can be shared between EGL programs. Variety of destination : the co-ordination engine provides an extensible set of template types that can generate text to a variety of destinations. The next section describes the default template type, which is tailored to generate text to files on disk, while a subsequent section discusses the way in which users can define their own template types for generating text to other types of destination. Separation of concerns : the co-ordination engine ensures that the logic for controlling the text that is generated (i.e. the content) and the logic for controlling the way in which text is emitted (i.e. the destination) are kept separate. There is also the EGX language , which was introduced after this documentation was initially written, but provides a fully-fledged rule-based execution engine for paramterising EGL templates. The Template type \u00b6 Central to the co-ordination engine is the Template type, which EGL provides in addition to the default EOL types. Via the Template type, EGL fulfils the three requirements identified above. Firstly, a Template can invoke other Templates , and hence can be shared and re-used between EGL programs. Secondly, the Template type has been implemented in an extensible manner: users can define their own types of Template that generate text to any destination (e.g. a database or a network socket), as described in the custom coordination section . Finally, the Template type provides a set of operations that are used to control the destination of generated text. Users typically define a \"driver\" template that does not generate text, but rather controls the destination of text that is generated by other templates. For example, consider the EGL program in the listing below. This template generates no text (as it contains only a single dynamic section), but is used instead to control the destination of text generated by another template. Line 1 defines a variable, t , of type Template . Note that, unlike the EOL types, instances of Template are not created with the new keyword. Instead, the TemplateFactory built-in object is used to load templates from, for example, a file system path. On line 3, the generate operation of the Template type invokes the EGL template stored in the file \"ClassNames.egl\" and emits the generated text to \"Output.txt\". [% var t : Template = TemplateFactory.load(\"ClassNames.egl\"); t.generate(\"Output.txt\"); %] In addition to generate , the Template type defines further operations for controlling the context and invocation of EGL templates. The following table lists all of the operations defined on Template , and a further example of their use is given in the sequel. Signature Description populate(name : String, value : Any) Makes a variable with the specified name and value available during the execution of the template. process() : String Executes the template and returns the text that is generated. generate(destination : String) Executes the template and stores the text to the specified destination. The format of the destination parameter is dictated by the type of template. For example, the default template type (which can generate files on disk) expects a file system path as the destination parameter. Returns a object representing the generated file. append(destination : String) Executes the template: if the destination exists, it will add a newline and the generated text at the end of the file. If the file does not exist, it will write the generated text to it (with no newline). Returns a object representing the generated file. setFormatter(formatter : Formatter) Changes the formatter for this template to the specified formatter. Subsequent calls to generate or process will produce text that is formatted with the specified formatter. setFormatters(formatters : Sequence(Formatter)) Changes the formatter for this template to the specified sequence of formatters. Subsequent calls to generate or process will produce text that is formatted with each of the specified formatters in turn. The TemplateFactory object \u00b6 As discussed above, instances of Template are not created with the new keyword. Instead, EGL provides a built-in object, the TemplateFactory , for this purpose. Users can customise the type of the TemplateFactory object to gain more control over the way in which text is generated. By default, EGL provides a TemplateFactory that exposes operations for loading templates (by loading files from disk), preparing templates (by parsing a string containing EGL code), and for controlling the file system locations from which templates are loaded and to which text is generated. The table below lists the operations provided by the built-in TemplateFactory object. Signature Description load(path : String) : Template Returns an instance of Template that can be used to execute the EGL template stored at the specified path. prepare(code : String) Changes the default path that is used to resolve relative paths when generating files to disk. Subsequent calls to load and prepare will create templates that use the new path. setOutputRoot(path : String) Changes the default path that is used to resolve relative paths when generating files to disk. Subsequent calls to load and prepare will create templates that use the new path. setTemplateRoot(path : String) Changes the default path that is used to resolve relative paths when loading templates with the load operation. Subsequent calls to load will use the new path. setDefaultFormatter(formatter : Formatter) Changes the formatter for this template factory to the specified formatter. Templates that are constructed after this operation has been invoked will produce text that is, by default, formatted with the specified formatter. setDefaultFormatters(format- ters : Sequence(Formatter)) Sequence(Formatter)) & Changes the formatter for this template to the specified sequence of formatters. Templates that are constructed after this operation has been invoked will produce text that is, by default, formatted with each of the specified formatters in turn. An Example of Co-ordination with EGL \u00b6 The operations provided by the TemplateFactory object and Template type are demonstrated by the EGL program in the listing below. Lines 2-3 use operations on TemplateFactory to change the paths from which templates will be loaded (line 2) and to which generated files will be created (line 3). Line 5 demonstrates the use of the prepare operation for creating a template from EGL code. When the interface template is invoked, the EGL code passed to the prepare operation will be executed. Finally, line 9 (and line 12) illustrates the way in which the populate operation can be used to pass a value to a template before invoking it. Specifically, the interface and implementation templates can use a variable called root , which is populated by the driver template before invoking them. [% TemplateFactory.setTemplateRoot(\"/usr/franz/templates\"); TemplateFactory.setOutputRoot(\"/tmp/output\"); var interface : Template = TemplateFactory.prepare(\"public interface [%=root.name] {}\"); var implementation : Template = TemplateFactory.load(\"Class2Impl.egl\"); for (c in Class.all) { interface.populate(\"root\", c); interface.generate(\"I\" + c.name + \".java\"); implementation.populate(\"root\", c); implementation.generate(c.name + \".java\"); } %] Customising the Co-ordination Engine \u00b6 EGL provides mechanisms for customising the co-ordination engine. Specifically, users can define and use their own TemplateFactory . In many cases, users need not customise the co-ordination engine, and can write transformations using the built-in Template type and TemplateFactory object. If, however, you need more control over the co-ordination process, the discussion in this section might be helpful. Specifically, a custom TemplateFactory is typically used to achieve one or more of the following goals: Provide additional mechanisms for constructing Templates . Example: facilitate the loading of templates from a database. Enrich / change the behaviour of the built-in Template type. Example: change the way in which generated text is sent to its destination. Observe or instrument the transformation process by, for instance, logging calls to the operations provided by the Template type of the TemplateFactory object. Example: audit or trace the transformation process. Customisation is achieved in two stages: implementing the custom TemplateFactory (and potentially a custom Template ) in Java, and using the custom TemplateFactory . Implementing a custom TemplateFactory \u00b6 A custom TemplateFactory is a subclass of EglTemplateFactory . Typically, a custom TemplateFactory is implemented by overriding one of the methods of EglTemplateFactory . For example, the createTemplate method is overriden to specify that a custom type of Template should be created by the TemplateFactory . Likewise, the load and prepare methods can be overriden to change the location from which Template s are constructed. A custom Template is a subclass of EglTemplate or, most often, a subclass of EglPersistentTemplate . Again, customisation is typically achieved by overriding methods in the superclass, or by adding new methods. For example, to perform auditing activities whenever a template is used to generate text, the doGenerate method of EglPersistentTemplate is overriden. import org.eclipse.epsilon.egl.EglFileGeneratingTemplateFactory ; import org.eclipse.epsilon.egl.EglTemplate ; import org.eclipse.epsilon.egl.EglPersistentTemplate ; import org.eclipse.epsilon.egl.exceptions.EglRuntimeException ; import org.eclipse.epsilon.egl.execute.context.IEglContext ; import org.eclipse.epsilon.egl.spec.EglTemplateSpecification ; public class CountingTemplateFactory extends EglFileGeneratingTemplateFactory { @Override protected EglTemplate createTemplate ( EglTemplateSpecification spec ) throws Exception { return new CountingTemplate ( spec , context , getOutputRootOrRoot (), outputRootPath ); } public class CountingTemplate extends EglPersistentTemplate { public static int numberOfCallsToGenerate = 0 ; public CountingTemplate ( EglTemplateSpecification spec , IEglContext context , URI outputRoot , String outputRootPath ) throws Exception { super ( spec , context , outputRoot , outputRootPath ); } @Override protected void doGenerate ( File file , String targetName , boolean overwrite , boolean protectRegions ) throws EglRuntimeException { numberOfCallsToGenerate ++ ; } } } Using a custom TemplateFactory \u00b6 When invoking an EGL program, the user may select a custom TemplateFactory . For example, the EGL development tools provide an Eclipse launch configuration that provides a tab named \"Generated Text.\"On this tab, users can select a TemplateFactory (under the group called \"Type of Template Factory\"). Note that a TemplateFactory only appears on the launch configuration tab if it has been registered with EGL via an Eclipse extension. Similarly, the workflow language provided by Epsilon allows the specification of custom types of TemplateFactory via the templateFactoryType parameter. Summary \u00b6 The co-ordination engine provided by EGL facilitates the construction of modular and re-usable M2T transformations and can be used to generate text to various types of destination. Furthermore, the logic for specifying the contents of generated text is kept separate from the logic for specifying the destination of generated text. Merge Engine \u00b6 EGL provides language constructs that allow M2T transformations to designate regions of generated text as protected . Whenever an EGL program attempts to generate text, any protected regions that are encountered in the specified destination are preserved. Within an EGL program, protected regions are specified with the preserve(String, String, String, Boolean, String) method on the out keyword. The first two parameters define the comment delimiters of the target language. The other parameters provide the name, enable-state and content of the protected region, as illustrated in the listing below. [%=out.preserve(\"/*\", \"*/\", \"anId\", true, \"System.out.println(foo);\") %] A protected region declaration may have many lines, and use many EGL variables in the contents definition. To enhance readability, EGL provides two additional methods on the out keyword: startPreserve(String, String, String, Boolean) and stopPreserve . The listing below uses these to generate a protected region. [%=out.startPreserve(\"/*\", \"*/\", \"anId\", true)%] System.out.println(foo); [%=out.stopPreserve()%] Because an EGL template may contain many protected regions, EGL also provides a separate method to set the target language generated by the current template, setContentType(String) . By default, EGL recognises Java, HTML, Perl and EGL as valid content types. An alternative configuration file can be used to specify further content types. Following a call to setContentType , the first two arguments to the preserve and startPreserve methods can be omitted, as shown in the listing below. [% out.setContentType(\"Java\"); %] [%=out.preserve(\"anId\", true, \"System.out.println(foo);\")%] Because some languages define more than one style of comment delimiter, EGL allows mixed use of the styles for preserve and startPreserve methods. Once a content type has been specified, a protected region may also be declared entirely from a static section, using the syntax in the listing below. [% out.setContentType(\"Java\"); %] // protected region anId [on|off] begin System.out.println(foo); // protected region anId end When a template that defines one or more protected regions is processed by the EGL execution engine, the target output destinations are examined and existing contents of any protected regions are preserved. If either the output generated by from the template or the existing contents of the target output destination contains protected regions, a merging process is invoked. The table below shows the default behaviour of EGL's merge engine. Protected Regions in Generated Protected Regions in Existing Contents taken from On On Existing On Off Generated On Absent Generated Off On Existing Off Off Generated Off Absent Generated Absent On Neither (causes a warning) Absent Off Neither (causes a warning) Formatters \u00b6 Often the text generated by a model-to-text transformation is not formatted in a desirable manner. Text generated with a model-to-text transformation might contain extra whitespace or inconsistent indentation. This is because controlling the formatting of generated text in a model-to-text transformation language can be challenging. In a template-based model-to-text language, such as EGL, it can be difficult to know how best to format a transformation. On the one hand, the transformation must be readable and understandable, and on the other hand, the generated text must typically also be readable and understandable. Conscientious developers apply various conventions to produce readable code. EGL encourages template developers to prioritise the readability of templates over the readability of generated text when writing EGL templates. For formatting generated text, EGL provides an extensible set of formatters that can be invoked during a model-to-text transformation. Using a Formatter \u00b6 EGL provides several built-in formatters. Users can implement additional formatters. To use a formatter, invoke the setFormatter or setFormatters operation on an instance of the Template type. A formatter is a Java class that implements EGL's Formatter interface. From within an EGL program, formatters can be created using a Native (i.e. Java) type. The listing below demonstrates the use of a built-in formatter (XmlFormatter). [% var f = new Native(\"org.eclipse.epsilon.egl.formatter.language.XmlFormatter\"); var t = TemplateFactory.load(\"generate_some_xml.egl\"); t.setFormatter(f); t.generate(\"formatted.xml\"); %] To facilitate the re-use of a formatter with many templates, the TemplateFactory object provides the setDefaultFormatter and setDefaultFormatters operations. Templates that are loaded or prepared after a call to setDefaultFormatter or setDefaultFormatters will, by default, use the formatter(s) specified for the TemplateFactory . Note that setting the formatter on a template overwrite any formatter that may have been set on that template by the TemplateFactory . The default formatters for an EGL program can also be set when invoking the program. For example, the EGL development tools provide an Eclipse launch configuration that provides a tab named \"Generated Text.\" On this tab, users can configure one or more formatters which will be used as the default formatters for this EGL program. Note that custom formatters only appear on the launch configuration tab if they have been registered with EGL via an Eclipse extension. Similarly, the workflow language provided by Epsilon provides a formatter nested element that can be used to specify one or more default formatters. Implementing a Custom Formatter \u00b6 Providing a user-defined formatter involves implementing the Formatter interface (in org.eclipse.epsilon.egl.formatter ). For example, the listing below demonstrates a simple formatter that transforms all generated text to uppercase. import org.eclipse.epsilon.egl.formatter.Formatter ; public class UppercaseFormatter implements Formatter { @Override public String format ( String text ) { return text . toUpperCase (); } } The set of built-in formatters provided by EGL includes some partial implementations of the Formatter interface that can be re-used to simplify the implementation of custom formatters. For instance, the LanguageFormatter class can correct the indentation of a program written in most languages, when given a start and end regular expression. Finally, an Eclipse extension point is provided for custom formatters. Providing an extension that conforms to the custom formatter extension point allows EGL to display the custom formatter in the launch configuration tabs of the EGL development tools. Outdentation \u00b6 New in 2.4 Support for outdentation was added in version 2.4 of Epsilon. If outdentation does not behave as expected in your EGX-coordinated templates with 2.4, please install the latest interim version of Epsilon. A common issue encountered when writing EGL templates is that the ideal indentation for the template code itself and the output it produces may be different. For example, consider the template below, which produces a Graphviz graph from a state machine model. digraph G { [%for (t in Transition.all){%] [%=t.from.name%] -> [%=t.to.name%] [%}%] } The output of the template for a minimal state machine model is shown below. digraph G { A -> B B -> C C -> A } Note that in order to indent lines 2-4 of the output with one tab, we had to \"pull\" line 3 of the template at the same indentation level as its container for loop, which is not ideal. To format both the template and its output properly in this case, we can use -%] instead of %] to close the for loop statement in line 2. This will instruct a built-in EGL formatter to remove one indentation character (see the setIndenters method above) from each of the lines of the content produced within the for loop. The template below uses this feature to produce the same output as the template above. digraph G { [%for (t in Transition.all){-%] [%=t.from.name%] -> [%=t.to.name%] [%}%] } Run this example You can run and tweak this example is the Epsilon Playground . Outdentation also works with if , switch , while statements etc. More examples are available in the unit tests folder of this feature . Traceability \u00b6 EGL also provides a traceability API, as a debugging aid, to support auditing of the M2T transformation process, and to facilitate change propagation. This API facilitates exploration of the templates executed, files affected and protected regions processed during a transformation. The figure below shows sample output from the traceability API after execution of an EGL M2T transformation to generate Java code from an instance of an OO metamodel. The view shown is accessed via the ... menu in Eclipse. Traceability information can also be accessed programmatically, as demonstrated in the listing below. EglTemplateFactoryModuleAdapter module = new EglTemplateFactoryModuleAdapter ( new EglTemplateFactory ()); boolean parsed = module . parse ( new File ( \"myTemplate.egl\" )); if ( parsed && module . getParseProblems (). isEmpty ()) { module . execute (); Template base = module . getContext (). getBaseTemplate (); // traverse the template hierachy // display data } else { // error handling } Additional Resources \u00b6 Additional resources about EGL/EGX are available here .","title":"Code Generation (EGL)"},{"location":"doc/egl/#the-epsilon-generation-language-egl","text":"EGL is a model-to-text transformation (M2T) language that can be used to transform models into various types of textual artefact, including code (e.g. Java), reports (e.g. in HTML/LaTeX), images (e.g. using Graphviz ), formal specifications, or even entire applications comprising code in multiple languages (e.g. HTML, Javascript and CSS). EGL is a template-based language (i.e. EGL programs resemble the text that they generate), and provides several features that simplify and support the generation of text from models, including: a sophisticated and language-independent merging engine (for preserving hand-written sections of generated text), an extensible template system (for generating text to a variety of sources, such as a file on disk, a database server, or even as a response issued by a web server), formatting algorithms (for producing generated text that is well-formatted and hence readable), and traceability mechanisms (for linking generated text with source models). Try EGL online You can run and fiddle with an EGL template that generates an ASCII-based Gantt chart from a project scheduling model in the online Epsilon Playground .","title":"The Epsilon Generation Language (EGL)"},{"location":"doc/egl/#abstract-syntax","text":"The figure below shows the abstract syntax of EGL's core functionality. Info As with most languages in Epsilon, EGL uses EOL as its expression language. This page only documents the additional syntax and semantics that EGL provides on top of EOL. classDiagram class EglSection { +getChildren(): List +getText(): String } class EglDynamicSection { +getText(): String } class EglStaticSection { +getText(): String } class EglShortcutSection { +getText(): String } EglSection <|-- EglDynamicSection EglSection <|-- EglStaticSection EglSection <|-- EglShortcutSection Conceptually, an EGL program comprises one or more sections . The contents of static sections are emitted verbatim and appear directly in the generated text. The contents of dynamic sections are executed and are used to control the text that is generated. In its dynamic sections, EGL re-uses EOL's syntax for structuring program control flow, performing model inspection and navigation, and defining custom operations. In addition, EGL provides an EOL object, out , which is used in dynamic sections to perform operations on the generated text, such as appending and removing strings; and specifying the type of text to be generated. EGL also provides syntax for defining dynamic output sections, which provide a convenient shorthand for outputting text from within dynamic sections. Similar syntax is often provided by template-based code generators.","title":"Abstract Syntax"},{"location":"doc/egl/#concrete-syntax","text":"The concrete syntax of EGL closely resembles the style of other template-based code generation languages, such as PHP. The tag pair [% %] is used to delimit a dynamic section. Any text not enclosed in such a tag pair is contained in a static section. The listing below illustrates the use of dynamic and static sections to form a basic EGL template. [% for (i in Sequence{1..5}) { %] i is [%=i%] [% } %] Executing the EGL template above would produce the generated text below. The [%=expr%] construct (line 2) is shorthand for [% out.print(expr); %] , which appends expr to the output generated by the transformation. i is 1 i is 2 i is 3 i is 4 i is 5 Any EOL statement can be contained in the dynamic sections of an EGL template. For example, the EGL template shown below generates text from a model that conforms to a metamodel that describes an object-oriented system. [% for (c in Class.all) { %] [%=c.name%] [% } %]","title":"Concrete Syntax"},{"location":"doc/egl/#comments-and-markers","text":"Inside an EGL dynamic section, EOL's comment syntax can be used. Additionally, EGL adds syntax for comment blocks [* this is a comment *] and marker blocks [*- this is a marker *] . Marker blocks are highlighted by the EGL editor and EGL outline view in Eclipse.","title":"Comments and Markers"},{"location":"doc/egl/#user-defined-operations","text":"Like EOL, EGL permits users to define re-usable units of code via operations. [% c.declaration(); %] [% operation Class declaration() { %] [%=self.visibility%] class [%=self.name%] {} [% } %] In EGL, user-defined operations are defined in dynamic sections, but may mix static and dynamic sections in their bodies. Consider, for example, the EGL code in the listing above, which emits a declaration for a Java class (e.g. public class Foo {} ). Lines 2-4 declare the operation. Note that the start and the end of the operation's declaration (on lines 2 and 4, respectively) are contained in dynamic sections. The body of the operation (line 3), however, mixes static and dynamic output sections. Finally, note that the operation is invoked from a dynamic section (line 1). It is worth noting that any loose (i.e. not contained in other operations) dynamic or static sections below the first operation of a template will be ignored at runtime. When a user-defined operation is invoked, any static or dynamic sections contained in the body of the operation are immediately appended to the generated text. Sometimes, however, it is desirable to manipulate the text produced by an operation before it is appended to the generated text. To this end, EGL defines the @template annotation which can applied to operations to indicate that any text generated by the operation must be returned from the operation and not appended to the generated text. For example, the EGL program in the listing above could be rewritten using a @template annotation, as demonstrated below. [%=c.declaration()%] [% @template operation Class declaration() { %] [%=self.visibility%] class [%=self.name%] {} [% } %] There is a subtle difference between the way in which standard (i.e. unannotated) operations and @template operations are invoked. Compare the first line of the two listings above. The former uses a dynamic section, because invoking the operation causes the evaluation of its body to be appended to the text generated by this program. By contrast, the latter uses a dynamic output section to append the result returned by the @template operation to the text generated by this program. In general, @template operations afford more flexibility than standard operations. For example, line 1 of the listing above could perform some manipulation of the text returned by the declaration() operation before the text is outputted. Therefore, @template operations provide a mechanism for re-using common pieces of a code generator, without sacrificing the flexibility to slightly alter text before it is emitted. Standard (unannotated) operations also permit re-use, but in a less flexible manner. Finally, it is worth noting that user-defined operations in EGL do not have to generate text. For example, the following listing illustrates two operations defined in an EGL program that do not generate any text. The former is a query that returns a Boolean value, while the latter alters the model, and does not return a value. [% operation Class isAnonymous() : Boolean { return self.name.isUndefined(); } operation removeOneClass() { delete Class.all.random(); } %]","title":"User-Defined Operations"},{"location":"doc/egl/#the-outputbuffer","text":"As an EGL program is executed, text is appended to a data structure termed the OutputBuffer . In every EGL program, the OutputBuffer is accessible via the out built-in variable. The OutputBuffer provides operations for appending to and removing from the buffer, and for merging generated text with existing text. For many EGL programs, interacting directly with the OutputBuffer is unnecessary. The contents of static and dynamic output sections are sent directly to the OutputBuffer , and no operation of the OutputBuffer need be invoked directly. However, in cases when generated text must be sent to the OutputBuffer from dynamic sections, or when generated text must be merged with existing text, the operations of OutputBuffer are provided in the table below. The [merge engine section]](#merge-engine) discusses merging generated and existing text, and presents several examples of invoking the operations of OutputBuffer . Signature Description chop(numberOfChars : Integer) Removes the specified number of characters from the end of the buffer print(object : Any) Appends a string representation of the specified object to the buffer println(object : Any) Appends a string representation of the specified object and a new line to the buffer println() Appends a new line to the buffer setContentType(contentType : String) Updates the content type of this template. Subsequent calls to preserve or startPreserve that do not specify a style of comment will use the style of comment defined by the specified content type. preserve(id : String, enabled : Boolean, contents : String) Appends a protected region to the buffer with the given identifier, enabled state and contents. Uses the current content type to determine how to format the start and end markers. preserve(startComment : String, endComment : String, id : String, enabled : Boolean, contents : String) Appends a protected region to the buffer with the given identifier, enabled state and contents. Uses the first two parameters as start and end markers. startPreserve(id : String, enabled : Boolean) Begins a protected region by appending the start marker for a protected region to the buffer with the given identifier and enabled state. Uses the current content type to determine how to format the start and end markers startPreserve(startComment : String, endComment : String, id : String, enabled : Boolean) Begins a protected region by appending the start marker to the buffer with the given identifier and enabled state. Uses the first two parameters as start and end markers. stopPreserve() Ends the current protected region by appending the end marker to the buffer. This operation should be invoked only if there a protected region is currently open (i.e. has been started by invoking startPreserve but not yet stopped by invoking stopPreserve ). setIndenters(indenters : Collection<String>) Sets the indentation characters for the buffer (default is \\t and four spaces).","title":"The OutputBuffer"},{"location":"doc/egl/#co-ordination","text":"Warning The recommended way to coordinate the execution of EGL templates is using the EGX rule-based language . This section describes an imperative way to invoke EGL templates which pre-dates EGX and should only be used as a fall-back in case the semantics of EGX are not sufficient for the task at hand. In the large, M2T transformations are used to generate text to various destinations. For example, code generators often produce files on disk, and web applications often generate text as part of the response for a resource on the web server. Text might be generated to a network socket during interprocess communication, or as a query that runs on a database. Furthermore, (parts of) a single M2T transformation might be re-used in different contexts. A M2T transformation that generates files on disk today might be re-purposed to generate the response from a web server tomorrow. Given these concerns, EGL provides a co-ordination engine that provides mechanisms for modularising M2T transformations, and for controlling the destinations to which text is generated. The EGL co-ordination engine fulfils three requirements: Reusability : the co-ordination engine allows EGL programs to be decomposed into one or more templates, which can be shared between EGL programs. Variety of destination : the co-ordination engine provides an extensible set of template types that can generate text to a variety of destinations. The next section describes the default template type, which is tailored to generate text to files on disk, while a subsequent section discusses the way in which users can define their own template types for generating text to other types of destination. Separation of concerns : the co-ordination engine ensures that the logic for controlling the text that is generated (i.e. the content) and the logic for controlling the way in which text is emitted (i.e. the destination) are kept separate. There is also the EGX language , which was introduced after this documentation was initially written, but provides a fully-fledged rule-based execution engine for paramterising EGL templates.","title":"Co-ordination"},{"location":"doc/egl/#the-template-type","text":"Central to the co-ordination engine is the Template type, which EGL provides in addition to the default EOL types. Via the Template type, EGL fulfils the three requirements identified above. Firstly, a Template can invoke other Templates , and hence can be shared and re-used between EGL programs. Secondly, the Template type has been implemented in an extensible manner: users can define their own types of Template that generate text to any destination (e.g. a database or a network socket), as described in the custom coordination section . Finally, the Template type provides a set of operations that are used to control the destination of generated text. Users typically define a \"driver\" template that does not generate text, but rather controls the destination of text that is generated by other templates. For example, consider the EGL program in the listing below. This template generates no text (as it contains only a single dynamic section), but is used instead to control the destination of text generated by another template. Line 1 defines a variable, t , of type Template . Note that, unlike the EOL types, instances of Template are not created with the new keyword. Instead, the TemplateFactory built-in object is used to load templates from, for example, a file system path. On line 3, the generate operation of the Template type invokes the EGL template stored in the file \"ClassNames.egl\" and emits the generated text to \"Output.txt\". [% var t : Template = TemplateFactory.load(\"ClassNames.egl\"); t.generate(\"Output.txt\"); %] In addition to generate , the Template type defines further operations for controlling the context and invocation of EGL templates. The following table lists all of the operations defined on Template , and a further example of their use is given in the sequel. Signature Description populate(name : String, value : Any) Makes a variable with the specified name and value available during the execution of the template. process() : String Executes the template and returns the text that is generated. generate(destination : String) Executes the template and stores the text to the specified destination. The format of the destination parameter is dictated by the type of template. For example, the default template type (which can generate files on disk) expects a file system path as the destination parameter. Returns a object representing the generated file. append(destination : String) Executes the template: if the destination exists, it will add a newline and the generated text at the end of the file. If the file does not exist, it will write the generated text to it (with no newline). Returns a object representing the generated file. setFormatter(formatter : Formatter) Changes the formatter for this template to the specified formatter. Subsequent calls to generate or process will produce text that is formatted with the specified formatter. setFormatters(formatters : Sequence(Formatter)) Changes the formatter for this template to the specified sequence of formatters. Subsequent calls to generate or process will produce text that is formatted with each of the specified formatters in turn.","title":"The Template type"},{"location":"doc/egl/#the-templatefactory-object","text":"As discussed above, instances of Template are not created with the new keyword. Instead, EGL provides a built-in object, the TemplateFactory , for this purpose. Users can customise the type of the TemplateFactory object to gain more control over the way in which text is generated. By default, EGL provides a TemplateFactory that exposes operations for loading templates (by loading files from disk), preparing templates (by parsing a string containing EGL code), and for controlling the file system locations from which templates are loaded and to which text is generated. The table below lists the operations provided by the built-in TemplateFactory object. Signature Description load(path : String) : Template Returns an instance of Template that can be used to execute the EGL template stored at the specified path. prepare(code : String) Changes the default path that is used to resolve relative paths when generating files to disk. Subsequent calls to load and prepare will create templates that use the new path. setOutputRoot(path : String) Changes the default path that is used to resolve relative paths when generating files to disk. Subsequent calls to load and prepare will create templates that use the new path. setTemplateRoot(path : String) Changes the default path that is used to resolve relative paths when loading templates with the load operation. Subsequent calls to load will use the new path. setDefaultFormatter(formatter : Formatter) Changes the formatter for this template factory to the specified formatter. Templates that are constructed after this operation has been invoked will produce text that is, by default, formatted with the specified formatter. setDefaultFormatters(format- ters : Sequence(Formatter)) Sequence(Formatter)) & Changes the formatter for this template to the specified sequence of formatters. Templates that are constructed after this operation has been invoked will produce text that is, by default, formatted with each of the specified formatters in turn.","title":"The TemplateFactory object"},{"location":"doc/egl/#an-example-of-co-ordination-with-egl","text":"The operations provided by the TemplateFactory object and Template type are demonstrated by the EGL program in the listing below. Lines 2-3 use operations on TemplateFactory to change the paths from which templates will be loaded (line 2) and to which generated files will be created (line 3). Line 5 demonstrates the use of the prepare operation for creating a template from EGL code. When the interface template is invoked, the EGL code passed to the prepare operation will be executed. Finally, line 9 (and line 12) illustrates the way in which the populate operation can be used to pass a value to a template before invoking it. Specifically, the interface and implementation templates can use a variable called root , which is populated by the driver template before invoking them. [% TemplateFactory.setTemplateRoot(\"/usr/franz/templates\"); TemplateFactory.setOutputRoot(\"/tmp/output\"); var interface : Template = TemplateFactory.prepare(\"public interface [%=root.name] {}\"); var implementation : Template = TemplateFactory.load(\"Class2Impl.egl\"); for (c in Class.all) { interface.populate(\"root\", c); interface.generate(\"I\" + c.name + \".java\"); implementation.populate(\"root\", c); implementation.generate(c.name + \".java\"); } %]","title":"An Example of Co-ordination with EGL"},{"location":"doc/egl/#customising-the-co-ordination-engine","text":"EGL provides mechanisms for customising the co-ordination engine. Specifically, users can define and use their own TemplateFactory . In many cases, users need not customise the co-ordination engine, and can write transformations using the built-in Template type and TemplateFactory object. If, however, you need more control over the co-ordination process, the discussion in this section might be helpful. Specifically, a custom TemplateFactory is typically used to achieve one or more of the following goals: Provide additional mechanisms for constructing Templates . Example: facilitate the loading of templates from a database. Enrich / change the behaviour of the built-in Template type. Example: change the way in which generated text is sent to its destination. Observe or instrument the transformation process by, for instance, logging calls to the operations provided by the Template type of the TemplateFactory object. Example: audit or trace the transformation process. Customisation is achieved in two stages: implementing the custom TemplateFactory (and potentially a custom Template ) in Java, and using the custom TemplateFactory .","title":"Customising the Co-ordination Engine"},{"location":"doc/egl/#implementing-a-custom-templatefactory","text":"A custom TemplateFactory is a subclass of EglTemplateFactory . Typically, a custom TemplateFactory is implemented by overriding one of the methods of EglTemplateFactory . For example, the createTemplate method is overriden to specify that a custom type of Template should be created by the TemplateFactory . Likewise, the load and prepare methods can be overriden to change the location from which Template s are constructed. A custom Template is a subclass of EglTemplate or, most often, a subclass of EglPersistentTemplate . Again, customisation is typically achieved by overriding methods in the superclass, or by adding new methods. For example, to perform auditing activities whenever a template is used to generate text, the doGenerate method of EglPersistentTemplate is overriden. import org.eclipse.epsilon.egl.EglFileGeneratingTemplateFactory ; import org.eclipse.epsilon.egl.EglTemplate ; import org.eclipse.epsilon.egl.EglPersistentTemplate ; import org.eclipse.epsilon.egl.exceptions.EglRuntimeException ; import org.eclipse.epsilon.egl.execute.context.IEglContext ; import org.eclipse.epsilon.egl.spec.EglTemplateSpecification ; public class CountingTemplateFactory extends EglFileGeneratingTemplateFactory { @Override protected EglTemplate createTemplate ( EglTemplateSpecification spec ) throws Exception { return new CountingTemplate ( spec , context , getOutputRootOrRoot (), outputRootPath ); } public class CountingTemplate extends EglPersistentTemplate { public static int numberOfCallsToGenerate = 0 ; public CountingTemplate ( EglTemplateSpecification spec , IEglContext context , URI outputRoot , String outputRootPath ) throws Exception { super ( spec , context , outputRoot , outputRootPath ); } @Override protected void doGenerate ( File file , String targetName , boolean overwrite , boolean protectRegions ) throws EglRuntimeException { numberOfCallsToGenerate ++ ; } } }","title":"Implementing a custom TemplateFactory"},{"location":"doc/egl/#using-a-custom-templatefactory","text":"When invoking an EGL program, the user may select a custom TemplateFactory . For example, the EGL development tools provide an Eclipse launch configuration that provides a tab named \"Generated Text.\"On this tab, users can select a TemplateFactory (under the group called \"Type of Template Factory\"). Note that a TemplateFactory only appears on the launch configuration tab if it has been registered with EGL via an Eclipse extension. Similarly, the workflow language provided by Epsilon allows the specification of custom types of TemplateFactory via the templateFactoryType parameter.","title":"Using a custom TemplateFactory"},{"location":"doc/egl/#summary","text":"The co-ordination engine provided by EGL facilitates the construction of modular and re-usable M2T transformations and can be used to generate text to various types of destination. Furthermore, the logic for specifying the contents of generated text is kept separate from the logic for specifying the destination of generated text.","title":"Summary"},{"location":"doc/egl/#merge-engine","text":"EGL provides language constructs that allow M2T transformations to designate regions of generated text as protected . Whenever an EGL program attempts to generate text, any protected regions that are encountered in the specified destination are preserved. Within an EGL program, protected regions are specified with the preserve(String, String, String, Boolean, String) method on the out keyword. The first two parameters define the comment delimiters of the target language. The other parameters provide the name, enable-state and content of the protected region, as illustrated in the listing below. [%=out.preserve(\"/*\", \"*/\", \"anId\", true, \"System.out.println(foo);\") %] A protected region declaration may have many lines, and use many EGL variables in the contents definition. To enhance readability, EGL provides two additional methods on the out keyword: startPreserve(String, String, String, Boolean) and stopPreserve . The listing below uses these to generate a protected region. [%=out.startPreserve(\"/*\", \"*/\", \"anId\", true)%] System.out.println(foo); [%=out.stopPreserve()%] Because an EGL template may contain many protected regions, EGL also provides a separate method to set the target language generated by the current template, setContentType(String) . By default, EGL recognises Java, HTML, Perl and EGL as valid content types. An alternative configuration file can be used to specify further content types. Following a call to setContentType , the first two arguments to the preserve and startPreserve methods can be omitted, as shown in the listing below. [% out.setContentType(\"Java\"); %] [%=out.preserve(\"anId\", true, \"System.out.println(foo);\")%] Because some languages define more than one style of comment delimiter, EGL allows mixed use of the styles for preserve and startPreserve methods. Once a content type has been specified, a protected region may also be declared entirely from a static section, using the syntax in the listing below. [% out.setContentType(\"Java\"); %] // protected region anId [on|off] begin System.out.println(foo); // protected region anId end When a template that defines one or more protected regions is processed by the EGL execution engine, the target output destinations are examined and existing contents of any protected regions are preserved. If either the output generated by from the template or the existing contents of the target output destination contains protected regions, a merging process is invoked. The table below shows the default behaviour of EGL's merge engine. Protected Regions in Generated Protected Regions in Existing Contents taken from On On Existing On Off Generated On Absent Generated Off On Existing Off Off Generated Off Absent Generated Absent On Neither (causes a warning) Absent Off Neither (causes a warning)","title":"Merge Engine"},{"location":"doc/egl/#formatters","text":"Often the text generated by a model-to-text transformation is not formatted in a desirable manner. Text generated with a model-to-text transformation might contain extra whitespace or inconsistent indentation. This is because controlling the formatting of generated text in a model-to-text transformation language can be challenging. In a template-based model-to-text language, such as EGL, it can be difficult to know how best to format a transformation. On the one hand, the transformation must be readable and understandable, and on the other hand, the generated text must typically also be readable and understandable. Conscientious developers apply various conventions to produce readable code. EGL encourages template developers to prioritise the readability of templates over the readability of generated text when writing EGL templates. For formatting generated text, EGL provides an extensible set of formatters that can be invoked during a model-to-text transformation.","title":"Formatters"},{"location":"doc/egl/#using-a-formatter","text":"EGL provides several built-in formatters. Users can implement additional formatters. To use a formatter, invoke the setFormatter or setFormatters operation on an instance of the Template type. A formatter is a Java class that implements EGL's Formatter interface. From within an EGL program, formatters can be created using a Native (i.e. Java) type. The listing below demonstrates the use of a built-in formatter (XmlFormatter). [% var f = new Native(\"org.eclipse.epsilon.egl.formatter.language.XmlFormatter\"); var t = TemplateFactory.load(\"generate_some_xml.egl\"); t.setFormatter(f); t.generate(\"formatted.xml\"); %] To facilitate the re-use of a formatter with many templates, the TemplateFactory object provides the setDefaultFormatter and setDefaultFormatters operations. Templates that are loaded or prepared after a call to setDefaultFormatter or setDefaultFormatters will, by default, use the formatter(s) specified for the TemplateFactory . Note that setting the formatter on a template overwrite any formatter that may have been set on that template by the TemplateFactory . The default formatters for an EGL program can also be set when invoking the program. For example, the EGL development tools provide an Eclipse launch configuration that provides a tab named \"Generated Text.\" On this tab, users can configure one or more formatters which will be used as the default formatters for this EGL program. Note that custom formatters only appear on the launch configuration tab if they have been registered with EGL via an Eclipse extension. Similarly, the workflow language provided by Epsilon provides a formatter nested element that can be used to specify one or more default formatters.","title":"Using a Formatter"},{"location":"doc/egl/#implementing-a-custom-formatter","text":"Providing a user-defined formatter involves implementing the Formatter interface (in org.eclipse.epsilon.egl.formatter ). For example, the listing below demonstrates a simple formatter that transforms all generated text to uppercase. import org.eclipse.epsilon.egl.formatter.Formatter ; public class UppercaseFormatter implements Formatter { @Override public String format ( String text ) { return text . toUpperCase (); } } The set of built-in formatters provided by EGL includes some partial implementations of the Formatter interface that can be re-used to simplify the implementation of custom formatters. For instance, the LanguageFormatter class can correct the indentation of a program written in most languages, when given a start and end regular expression. Finally, an Eclipse extension point is provided for custom formatters. Providing an extension that conforms to the custom formatter extension point allows EGL to display the custom formatter in the launch configuration tabs of the EGL development tools.","title":"Implementing a Custom Formatter"},{"location":"doc/egl/#outdentation","text":"New in 2.4 Support for outdentation was added in version 2.4 of Epsilon. If outdentation does not behave as expected in your EGX-coordinated templates with 2.4, please install the latest interim version of Epsilon. A common issue encountered when writing EGL templates is that the ideal indentation for the template code itself and the output it produces may be different. For example, consider the template below, which produces a Graphviz graph from a state machine model. digraph G { [%for (t in Transition.all){%] [%=t.from.name%] -> [%=t.to.name%] [%}%] } The output of the template for a minimal state machine model is shown below. digraph G { A -> B B -> C C -> A } Note that in order to indent lines 2-4 of the output with one tab, we had to \"pull\" line 3 of the template at the same indentation level as its container for loop, which is not ideal. To format both the template and its output properly in this case, we can use -%] instead of %] to close the for loop statement in line 2. This will instruct a built-in EGL formatter to remove one indentation character (see the setIndenters method above) from each of the lines of the content produced within the for loop. The template below uses this feature to produce the same output as the template above. digraph G { [%for (t in Transition.all){-%] [%=t.from.name%] -> [%=t.to.name%] [%}%] } Run this example You can run and tweak this example is the Epsilon Playground . Outdentation also works with if , switch , while statements etc. More examples are available in the unit tests folder of this feature .","title":"Outdentation"},{"location":"doc/egl/#traceability","text":"EGL also provides a traceability API, as a debugging aid, to support auditing of the M2T transformation process, and to facilitate change propagation. This API facilitates exploration of the templates executed, files affected and protected regions processed during a transformation. The figure below shows sample output from the traceability API after execution of an EGL M2T transformation to generate Java code from an instance of an OO metamodel. The view shown is accessed via the ... menu in Eclipse. Traceability information can also be accessed programmatically, as demonstrated in the listing below. EglTemplateFactoryModuleAdapter module = new EglTemplateFactoryModuleAdapter ( new EglTemplateFactory ()); boolean parsed = module . parse ( new File ( \"myTemplate.egl\" )); if ( parsed && module . getParseProblems (). isEmpty ()) { module . execute (); Template base = module . getContext (). getBaseTemplate (); // traverse the template hierachy // display data } else { // error handling }","title":"Traceability"},{"location":"doc/egl/#additional-resources","text":"Additional resources about EGL/EGX are available here .","title":"Additional Resources"},{"location":"doc/egx/","text":"The EGL Co-Ordination Language (EGX) \u00b6 EGX is a rule-based co-ordination language designed for automating the parametrised execution of model-to-text template transformations. Although built on top of the Epsilon Generation Language (EGL), EGX can in principle work with any template-based model-to-text transformation language. The rationale for this co-ordination language comes from the need to invoke text generation templates multiple times with various parameters, usually derived from input models. To better understand EGX, it is helpful to be familiar with template-based text generation. Epsilon Generation Language \u00b6 EGL is Epsilon's model-to-text transformation language. EGL in principle is similar in purpose to server-side scripting languages like PHP (and can indeed be used for such purposes, as demonstrated in this article ). To recap, a template is a text file which has both static and dynamic regions. As the name implies, a static region is where text appears as-is in the output, whereas a dynamic region uses code to generate the output, often relying on data which is only available at runtime (hence, \"dynamic\"). Dynamic regions are expressed using EOL . One can think of an EGL template as a regular text file with some EOL embedded in it, or as an EOL program with the added convenience of verbatim text generation. Indeed, it is possible to use EGL without any static regions, relying on the output buffer variable to write the output text. In EGL, the output variable is called \"out\" and the markers for the start and end of dynamic regions are [% and %] respectively. For convenience, [%= outputs the string value of the expression which follows. EGL has many advanced features, such as recording traceability information, post-process formatting (to ensure consistent style in the final output) and protected regions, which allow certain parts of the text to be preserved if modified by hand, rather than being overwritten on each invocation of the template. EGL can handle merges, and also supports outputting text to any output stream. As an example, consider a simple Library metamodel (shown below). Suppose each model may have multiple Libraries, and each Library has a name, multiple Books and Authors. Similarly, each Book has one or more Authors, and each Author has multiple Books, similar to the relation between Actors and Movies in the IMDb metamodel used in previous chapters. Now suppose we have a single monolithic model and want to transform this into multiple structured files, such as web pages (HTML) or XML documents. One possible decomposition of this is to generate a page for each Library in the model. classDiagram class Library{ name: EString id: ELong books: Book[*] } class Book { title: EString pages: EInt ISBN: EString authors: Author[*] } class Author{ name: EString books: Book[*] } Library -- Book: books * Book -- Author: books * / authors * <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library id=[%=lib.id%] name=\"[%=name%]\"> [% for (book in books) {%] <book> <title>[%=book.title%]</title> <isbn>[%=book.isbn%]</isbn> <pages>[%=book.pages.asString()%]</pages> <authors> [% for (author in book.authors) {%] <author name=\"[%=author.name%]\"/> [%}%] </authors> </book> [%}%] </library> Notice how the template refers to books (which is a collection of Book elements) without deriving them directly from the underlying model (i.e. there are no uses of allInstances). This is because the variables were provided to the template before invocation. Template Orchestration \u00b6 In the previous example, we stated that we want to invoke the template for all instances of Library in the model. To do this, we need to loop through all Library instances in the model(s), load the template, populate it with the required variables derived from the current Library instance and execute the template. However since we want each Library's contents to be written to a distinct XML file (perhaps identified by its name or id), we also need to set the output file for each template based on the current instance. In more complex cases, we may also want to have certain rules for whether a Library should be generated at all (e.g. if it does not have a threshold number of Books), and whether we should overwrite an existing file. For example, we may decide that for Libraries with a large number of books, we do not want to overwrite the file. Furthermore, we may want to have a different naming convention for certain libraries based on their name or ID, which may be decided based on an arbitrarily complex function. Also, we may not want to include all of the Books in the output file, but a subset, which requires additional processing logic. We may even have different templates for libraries based on the number of Books they hold \u2013 for example, with a large Library, we may want to inline all of the properties of each Book to save disk space, rather than having the title, pages, authors etc. enumerated as children. Or we may want to omit the authors. This can be achieved by modifying the template with conditionals, but this makes the template much less readable and harder to modify, so it can be easier to have a separate template instead. All of these factors are tedious to implement manually and can be difficult to maintain and modify by domain experts using handwritten imperative code. Therefore, a more declarative way of achieving this is needed. This is precisely the purpose of EGX. Features and Execution Algorithm \u00b6 Like all of Epsilon's rule-based (ERL) languages, an EGX module consists of any number of named rules, as well as optional pre and post blocks which can be used to perform arbitrarily complex tasks using imperative code before and after the execution of rules, respectively. The execution algorithm of EGX is quite simple, since the language itself is essentially a means to parameterise a for loop. EGX adds on top of ERL only a single top-level rule construct: the GenerationRule . The execution algorithm is thus as simple as executing all of these rules, in the order they are defined in the module. Thus, the remainder of this section describes the components and execution semantics of GenerationRule . Note that since variables declared in an earlier scope (executable block) within a GenerationRule are visible to later blocks, the order in which the engine executes each component block is important. Thus, we summarise each component block in execution order; which should also be the order in which they are declared by the user in the program. Note also that all of the component blocks of a GenerationRule are optional \u2013 that is, one can use any combination of them, including all or none. transform : A parameter (name and type), optionally followed by the collection of elements to run the rule over. The parameter name is bound to the current element, and this rule is executed for all elements in the specified collection. If the user does not specify a domain from which the elements are drawn using the in: construct , the engine will retrieve all model elements matching the type (but not subtypes) of the parameter type. To include all types and subtypes of the specified parameter, rule must be marked with the @greedy annotation, otherwise the entire rule must be repeated for each subtype. guard : True by default. If this returns false, the GenerationRule will skip execution of the remaining blocks for the current element (or altogether if the rule has no input elements). pre : Arbitrary block of code, can be used to set up variables or any other pre-processing. overwrite : Whether to overwrite the target file if it already exists. True by default. merge : Whether to merge new contents with existing contents. True by default. append : Whether to append new contents to existing contents. False by default. patch : Whether to patch existing contents with new contents. False by default. template : The path (usually relative) and name of the template to invoke. parameters : Key-value pairs mapping variable names to values, which will be passed to the template. That is, the template will be populated with variable names (the keys) and values based on the provided Map. target : The path of the file to which the output of the template should be written. formatter : The Formatter implementation to post-process the output with. See the documentation on formatters for more details. post : Arbitrarily code block for post-processing. In addition to having access to all variable declared in previous blocks, a new variable called generated is also available, which is usually a reference to the generated file so the user can call any methods available on java.io.File . If the EGL execution engine has not been configured to output to files, or the target is ommitted, then this variable will be the output of the template as a String instead. The only other noteworthy aspect of EGX's execution algorithm is that it keeps a cache of templates which have been loaded, to avoid re-parsing and re-initialising them every time. Of course, the variables for the template are reset and rebound every time, as they may be different. The purpose of the cache is only to avoid the potentially expensive process of parsing EGL templates. Parallel Execution \u00b6 Owing to its rule-based declarative nature, EGX can execute rules independently, and even if you only have a single rule, it can be invoked on a per-element basis by separate threads. You can declare a rule to be executed in parallel using the @parallel annotation, or by using the automatic parallelisation execution engine. Example Programs \u00b6 Returning to our example, we can orchestrate the generation of Libraries as shown below, which demonstrates most of the features of EGX. Here we see how it is possible to screen eligible Library instances for generation, populate the template with the necessary parameters, invoke a different version of the template, format the output, and direct the output to the desired file, all based on arbitrary user-defined criteria expressed declaratively using EOL. We can also compute aggregate metadata thanks to the pre and post blocks available both globally and on a per-rule basis. In this example, we simply compute the size of each file and print them once all transformations have taken place. Furthermore, we demonstrate that not all rules need to transform a specific model element: EGX can be used for convenience to invoke EGL templates with parameters, as shown by the AuthorsAndBooks rule. Here we only want to generate a single file from the Authors and Books in the model, where the logic for doing this is in a single EGL template. Although it wouldn't make much sense to use EGX purely for invoking single templates without parameters, the reader can perhaps appreciate that in large and complex models, there may be many different templates - e.g. one for each type - so all of the co-ordination in invoking them can be centralised to a single declarative file. EGX can thus be used as a workflow language in directing model-to-text transformations and is suitable for various use cases of almost any complexity. operation Book isValid() : Boolean { return self.isbn.isDefined() and self.isbn.length() == 13; } pre { var outDirLib : String = \"../libraries/\"; var libFileSizes = new Map; var xml = new Native(\"org.eclipse.epsilon.egl.formatter.language.XmlFormatter\"); } rule Lib2XML transform lib : Library { guard : lib.name.length() > 3 and lib.books.size() > 10 pre { var eligibleBooks = lib.books.select(b | b.isValid()); var isBigLibrary = eligibleBooks.size() > 9000; } merge : isBigLibrary overwrite : not isBigLibrary template { var libTemplate = \"rel/path/to/Lib2XML\"; if (isBigLibrary) { libTemplate += \"_minified\"; } return libTemplate + \".egl\"; } parameters : Map { \"name\" = lib.name, \"id\" = lib.id, \"books\" = lib.books } target { var outFile = outDirLib + lib.name; if (isBigLibrary) { outFile += \"_compact\"; } return outFile + \".xml\"; } formatter : xml post { libFileSizes.put(generated.getName(), generated.length()); } } rule AuthorsAndBooks { parameters : Map { \"authors\" = Authors.allInstances(), \"books\" = Book.allInstances() } template : \"AuthorsAndBooks.egl\" target : \"AllAuthorsBooks.txt\" } post { libFileSizes.println(); (\"Total: \"+libFileSizes.values().sum()).println(); } The previous example demonstrated the use of model-to-text transformations over Library model elements. However, there may be scenarios in which one would like to use model-to-text transformations over the items of a list. This is particularly useful when the list has been populated by other model-to-text transformations. The following example will generate a text file for each item in the files list, and the content of each file is specified by the data map. pre { var files = Sequence{\"file1\", \"file2\", \"file3\"}; var data = Map { \"file1\" = \"Content of the first file\", \"file2\" = \"Content of the second file\", \"file3\" = \"Content of the third file\" }; } rule ItemToFile transform file: String in: files { parameters : Map {\"content\" = data.get(file)} target : file + \".txt\" template: \"file.egl\" } Additional Resources \u00b6 Additional resources about EGL/EGX are available here .","title":"The EGL Co-Ordination Language (EGX)"},{"location":"doc/egx/#the-egl-co-ordination-language-egx","text":"EGX is a rule-based co-ordination language designed for automating the parametrised execution of model-to-text template transformations. Although built on top of the Epsilon Generation Language (EGL), EGX can in principle work with any template-based model-to-text transformation language. The rationale for this co-ordination language comes from the need to invoke text generation templates multiple times with various parameters, usually derived from input models. To better understand EGX, it is helpful to be familiar with template-based text generation.","title":"The EGL Co-Ordination Language (EGX)"},{"location":"doc/egx/#epsilon-generation-language","text":"EGL is Epsilon's model-to-text transformation language. EGL in principle is similar in purpose to server-side scripting languages like PHP (and can indeed be used for such purposes, as demonstrated in this article ). To recap, a template is a text file which has both static and dynamic regions. As the name implies, a static region is where text appears as-is in the output, whereas a dynamic region uses code to generate the output, often relying on data which is only available at runtime (hence, \"dynamic\"). Dynamic regions are expressed using EOL . One can think of an EGL template as a regular text file with some EOL embedded in it, or as an EOL program with the added convenience of verbatim text generation. Indeed, it is possible to use EGL without any static regions, relying on the output buffer variable to write the output text. In EGL, the output variable is called \"out\" and the markers for the start and end of dynamic regions are [% and %] respectively. For convenience, [%= outputs the string value of the expression which follows. EGL has many advanced features, such as recording traceability information, post-process formatting (to ensure consistent style in the final output) and protected regions, which allow certain parts of the text to be preserved if modified by hand, rather than being overwritten on each invocation of the template. EGL can handle merges, and also supports outputting text to any output stream. As an example, consider a simple Library metamodel (shown below). Suppose each model may have multiple Libraries, and each Library has a name, multiple Books and Authors. Similarly, each Book has one or more Authors, and each Author has multiple Books, similar to the relation between Actors and Movies in the IMDb metamodel used in previous chapters. Now suppose we have a single monolithic model and want to transform this into multiple structured files, such as web pages (HTML) or XML documents. One possible decomposition of this is to generate a page for each Library in the model. classDiagram class Library{ name: EString id: ELong books: Book[*] } class Book { title: EString pages: EInt ISBN: EString authors: Author[*] } class Author{ name: EString books: Book[*] } Library -- Book: books * Book -- Author: books * / authors * <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library id=[%=lib.id%] name=\"[%=name%]\"> [% for (book in books) {%] <book> <title>[%=book.title%]</title> <isbn>[%=book.isbn%]</isbn> <pages>[%=book.pages.asString()%]</pages> <authors> [% for (author in book.authors) {%] <author name=\"[%=author.name%]\"/> [%}%] </authors> </book> [%}%] </library> Notice how the template refers to books (which is a collection of Book elements) without deriving them directly from the underlying model (i.e. there are no uses of allInstances). This is because the variables were provided to the template before invocation.","title":"Epsilon Generation Language"},{"location":"doc/egx/#template-orchestration","text":"In the previous example, we stated that we want to invoke the template for all instances of Library in the model. To do this, we need to loop through all Library instances in the model(s), load the template, populate it with the required variables derived from the current Library instance and execute the template. However since we want each Library's contents to be written to a distinct XML file (perhaps identified by its name or id), we also need to set the output file for each template based on the current instance. In more complex cases, we may also want to have certain rules for whether a Library should be generated at all (e.g. if it does not have a threshold number of Books), and whether we should overwrite an existing file. For example, we may decide that for Libraries with a large number of books, we do not want to overwrite the file. Furthermore, we may want to have a different naming convention for certain libraries based on their name or ID, which may be decided based on an arbitrarily complex function. Also, we may not want to include all of the Books in the output file, but a subset, which requires additional processing logic. We may even have different templates for libraries based on the number of Books they hold \u2013 for example, with a large Library, we may want to inline all of the properties of each Book to save disk space, rather than having the title, pages, authors etc. enumerated as children. Or we may want to omit the authors. This can be achieved by modifying the template with conditionals, but this makes the template much less readable and harder to modify, so it can be easier to have a separate template instead. All of these factors are tedious to implement manually and can be difficult to maintain and modify by domain experts using handwritten imperative code. Therefore, a more declarative way of achieving this is needed. This is precisely the purpose of EGX.","title":"Template Orchestration"},{"location":"doc/egx/#features-and-execution-algorithm","text":"Like all of Epsilon's rule-based (ERL) languages, an EGX module consists of any number of named rules, as well as optional pre and post blocks which can be used to perform arbitrarily complex tasks using imperative code before and after the execution of rules, respectively. The execution algorithm of EGX is quite simple, since the language itself is essentially a means to parameterise a for loop. EGX adds on top of ERL only a single top-level rule construct: the GenerationRule . The execution algorithm is thus as simple as executing all of these rules, in the order they are defined in the module. Thus, the remainder of this section describes the components and execution semantics of GenerationRule . Note that since variables declared in an earlier scope (executable block) within a GenerationRule are visible to later blocks, the order in which the engine executes each component block is important. Thus, we summarise each component block in execution order; which should also be the order in which they are declared by the user in the program. Note also that all of the component blocks of a GenerationRule are optional \u2013 that is, one can use any combination of them, including all or none. transform : A parameter (name and type), optionally followed by the collection of elements to run the rule over. The parameter name is bound to the current element, and this rule is executed for all elements in the specified collection. If the user does not specify a domain from which the elements are drawn using the in: construct , the engine will retrieve all model elements matching the type (but not subtypes) of the parameter type. To include all types and subtypes of the specified parameter, rule must be marked with the @greedy annotation, otherwise the entire rule must be repeated for each subtype. guard : True by default. If this returns false, the GenerationRule will skip execution of the remaining blocks for the current element (or altogether if the rule has no input elements). pre : Arbitrary block of code, can be used to set up variables or any other pre-processing. overwrite : Whether to overwrite the target file if it already exists. True by default. merge : Whether to merge new contents with existing contents. True by default. append : Whether to append new contents to existing contents. False by default. patch : Whether to patch existing contents with new contents. False by default. template : The path (usually relative) and name of the template to invoke. parameters : Key-value pairs mapping variable names to values, which will be passed to the template. That is, the template will be populated with variable names (the keys) and values based on the provided Map. target : The path of the file to which the output of the template should be written. formatter : The Formatter implementation to post-process the output with. See the documentation on formatters for more details. post : Arbitrarily code block for post-processing. In addition to having access to all variable declared in previous blocks, a new variable called generated is also available, which is usually a reference to the generated file so the user can call any methods available on java.io.File . If the EGL execution engine has not been configured to output to files, or the target is ommitted, then this variable will be the output of the template as a String instead. The only other noteworthy aspect of EGX's execution algorithm is that it keeps a cache of templates which have been loaded, to avoid re-parsing and re-initialising them every time. Of course, the variables for the template are reset and rebound every time, as they may be different. The purpose of the cache is only to avoid the potentially expensive process of parsing EGL templates.","title":"Features and Execution Algorithm"},{"location":"doc/egx/#parallel-execution","text":"Owing to its rule-based declarative nature, EGX can execute rules independently, and even if you only have a single rule, it can be invoked on a per-element basis by separate threads. You can declare a rule to be executed in parallel using the @parallel annotation, or by using the automatic parallelisation execution engine.","title":"Parallel Execution"},{"location":"doc/egx/#example-programs","text":"Returning to our example, we can orchestrate the generation of Libraries as shown below, which demonstrates most of the features of EGX. Here we see how it is possible to screen eligible Library instances for generation, populate the template with the necessary parameters, invoke a different version of the template, format the output, and direct the output to the desired file, all based on arbitrary user-defined criteria expressed declaratively using EOL. We can also compute aggregate metadata thanks to the pre and post blocks available both globally and on a per-rule basis. In this example, we simply compute the size of each file and print them once all transformations have taken place. Furthermore, we demonstrate that not all rules need to transform a specific model element: EGX can be used for convenience to invoke EGL templates with parameters, as shown by the AuthorsAndBooks rule. Here we only want to generate a single file from the Authors and Books in the model, where the logic for doing this is in a single EGL template. Although it wouldn't make much sense to use EGX purely for invoking single templates without parameters, the reader can perhaps appreciate that in large and complex models, there may be many different templates - e.g. one for each type - so all of the co-ordination in invoking them can be centralised to a single declarative file. EGX can thus be used as a workflow language in directing model-to-text transformations and is suitable for various use cases of almost any complexity. operation Book isValid() : Boolean { return self.isbn.isDefined() and self.isbn.length() == 13; } pre { var outDirLib : String = \"../libraries/\"; var libFileSizes = new Map; var xml = new Native(\"org.eclipse.epsilon.egl.formatter.language.XmlFormatter\"); } rule Lib2XML transform lib : Library { guard : lib.name.length() > 3 and lib.books.size() > 10 pre { var eligibleBooks = lib.books.select(b | b.isValid()); var isBigLibrary = eligibleBooks.size() > 9000; } merge : isBigLibrary overwrite : not isBigLibrary template { var libTemplate = \"rel/path/to/Lib2XML\"; if (isBigLibrary) { libTemplate += \"_minified\"; } return libTemplate + \".egl\"; } parameters : Map { \"name\" = lib.name, \"id\" = lib.id, \"books\" = lib.books } target { var outFile = outDirLib + lib.name; if (isBigLibrary) { outFile += \"_compact\"; } return outFile + \".xml\"; } formatter : xml post { libFileSizes.put(generated.getName(), generated.length()); } } rule AuthorsAndBooks { parameters : Map { \"authors\" = Authors.allInstances(), \"books\" = Book.allInstances() } template : \"AuthorsAndBooks.egl\" target : \"AllAuthorsBooks.txt\" } post { libFileSizes.println(); (\"Total: \"+libFileSizes.values().sum()).println(); } The previous example demonstrated the use of model-to-text transformations over Library model elements. However, there may be scenarios in which one would like to use model-to-text transformations over the items of a list. This is particularly useful when the list has been populated by other model-to-text transformations. The following example will generate a text file for each item in the files list, and the content of each file is specified by the data map. pre { var files = Sequence{\"file1\", \"file2\", \"file3\"}; var data = Map { \"file1\" = \"Content of the first file\", \"file2\" = \"Content of the second file\", \"file3\" = \"Content of the third file\" }; } rule ItemToFile transform file: String in: files { parameters : Map {\"content\" = data.get(file)} target : file + \".txt\" template: \"file.egl\" }","title":"Example Programs"},{"location":"doc/egx/#additional-resources","text":"Additional resources about EGL/EGX are available here .","title":"Additional Resources"},{"location":"doc/emc/","text":"The Epsilon Model Connectivity Layer (EMC) \u00b6 The Epsilon Model Connectivity (EMC) layer provides abstraction facilities over concrete modelling technologies such as EMF , XML , Simulink etc. and enables Epsilon programs to interact with models conforming to these technologies in a uniform manner. A graphical overview of the core classes and methods of EMC is displayed below. Tip If you are interested in examples of EMC-based drivers for Epsilon, rather than on the organisation of EMC itself, please scroll to the bottom of this page . classDiagram class IModel { -name: String -aliases: String[*] +load() +load(properties : StringProperties) +store() +getAllOfKind(type: String): Object[*] +isKindOf(element: Object, type: String): boolean +getAllOfType(type: String): Object[*] +isTypeOf(element: Object, type: String): boolean +createInstance(type: String): Object +deleteElement(element: Object) } class ModelRepository { +getOwningModel(modelElement: Object) +getModelByName(name: String) +dispose() } class IPropertyGetter { +invoke(object: Object, property: String) } class IPropertySetter { +invoke(object: Object, property: String, value: Object) } ModelRepository -- IModel: models * ModelGroup -- IModel: models * IModel <|-- ModelGroup IModel -- IPropertySetter: propertySetter IModel -- IPropertyGetter: propertyGetter To abstract away from diverse model representations and APIs provided by different modelling technologies, EMC defines the IModel interface. IModel provides a number of methods that enable querying and modifying the model elements it contains at a higher level of abstraction. To enable languages and tools that build atop EMC to manage multiple models simultaneously, the ModelRepository class acts as a container that offers fa\u00e7ade services. The following sections discuss these two core concepts in detail. The IModel interface \u00b6 Each model specifies a name which must be unique in the context of the model repository in which it is contained. Also, it defines a number of aliases; that is non-unique alternate names; via which it can be accessed. The interface also defines the following services. Loading and Persistence \u00b6 The load() and load(properties : Properties) methods enable extenders to specify in a uniform way how a model is loaded into memory from the physical location in which it resides. Similarly, the store() and store(location : String) methods are used to define how the model can be persisted from memory to a permanent storage location. Type-related Services \u00b6 The majority of metamodelling architectures support inheritance between meta-classes and therefore two types of type-conformance relationships generally appear between model elements and types. The type-of relationship appears when a model element is an instance of the type and the kind-of relationship appears when the model element is an instance of the type or any of its sub-types. Under this definition, the getAllOfType(type: String) and the getAllOfKind(type: String) operations return all the elements in the model that have a type-of and a kind-of relationship with the type in question respectively. Similarly, the isTypeOf(element: Object, type : String) and isKindOf(element: Object, type : String) return whether the element in question has a type-of or a kind-of relationship with the type respectively. The getTypeOf(element: Object) method returns the fully-qualified name of the type an element conforms to. The hasType(type: String) method returns true if the model supports a type with the specified name. To support technologies that enable users to define abstract (non-instantiable) types, the isInstantiable(type: String) method returns if instances of the type can be created. Ownership \u00b6 The allContents() method returns all the elements that the model contains and the owns(element: Object) method returns true if the element under question belongs to the model. Creation, Deletion and Modifications \u00b6 Model elements are created and deleted using the createInstance(type: String) and deleteElement(element: Object) methods respectively. To retrieve and set the values of properties of its model elements, IModel uses its associated propertyGetter ( IPropertyGetter ) and propertySetter ( IPropertySetter ) respectively. Technology-specific implementations of those two interfaces are responsible for accessing and modifying the value of a property of a model element through their invoke(element: Object, property : String) and invoke(value: Object) respectively. The ModelRepository class \u00b6 A model repository acts as a container for a set of models that need to be managed in the context of a task or a set of tasks. Apart from a reference to the models it contains, ModelRepository also provides the following fa\u00e7ade functionality. The getOwningModel(element: Object) method returns the model that owns a particular element. The transactionSupport property specifies an instance of the ModelRepositoryTransactionSupport class which is responsible for aggregate management of transactions by delegating calls to its startTransaction() , commitTransaction() and abortTransaction() methods, to the respective methods of instances of IModelTransactionSupport associated with models contained in the repository. The ModelGroup class \u00b6 A ModelGroup is a group of models that have a common alias. ModelGroups are calculated dynamically by the model repository based on common model aliases. That is, if two or more models share a common alias, the repository forms a new model group. Since ModelGroup implements the IModel interface, clients can use all the methods of IModel to perform aggregate operations on multiple models, such as collecting the contents of more than one models. An exception to that is the createInstance(type: String) method which cannot be defined for a group of models as it cannot be determined in which model of the group the newly created element should belong. Assumptions about the underlying modelling technologies \u00b6 The discussion provided above has demonstrated that EMC makes only minimal assumptions about the structure and the organization of the underlying modelling technologies. Thus, it intentionally refrains from defining classes for concepts such as model element , type and metamodel . By contrast, it employs a lightweight approach that uses primitive strings for type names and objects of the target implementation platforms as model elements. There are two reasons for this decision. The primary reason is that by minimizing the assumptions about the underlying technologies EMC becomes more resistant to future changes of the implementations of the current technologies and can also embrace new technologies without changes. Another reason is that if a heavy-weight approach was used, extending the platform with support for a new modelling technology would involve providing wrapping objects for the native objects which represent model elements and types in the specific modelling technology. Experiments in the early phases of the design of EMC demonstrated that such a heavy-weight approach significantly increases the amount of memory required to represent the models in memory, degrades performance and provides little benefits in reward. EMC Drivers \u00b6 Below are known drivers that implement the EMC interfaces discussed above and allow Epsilon programs to access different types of models and structured data. Eclipse Modeling Framework \u00b6 The Eclipse Modelling Framework (EMF) is one of the most robust and widely used open-source modelling frameworks, and the cornerstone of an extensive ecosystem of technologies for graphical/textual model editing, model comparison and merging etc. Being an Eclipse project, Epsilon naturally provides support for all flavours of EMF models (e.g. textual, graphical, XSD-based XML), and most of the screencasts , articles and examples in Epsilon's Git repository use EMF models. Epsilon can also connect to CDO repositories of EMF models. Matlab Simulink \u00b6 Epsilon also provides mature support for querying and modifying Matlab Simulink models as shown in these articles . Cameo / MagicDraw Systems Modeler \u00b6 Cameo Systems Modeler is a widely-used graphical systems modelling tool. A driver that allows Epsilon programs to read/write Cameo models is available under EpsilonLabs on GitHub . XML/CSV/Excel \u00b6 For quick and dirty metamodel-less modelling, Epsilon also supports plain XML documents , Excel spreadsheets , and CSV files . Eclipse Hawk \u00b6 Hawk is an Eclipse project that provides tools for monitoring, indexing and querying repositories (i.e. local folders, Eclipse workspaces, Git/SVN repositories) containing models. Hawk provides an EMC driver through which model indices can be queried with Epsilon languages. Other Drivers \u00b6 There are also less mature/well-documented drivers for Epsilon for tools and formats such as: ArgoUML Connected Data Objects (CDO) Eclipse C/C++ Development Tools Eclipse Java Development Tools MagicDraw / Cameo Systems Modeler MetaEdit+ NeoEMF PTC Integrity Modeller Relational Databases (JDBC) These drivers have not had much external use historically, but if you're interested in them, please give us a shout .","title":"Model Connectivity"},{"location":"doc/emc/#the-epsilon-model-connectivity-layer-emc","text":"The Epsilon Model Connectivity (EMC) layer provides abstraction facilities over concrete modelling technologies such as EMF , XML , Simulink etc. and enables Epsilon programs to interact with models conforming to these technologies in a uniform manner. A graphical overview of the core classes and methods of EMC is displayed below. Tip If you are interested in examples of EMC-based drivers for Epsilon, rather than on the organisation of EMC itself, please scroll to the bottom of this page . classDiagram class IModel { -name: String -aliases: String[*] +load() +load(properties : StringProperties) +store() +getAllOfKind(type: String): Object[*] +isKindOf(element: Object, type: String): boolean +getAllOfType(type: String): Object[*] +isTypeOf(element: Object, type: String): boolean +createInstance(type: String): Object +deleteElement(element: Object) } class ModelRepository { +getOwningModel(modelElement: Object) +getModelByName(name: String) +dispose() } class IPropertyGetter { +invoke(object: Object, property: String) } class IPropertySetter { +invoke(object: Object, property: String, value: Object) } ModelRepository -- IModel: models * ModelGroup -- IModel: models * IModel <|-- ModelGroup IModel -- IPropertySetter: propertySetter IModel -- IPropertyGetter: propertyGetter To abstract away from diverse model representations and APIs provided by different modelling technologies, EMC defines the IModel interface. IModel provides a number of methods that enable querying and modifying the model elements it contains at a higher level of abstraction. To enable languages and tools that build atop EMC to manage multiple models simultaneously, the ModelRepository class acts as a container that offers fa\u00e7ade services. The following sections discuss these two core concepts in detail.","title":"The Epsilon Model Connectivity Layer (EMC)"},{"location":"doc/emc/#the-imodel-interface","text":"Each model specifies a name which must be unique in the context of the model repository in which it is contained. Also, it defines a number of aliases; that is non-unique alternate names; via which it can be accessed. The interface also defines the following services.","title":"The IModel interface"},{"location":"doc/emc/#loading-and-persistence","text":"The load() and load(properties : Properties) methods enable extenders to specify in a uniform way how a model is loaded into memory from the physical location in which it resides. Similarly, the store() and store(location : String) methods are used to define how the model can be persisted from memory to a permanent storage location.","title":"Loading and Persistence"},{"location":"doc/emc/#type-related-services","text":"The majority of metamodelling architectures support inheritance between meta-classes and therefore two types of type-conformance relationships generally appear between model elements and types. The type-of relationship appears when a model element is an instance of the type and the kind-of relationship appears when the model element is an instance of the type or any of its sub-types. Under this definition, the getAllOfType(type: String) and the getAllOfKind(type: String) operations return all the elements in the model that have a type-of and a kind-of relationship with the type in question respectively. Similarly, the isTypeOf(element: Object, type : String) and isKindOf(element: Object, type : String) return whether the element in question has a type-of or a kind-of relationship with the type respectively. The getTypeOf(element: Object) method returns the fully-qualified name of the type an element conforms to. The hasType(type: String) method returns true if the model supports a type with the specified name. To support technologies that enable users to define abstract (non-instantiable) types, the isInstantiable(type: String) method returns if instances of the type can be created.","title":"Type-related Services"},{"location":"doc/emc/#ownership","text":"The allContents() method returns all the elements that the model contains and the owns(element: Object) method returns true if the element under question belongs to the model.","title":"Ownership"},{"location":"doc/emc/#creation-deletion-and-modifications","text":"Model elements are created and deleted using the createInstance(type: String) and deleteElement(element: Object) methods respectively. To retrieve and set the values of properties of its model elements, IModel uses its associated propertyGetter ( IPropertyGetter ) and propertySetter ( IPropertySetter ) respectively. Technology-specific implementations of those two interfaces are responsible for accessing and modifying the value of a property of a model element through their invoke(element: Object, property : String) and invoke(value: Object) respectively.","title":"Creation, Deletion and Modifications"},{"location":"doc/emc/#the-modelrepository-class","text":"A model repository acts as a container for a set of models that need to be managed in the context of a task or a set of tasks. Apart from a reference to the models it contains, ModelRepository also provides the following fa\u00e7ade functionality. The getOwningModel(element: Object) method returns the model that owns a particular element. The transactionSupport property specifies an instance of the ModelRepositoryTransactionSupport class which is responsible for aggregate management of transactions by delegating calls to its startTransaction() , commitTransaction() and abortTransaction() methods, to the respective methods of instances of IModelTransactionSupport associated with models contained in the repository.","title":"The ModelRepository class"},{"location":"doc/emc/#the-modelgroup-class","text":"A ModelGroup is a group of models that have a common alias. ModelGroups are calculated dynamically by the model repository based on common model aliases. That is, if two or more models share a common alias, the repository forms a new model group. Since ModelGroup implements the IModel interface, clients can use all the methods of IModel to perform aggregate operations on multiple models, such as collecting the contents of more than one models. An exception to that is the createInstance(type: String) method which cannot be defined for a group of models as it cannot be determined in which model of the group the newly created element should belong.","title":"The ModelGroup class"},{"location":"doc/emc/#assumptions-about-the-underlying-modelling-technologies","text":"The discussion provided above has demonstrated that EMC makes only minimal assumptions about the structure and the organization of the underlying modelling technologies. Thus, it intentionally refrains from defining classes for concepts such as model element , type and metamodel . By contrast, it employs a lightweight approach that uses primitive strings for type names and objects of the target implementation platforms as model elements. There are two reasons for this decision. The primary reason is that by minimizing the assumptions about the underlying technologies EMC becomes more resistant to future changes of the implementations of the current technologies and can also embrace new technologies without changes. Another reason is that if a heavy-weight approach was used, extending the platform with support for a new modelling technology would involve providing wrapping objects for the native objects which represent model elements and types in the specific modelling technology. Experiments in the early phases of the design of EMC demonstrated that such a heavy-weight approach significantly increases the amount of memory required to represent the models in memory, degrades performance and provides little benefits in reward.","title":"Assumptions about the underlying modelling technologies"},{"location":"doc/emc/#emc-drivers","text":"Below are known drivers that implement the EMC interfaces discussed above and allow Epsilon programs to access different types of models and structured data.","title":"EMC Drivers"},{"location":"doc/emc/#eclipse-modeling-framework","text":"The Eclipse Modelling Framework (EMF) is one of the most robust and widely used open-source modelling frameworks, and the cornerstone of an extensive ecosystem of technologies for graphical/textual model editing, model comparison and merging etc. Being an Eclipse project, Epsilon naturally provides support for all flavours of EMF models (e.g. textual, graphical, XSD-based XML), and most of the screencasts , articles and examples in Epsilon's Git repository use EMF models. Epsilon can also connect to CDO repositories of EMF models.","title":"Eclipse Modeling Framework"},{"location":"doc/emc/#matlab-simulink","text":"Epsilon also provides mature support for querying and modifying Matlab Simulink models as shown in these articles .","title":"Matlab Simulink"},{"location":"doc/emc/#cameo-magicdraw-systems-modeler","text":"Cameo Systems Modeler is a widely-used graphical systems modelling tool. A driver that allows Epsilon programs to read/write Cameo models is available under EpsilonLabs on GitHub .","title":"Cameo / MagicDraw Systems Modeler"},{"location":"doc/emc/#xmlcsvexcel","text":"For quick and dirty metamodel-less modelling, Epsilon also supports plain XML documents , Excel spreadsheets , and CSV files .","title":"XML/CSV/Excel"},{"location":"doc/emc/#eclipse-hawk","text":"Hawk is an Eclipse project that provides tools for monitoring, indexing and querying repositories (i.e. local folders, Eclipse workspaces, Git/SVN repositories) containing models. Hawk provides an EMC driver through which model indices can be queried with Epsilon languages.","title":"Eclipse Hawk"},{"location":"doc/emc/#other-drivers","text":"There are also less mature/well-documented drivers for Epsilon for tools and formats such as: ArgoUML Connected Data Objects (CDO) Eclipse C/C++ Development Tools Eclipse Java Development Tools MagicDraw / Cameo Systems Modeler MetaEdit+ NeoEMF PTC Integrity Modeller Relational Databases (JDBC) These drivers have not had much external use historically, but if you're interested in them, please give us a shout .","title":"Other Drivers"},{"location":"doc/emg/","text":"The Epsilon Model Generation Language (EMG) \u00b6 At some point, programs written in any of the Epsilon model management languages might need to be tested in order to find defects (bugs) and assert their correctness, or benchmarked in order to assess their performance. Both testing and benchmarking activities require appropriate test data, i.e. models that conform to specific metamodels and their constraints, satisfy additional requirements or characteristics (e.g. certain size), and/or contain data and provide a structure that exercises particular aspects of the program under test. Manual assembly of test models is an error prone, time and labour consuming activity. This type of activities are perfect candidates for automation. Given that it is also a model management activity, it follows that the automation can be provided by a model generation engine that can execute model generation scripts. The scripts should be written in a model generation language that allows the user to generate models that conform to specific metamodels and its arbitrarily complex constraints (e.g constraints formulated in compound first-order OCL operations), satisfy particular characteristics, and contain specific data and exhibit particular structures. The model generation engine should exhibit characteristics such as randomness, repeatability, scalability and easy parametrization. The Epsilon Model Generation Language addresses the automated generation of complex models. Approaches to Model Generation \u00b6 The model generation approaches found in literature provide fully-automated behaviour. In a fully-automated approach, the tool loads the metamodel (and in some cases its constraints) and generates models that conform to the metamodel (and satisfy the constraints, if constraints are supported). However, the existing solutions can generate invalid models and in the case where constraints are supported, only simple constraints are supported. The Epsilon Model Generation follows a semi-automated generation approach. There are three main tasks in model generation: Create instances of types in the metamodel(s). Assign values to the instance's attributes (properties typed by primitive types: String, Integer, etc.). Create links between instances to assign values to references (properties typed by complex types: other types in the metamodel). In the semi-automated approach, all of these tasks can be configured to execute statically or dynamically (with randomness). Statically, the user must specify every single aspect of the generation. Dynamically, for example, the number of instances to create of a given type can be random, or the value of a given attribute can be set to random values, or the links between elements can be done between random pairs of elements. The combination of random and static definition of the generation tasks allows the user to generate models that can satisfy complex constraints, guarantee additional characteristics and exercise particular aspects of the program under test. This chapter discusses the concrete syntax of EMG as well as its execution semantics. To aid understanding, the discussion of the syntax and the semantics of the language revolves around an exemplar generation which is developed incrementally throughout the chapter. Syntax \u00b6 The EMG language does not provide additional syntax. Instead it provides a set of predefined annotations that can be added to EOL operations and EPL patterns in order to perform the model generation. The predefined EOL operation annotations are: Name Description instances Defines the number of instances to create. This annotation accepts one parameter. The parameter can be an expression that resolves to an Integer (e.g. literal, variable name, etc.) or a sequence in the form Sequence {min, max} ). An integer value statically defines how many instances are to be created. A sequence defines a range that is used by the engine to generates a random number n of instances, with min <= n <= max . list Defines an identifier (listID) for a placeholder list for the elements created. This annotation accepts one parameter. The parameter is the identifier (String) that can later be used in operations that accept it as an argument in order to access the elements created by the operation. parameters If the instantiated type accepts/needs arguments for instantiation, the parameters annotation can be used to provide them. This annotation accepts one parameter. The parameter must be a Sequence that contains the desired arguments in the order expected by the constructor. All three annotations are executable and hence must be prefixed with a $ symbol when used. Further, these annotations are only evaluated on create operations. The EPL pattern annotations are: Name Description number This limits the number of times the pattern is matched, to constraint the number of links created between elements. This annotation accepts one parameter. The parameter can be an expression that resolves to an Integer (e.g. literal, variable name, etc.) or a sequence in the form Sequence {min, max} ). An integer value statically defines how many instances are to be created. A sequence defines a range that is used by the engine to generates a random number n of instances, with min <= n <= max . probability This defines the probability that the body of the pattern will be executed for a matching set of elements. The effect is that not all matching elements are linked. Effectively this also limits the number of times links are created. noRepeat This forbids previous matched elements to be re-linked. The first two annotations are executable and hence must be prefixed with a $ symbol when used and the last one is a simple annotation and must be prefixed with @ . Additionally the EMG engine provides a set of predefined operations that provide support for generating random data that can be used to set the attributes and references of the generated model elements, to select random elements from collections, etc. EMG predefined operations \u00b6 Signature Description nextAddTo(n : Integer, m : Integer): Sequence(Integer) Returns a sequence of n integers who's sum is equal to m. nextBoolean() Returns the next pseudorandom, uniformly distributed boolean value. nextCamelCaseWords(charSet : String, length : Integer, minWordLength : Integer) : String Generates a string of the given length formatted as CamelCase, with subwords of a minimum length of the minWordLength argument, using characters from the given charSet. nextCapitalisedWord(charSet : String, length : Integer) : String Generate a Capitalized string of the given length using characters from the given charSet. nextFromCollection(c : Sequence) : Any Returns the next object from the collection, selected pseudoramdomly using the uniform distribution. If the collection is empty, returns null. nextFromList(listID : String) : Any Returns the next object from the list, selected pseudoramdomly using the uniform distribution. If the list is empty, returns null. The listID can either be a name defined by the \\@list annotation or a parameter name from the run configuration. In the latter case, the parameter value can be either a comma separated string or a file path. If it is a comma separated string, then a list is created by splitting the string, if the value is a path, then the file will be read and each line will be treated as a list element. nextFromListAsSample(listID : String) : Any Same as nextFromList, but in this case the list is treated as a sample without replacement, i.e. each call will return a unique member of the list. nextHttpURI(addPort : Boolean, addPath : Boolean, addQuery : Boolean, addFragment : Boolean) : String Generates a random URI that complies to http:[//host[:port]][/]path [?query][#fragment]. The path, query and fragment parts are optional and will be added if the respective argument is True. nextInt() : Integer Returns the next pseudorandom, uniformly distributed integer. All 2^32 possible integer values should be produced with (approximately) equal probability. nextInt(upper : Integer) : Integer Returns a pseudorandom, uniformly distributed integer value between 0 (inclusive) and upper (exclusive). The argument must be positive. nextInt(lower: Integer, upper : Integer) : Integer Returns a pseudorandom, uniformly distributed integer value between lower and upper (endpoints included). The arguments must be positive and upper >= lower . nextReal() : Real Returns the next pseudorandom, uniformly distributed real value between 0.0 and 1.0 . nextReal(upper : Real) : Real Returns the next pseudorandom, uniformly distributed real value between 0.0 and upper (inclusive). nextReal(lower: Real, upper : Real) : Real Returns a pseudorandom, uniformly distributed real value between lower and upper (endpoints included). nextSample(c : Sequence, k : Integer) : Sequence(Any) Returns a Sequence of k objects selected randomly from the Sequence c using a uniform distribution. Sampling from c is without replacement; but if c contains identical objects, the sample may include repeats. If all elements of c are distinct, the resulting object collection represents a Simple Random Sample of size k from the elements of c . nextSample(listID : String, k : Integer) : Sequence(Any) Same as nextSample but the sequence is referenced by listID . The listID has the same meanings as for operation nextFromList . nextString() : String Returns the next string made up from characters of the LETTER character set, pseudorandomly selected with a uniform distribution. The length of the string is between 4 and 10 characters. nextString(length : Integer) : String Returns the next String made up from characters of the LETTER character set, pseudorandomly selected with a uniform distribution. The length of the String is equal to length . nextString(charSet : String, length : Integer) : String Returns the next String of the given length using the specified character set, pseudorandomly selected with a uniform distribution. nextURI() : String Generates a random URI that complies to: scheme:[//[user:password]host[:port]][/]path [?query][#fragment]. The port, path, query and fragment are added randomly. The scheme is randomly selected from: http, ssh and ftp. For ssh and ftp, a user and pasword are randomly generated. The host is generated from a random string and uses a top-level domain. The number of paths and queries are random between 1 and 4. nextURI(addPort : Boolean, addPath : Boolean, addQuery : Boolean, addFragment : Boolean) : String Same as nextURI, but the given arguments control what additional port, path, query and fragment information is added. nextUUID() : String Returns a type 4 (pseudo randomly generated) UUID. The UUID is generated using a cryptographically strong pseudo random number generator. nextValue() : Real Returns the next pseudorandom value, picked from the configured distribution (by default the uniform distribution is used). nextValue(d : String, p : Sequence) : Real Returns the next pseudorandom, from the provided distribution d . The parameters p are used to configure the distribution (if required). The supported distributions are: Binomial, Exponential and Uniform. For Binomial parameters are: numberOfTrials and probabilityOfSuccess. For Exponential the mean. For Uniform the lower and upper values (lower inclusive). setNextValueDistribution(d : String, p : Sequence) Define the distribution to use for calls to nextValue() . Parameters are the same as for nextValue(d, p). Character Sets for String operations \u00b6 For the operations that accept a character set, the supported sets are defined as follows: Name Characters ID abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 NUMERIC 1234567890 LETTER abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ LETTER_UPPER ABCDEFGHIJKLMNOPQRSTUVWXYZ LETTER_LOWER abcdefghijklmnopqrstuvwxyz UPPER_NUM ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 LOWER_NUM abcdefghijklmnopqrstuvwxyz 1234567890 ID_SYMBOL abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 ~{}!@#\\$%\\^&( ) _+-=[] \\|;': \\\" \\< > ? , . /\\ HEX_LOWER abcdef1234567890 HEX_UPPER ABCDEF1234567890 Creating Model Elements \u00b6 The EMG engine will search for EOL operations that follow a particular signature in order to determine what elements to create in the generated model. The signature is: create <OutputType> () { ... } . That is, the operation must be named create , the operation's context type defines the type of the created instance and no parameters should be passed. By default the create operation only creates one instance. Hence, the provided annotations can be used to tailor the behaviour of the operation. Consider the case of the PetriNet metamodel in the figure below. classDiagram class Element { +name: String } class Place { +outgoing: PlaceToTransArc[*] +incoming: TransToPlaceArc[*] } class PetriNet { +places: Place[*] +transitions: Transition[*] +arcs: Arc[*] } class Transition { +incoming: PlaceToTransArc[*] +outgoing: TransToPlaceArc[*] } class TransToPlaceArc { +source: Transition +target: Place } class PlaceToTransArc { +target: Transition +source: Place } Element <|-- PetriNet Element <|-- Place Transition --|> Element PetriNet *-- Arc PetriNet *-- Place PetriNet *-- Transition Arc <|-- TransToPlaceArc Arc <|-- PlaceToTransArc The code excerpt displayed below creates a PetriNet and then adds some places and transitions to it. Note that the instances annotation is executable and hence you can use absolute values, variables or expressions. The list annotation in the PetriNet creation will result in all PetriNet instances to be stored in a sequence called net . The list name is then used in the Place and Transition create operations to add the places and transitions to a random ( nextFromList ) PetriNet. In this example there is only one, but we could easily create more PetriNet instances and hence have them contain random number of Places and Transitions. The name of the elements is generated using the random string generation facilities. pre { var num_p = 10 } $instances 1 @list net operation PetriNet create() { self.name = nextCamelCaseWords(\"LETTER_LOWER\", 15, 10); } $instances num_p operation Place create() { self.name = \"P_\" + nextString(\"LETTER_LOWER\", 15); nextFromList(\"net\").transitions.add(self); } $instances num_p / 2 operation Transition create() { self.name = \"T_\" + nextString(\"LETTER_LOWER\", 15); nextFromList(\"net\").transitions.add(self); } Creating Model Links \u00b6 In the previous section, the places and transitions references of the PetriNet were defined during the creation of the Place and Transition elements. For more complex reference patterns, EMG leverages the use of EPL patterns. For example, Arcs can have complex constraints in order to determine the source and target transition/place, and possibly even having separate rules for each type of Arc. The EPL pattern in the listing below creates two arcs in order to connect a source and a target Place via a Transition. The pattern matches all transitions in a given PetriNet. The pattern body selects a random Place for the source and a random Place for the target (the while loops are used to pick places that have the lowest incoming/outgoing arcs possible). The weight of the arc is generated randomly from 0 to 10 ( nextInt(10) ). The pattern has been annotated with the \\@probability annotation which will effectively only use 70% of the transitions to create arcs (i.e. of all the possible PetriNet-Transition matches, the code of the pattern will only be executed with a probability of 0.70). @probability 0.7 pattern Transition net:PetriNet, tra:Transition from: net.transitions { onmatch { var size = 0; var freeSources = Place.all().select(s | s.incoming.size() == size); while (freeSources.isEmpty()) { size += 1; freeSources = Place.all().select(s | s.incoming.size() == size); } size = 0; var freeTarget = Place.all().select(s | s.outgoing.size() == size); while (freeTarget.isEmpty()) { size += 1; freeTarget = Place.all().select(s | s.outgoing.size() == size); } var source = nextFromCollection(freeSources); var target = nextFromCollection(freeTarget); var a1:Arc = new PlaceToTransArc(); a1.weight = nextInt(10); a1.source = source; net.places.add(source); a1.target = tra; net.arcs.add(a1); var a2:Arc = new TransToPlaceArc(); a1.weight = nextInt(10); a2.source = tra; a2.target = target; net.places.add(target); net.arcs.add(a2); } } Meaningful Strings \u00b6 In some scenarios having completely random Strings for some of the element fields might not be desirable. In this case EMG has an embedded mechanism to facilitate the use of meaningful attribute values (not only for Strings) and we show a second approach based on additional models. Values as a parameter \u00b6 The nextFromList() operation will first look for a list with that name, if it can't find it will look for a parameter (from the run configuration) with that name. The value of the parameter can be either an absolute path to a file or a comma separated list of values. If it is a comma separated list of values, then the individual values will be loaded as a Collection. For example, if we added the parameter names: John, Rose, Juan, Xiang, Joe to the run configuration, the listing below shows how to use that information to define the instance attributes. $instances num_p operation Place create() { self.name = nextFromList(\"name\"); nextFromList(\"net\").transitions.add(self); } If it is a file path, then each line of the file will be loaded as an item to the Collection. Note that the distinction between paths and comma separated values is the assumption that paths don't contain commas. Values as a model \u00b6 A more powerful approach would be to use an existing model to serve as the source for attribute values. Given that there are several websites 1 to generate random data in the form of CSV files, we recommend the use of a CSV model to serve as an attribute value source. A CSV file with name , lastName , and email can be easily generated and loaded as a second model the the EMG script. Then, a Row of data can be picked randomly to set an element's attributes. The listing below shows this approach. $instances num_p operation Person create() { var p = nextFromCollection(dataModel.Row.all()); self.name = p.name; self.lastName = p.lastName; self.email = p.email; } Note that in this case, by using different rows for each value you can further randomize the data. https://www.mockaroo.com/, https://www.generatedata.com/, www.freedatagenerator.com/, etc. \u21a9","title":"Model Generation (EMG)"},{"location":"doc/emg/#the-epsilon-model-generation-language-emg","text":"At some point, programs written in any of the Epsilon model management languages might need to be tested in order to find defects (bugs) and assert their correctness, or benchmarked in order to assess their performance. Both testing and benchmarking activities require appropriate test data, i.e. models that conform to specific metamodels and their constraints, satisfy additional requirements or characteristics (e.g. certain size), and/or contain data and provide a structure that exercises particular aspects of the program under test. Manual assembly of test models is an error prone, time and labour consuming activity. This type of activities are perfect candidates for automation. Given that it is also a model management activity, it follows that the automation can be provided by a model generation engine that can execute model generation scripts. The scripts should be written in a model generation language that allows the user to generate models that conform to specific metamodels and its arbitrarily complex constraints (e.g constraints formulated in compound first-order OCL operations), satisfy particular characteristics, and contain specific data and exhibit particular structures. The model generation engine should exhibit characteristics such as randomness, repeatability, scalability and easy parametrization. The Epsilon Model Generation Language addresses the automated generation of complex models.","title":"The Epsilon Model Generation Language (EMG)"},{"location":"doc/emg/#approaches-to-model-generation","text":"The model generation approaches found in literature provide fully-automated behaviour. In a fully-automated approach, the tool loads the metamodel (and in some cases its constraints) and generates models that conform to the metamodel (and satisfy the constraints, if constraints are supported). However, the existing solutions can generate invalid models and in the case where constraints are supported, only simple constraints are supported. The Epsilon Model Generation follows a semi-automated generation approach. There are three main tasks in model generation: Create instances of types in the metamodel(s). Assign values to the instance's attributes (properties typed by primitive types: String, Integer, etc.). Create links between instances to assign values to references (properties typed by complex types: other types in the metamodel). In the semi-automated approach, all of these tasks can be configured to execute statically or dynamically (with randomness). Statically, the user must specify every single aspect of the generation. Dynamically, for example, the number of instances to create of a given type can be random, or the value of a given attribute can be set to random values, or the links between elements can be done between random pairs of elements. The combination of random and static definition of the generation tasks allows the user to generate models that can satisfy complex constraints, guarantee additional characteristics and exercise particular aspects of the program under test. This chapter discusses the concrete syntax of EMG as well as its execution semantics. To aid understanding, the discussion of the syntax and the semantics of the language revolves around an exemplar generation which is developed incrementally throughout the chapter.","title":"Approaches to Model Generation"},{"location":"doc/emg/#syntax","text":"The EMG language does not provide additional syntax. Instead it provides a set of predefined annotations that can be added to EOL operations and EPL patterns in order to perform the model generation. The predefined EOL operation annotations are: Name Description instances Defines the number of instances to create. This annotation accepts one parameter. The parameter can be an expression that resolves to an Integer (e.g. literal, variable name, etc.) or a sequence in the form Sequence {min, max} ). An integer value statically defines how many instances are to be created. A sequence defines a range that is used by the engine to generates a random number n of instances, with min <= n <= max . list Defines an identifier (listID) for a placeholder list for the elements created. This annotation accepts one parameter. The parameter is the identifier (String) that can later be used in operations that accept it as an argument in order to access the elements created by the operation. parameters If the instantiated type accepts/needs arguments for instantiation, the parameters annotation can be used to provide them. This annotation accepts one parameter. The parameter must be a Sequence that contains the desired arguments in the order expected by the constructor. All three annotations are executable and hence must be prefixed with a $ symbol when used. Further, these annotations are only evaluated on create operations. The EPL pattern annotations are: Name Description number This limits the number of times the pattern is matched, to constraint the number of links created between elements. This annotation accepts one parameter. The parameter can be an expression that resolves to an Integer (e.g. literal, variable name, etc.) or a sequence in the form Sequence {min, max} ). An integer value statically defines how many instances are to be created. A sequence defines a range that is used by the engine to generates a random number n of instances, with min <= n <= max . probability This defines the probability that the body of the pattern will be executed for a matching set of elements. The effect is that not all matching elements are linked. Effectively this also limits the number of times links are created. noRepeat This forbids previous matched elements to be re-linked. The first two annotations are executable and hence must be prefixed with a $ symbol when used and the last one is a simple annotation and must be prefixed with @ . Additionally the EMG engine provides a set of predefined operations that provide support for generating random data that can be used to set the attributes and references of the generated model elements, to select random elements from collections, etc.","title":"Syntax"},{"location":"doc/emg/#emg-predefined-operations","text":"Signature Description nextAddTo(n : Integer, m : Integer): Sequence(Integer) Returns a sequence of n integers who's sum is equal to m. nextBoolean() Returns the next pseudorandom, uniformly distributed boolean value. nextCamelCaseWords(charSet : String, length : Integer, minWordLength : Integer) : String Generates a string of the given length formatted as CamelCase, with subwords of a minimum length of the minWordLength argument, using characters from the given charSet. nextCapitalisedWord(charSet : String, length : Integer) : String Generate a Capitalized string of the given length using characters from the given charSet. nextFromCollection(c : Sequence) : Any Returns the next object from the collection, selected pseudoramdomly using the uniform distribution. If the collection is empty, returns null. nextFromList(listID : String) : Any Returns the next object from the list, selected pseudoramdomly using the uniform distribution. If the list is empty, returns null. The listID can either be a name defined by the \\@list annotation or a parameter name from the run configuration. In the latter case, the parameter value can be either a comma separated string or a file path. If it is a comma separated string, then a list is created by splitting the string, if the value is a path, then the file will be read and each line will be treated as a list element. nextFromListAsSample(listID : String) : Any Same as nextFromList, but in this case the list is treated as a sample without replacement, i.e. each call will return a unique member of the list. nextHttpURI(addPort : Boolean, addPath : Boolean, addQuery : Boolean, addFragment : Boolean) : String Generates a random URI that complies to http:[//host[:port]][/]path [?query][#fragment]. The path, query and fragment parts are optional and will be added if the respective argument is True. nextInt() : Integer Returns the next pseudorandom, uniformly distributed integer. All 2^32 possible integer values should be produced with (approximately) equal probability. nextInt(upper : Integer) : Integer Returns a pseudorandom, uniformly distributed integer value between 0 (inclusive) and upper (exclusive). The argument must be positive. nextInt(lower: Integer, upper : Integer) : Integer Returns a pseudorandom, uniformly distributed integer value between lower and upper (endpoints included). The arguments must be positive and upper >= lower . nextReal() : Real Returns the next pseudorandom, uniformly distributed real value between 0.0 and 1.0 . nextReal(upper : Real) : Real Returns the next pseudorandom, uniformly distributed real value between 0.0 and upper (inclusive). nextReal(lower: Real, upper : Real) : Real Returns a pseudorandom, uniformly distributed real value between lower and upper (endpoints included). nextSample(c : Sequence, k : Integer) : Sequence(Any) Returns a Sequence of k objects selected randomly from the Sequence c using a uniform distribution. Sampling from c is without replacement; but if c contains identical objects, the sample may include repeats. If all elements of c are distinct, the resulting object collection represents a Simple Random Sample of size k from the elements of c . nextSample(listID : String, k : Integer) : Sequence(Any) Same as nextSample but the sequence is referenced by listID . The listID has the same meanings as for operation nextFromList . nextString() : String Returns the next string made up from characters of the LETTER character set, pseudorandomly selected with a uniform distribution. The length of the string is between 4 and 10 characters. nextString(length : Integer) : String Returns the next String made up from characters of the LETTER character set, pseudorandomly selected with a uniform distribution. The length of the String is equal to length . nextString(charSet : String, length : Integer) : String Returns the next String of the given length using the specified character set, pseudorandomly selected with a uniform distribution. nextURI() : String Generates a random URI that complies to: scheme:[//[user:password]host[:port]][/]path [?query][#fragment]. The port, path, query and fragment are added randomly. The scheme is randomly selected from: http, ssh and ftp. For ssh and ftp, a user and pasword are randomly generated. The host is generated from a random string and uses a top-level domain. The number of paths and queries are random between 1 and 4. nextURI(addPort : Boolean, addPath : Boolean, addQuery : Boolean, addFragment : Boolean) : String Same as nextURI, but the given arguments control what additional port, path, query and fragment information is added. nextUUID() : String Returns a type 4 (pseudo randomly generated) UUID. The UUID is generated using a cryptographically strong pseudo random number generator. nextValue() : Real Returns the next pseudorandom value, picked from the configured distribution (by default the uniform distribution is used). nextValue(d : String, p : Sequence) : Real Returns the next pseudorandom, from the provided distribution d . The parameters p are used to configure the distribution (if required). The supported distributions are: Binomial, Exponential and Uniform. For Binomial parameters are: numberOfTrials and probabilityOfSuccess. For Exponential the mean. For Uniform the lower and upper values (lower inclusive). setNextValueDistribution(d : String, p : Sequence) Define the distribution to use for calls to nextValue() . Parameters are the same as for nextValue(d, p).","title":"EMG predefined operations"},{"location":"doc/emg/#character-sets-for-string-operations","text":"For the operations that accept a character set, the supported sets are defined as follows: Name Characters ID abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 NUMERIC 1234567890 LETTER abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ LETTER_UPPER ABCDEFGHIJKLMNOPQRSTUVWXYZ LETTER_LOWER abcdefghijklmnopqrstuvwxyz UPPER_NUM ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 LOWER_NUM abcdefghijklmnopqrstuvwxyz 1234567890 ID_SYMBOL abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890 ~{}!@#\\$%\\^&( ) _+-=[] \\|;': \\\" \\< > ? , . /\\ HEX_LOWER abcdef1234567890 HEX_UPPER ABCDEF1234567890","title":"Character Sets for String operations"},{"location":"doc/emg/#creating-model-elements","text":"The EMG engine will search for EOL operations that follow a particular signature in order to determine what elements to create in the generated model. The signature is: create <OutputType> () { ... } . That is, the operation must be named create , the operation's context type defines the type of the created instance and no parameters should be passed. By default the create operation only creates one instance. Hence, the provided annotations can be used to tailor the behaviour of the operation. Consider the case of the PetriNet metamodel in the figure below. classDiagram class Element { +name: String } class Place { +outgoing: PlaceToTransArc[*] +incoming: TransToPlaceArc[*] } class PetriNet { +places: Place[*] +transitions: Transition[*] +arcs: Arc[*] } class Transition { +incoming: PlaceToTransArc[*] +outgoing: TransToPlaceArc[*] } class TransToPlaceArc { +source: Transition +target: Place } class PlaceToTransArc { +target: Transition +source: Place } Element <|-- PetriNet Element <|-- Place Transition --|> Element PetriNet *-- Arc PetriNet *-- Place PetriNet *-- Transition Arc <|-- TransToPlaceArc Arc <|-- PlaceToTransArc The code excerpt displayed below creates a PetriNet and then adds some places and transitions to it. Note that the instances annotation is executable and hence you can use absolute values, variables or expressions. The list annotation in the PetriNet creation will result in all PetriNet instances to be stored in a sequence called net . The list name is then used in the Place and Transition create operations to add the places and transitions to a random ( nextFromList ) PetriNet. In this example there is only one, but we could easily create more PetriNet instances and hence have them contain random number of Places and Transitions. The name of the elements is generated using the random string generation facilities. pre { var num_p = 10 } $instances 1 @list net operation PetriNet create() { self.name = nextCamelCaseWords(\"LETTER_LOWER\", 15, 10); } $instances num_p operation Place create() { self.name = \"P_\" + nextString(\"LETTER_LOWER\", 15); nextFromList(\"net\").transitions.add(self); } $instances num_p / 2 operation Transition create() { self.name = \"T_\" + nextString(\"LETTER_LOWER\", 15); nextFromList(\"net\").transitions.add(self); }","title":"Creating Model Elements"},{"location":"doc/emg/#creating-model-links","text":"In the previous section, the places and transitions references of the PetriNet were defined during the creation of the Place and Transition elements. For more complex reference patterns, EMG leverages the use of EPL patterns. For example, Arcs can have complex constraints in order to determine the source and target transition/place, and possibly even having separate rules for each type of Arc. The EPL pattern in the listing below creates two arcs in order to connect a source and a target Place via a Transition. The pattern matches all transitions in a given PetriNet. The pattern body selects a random Place for the source and a random Place for the target (the while loops are used to pick places that have the lowest incoming/outgoing arcs possible). The weight of the arc is generated randomly from 0 to 10 ( nextInt(10) ). The pattern has been annotated with the \\@probability annotation which will effectively only use 70% of the transitions to create arcs (i.e. of all the possible PetriNet-Transition matches, the code of the pattern will only be executed with a probability of 0.70). @probability 0.7 pattern Transition net:PetriNet, tra:Transition from: net.transitions { onmatch { var size = 0; var freeSources = Place.all().select(s | s.incoming.size() == size); while (freeSources.isEmpty()) { size += 1; freeSources = Place.all().select(s | s.incoming.size() == size); } size = 0; var freeTarget = Place.all().select(s | s.outgoing.size() == size); while (freeTarget.isEmpty()) { size += 1; freeTarget = Place.all().select(s | s.outgoing.size() == size); } var source = nextFromCollection(freeSources); var target = nextFromCollection(freeTarget); var a1:Arc = new PlaceToTransArc(); a1.weight = nextInt(10); a1.source = source; net.places.add(source); a1.target = tra; net.arcs.add(a1); var a2:Arc = new TransToPlaceArc(); a1.weight = nextInt(10); a2.source = tra; a2.target = target; net.places.add(target); net.arcs.add(a2); } }","title":"Creating Model Links"},{"location":"doc/emg/#meaningful-strings","text":"In some scenarios having completely random Strings for some of the element fields might not be desirable. In this case EMG has an embedded mechanism to facilitate the use of meaningful attribute values (not only for Strings) and we show a second approach based on additional models.","title":"Meaningful Strings"},{"location":"doc/emg/#values-as-a-parameter","text":"The nextFromList() operation will first look for a list with that name, if it can't find it will look for a parameter (from the run configuration) with that name. The value of the parameter can be either an absolute path to a file or a comma separated list of values. If it is a comma separated list of values, then the individual values will be loaded as a Collection. For example, if we added the parameter names: John, Rose, Juan, Xiang, Joe to the run configuration, the listing below shows how to use that information to define the instance attributes. $instances num_p operation Place create() { self.name = nextFromList(\"name\"); nextFromList(\"net\").transitions.add(self); } If it is a file path, then each line of the file will be loaded as an item to the Collection. Note that the distinction between paths and comma separated values is the assumption that paths don't contain commas.","title":"Values as a parameter"},{"location":"doc/emg/#values-as-a-model","text":"A more powerful approach would be to use an existing model to serve as the source for attribute values. Given that there are several websites 1 to generate random data in the form of CSV files, we recommend the use of a CSV model to serve as an attribute value source. A CSV file with name , lastName , and email can be easily generated and loaded as a second model the the EMG script. Then, a Row of data can be picked randomly to set an element's attributes. The listing below shows this approach. $instances num_p operation Person create() { var p = nextFromCollection(dataModel.Row.all()); self.name = p.name; self.lastName = p.lastName; self.email = p.email; } Note that in this case, by using different rows for each value you can further randomize the data. https://www.mockaroo.com/, https://www.generatedata.com/, www.freedatagenerator.com/, etc. \u21a9","title":"Values as a model"},{"location":"doc/eml/","text":"The Epsilon Merging Language (EML) \u00b6 The aim of EML is to contribute model merging capabilities to Epsilon. More specifically, EML can be used to merge an arbitrary number of input models of potentially diverse metamodels and modelling technologies. This section provides a discussion on the abstract and concrete syntax of EML, as well as its execution semantics. It also provides two examples of merging homogeneous and heterogeneous models. Abstract Syntax \u00b6 In EML, merging specifications are organized in modules ( EmlModule ). As displayed below, EmlModule inherits from EtlModule . classDiagram class MergeRule { -name: String -abstract: Boolean -lazy: Boolean -primary: Boolean -greedy: Boolean -guard: ExecutableBlock<Boolean> -compare: ExecutableBlock<Boolean> -do: ExecutableBlock<Void> } class Parameter { -name: String -type: EolType } class NamedStatementBlockRule { -name: String -body: StatementBlock } EolModule <|-- ErlModule EtlModule <|-- EmlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule EtlModule <|-- ErlModule ErlModule -- Pre: pre * ErlModule -- Post: post * EmlModule -- MergeRule: rules * MergeRule -- Parameter: left MergeRule -- Parameter: right MergeRule -- Parameter: target MergeRule -- MergeRule: extends * By extending EtlModule , an EML module can contain a number of transformation rules and user-defined operations. An EML module can also contain one or more merge rules as well as a set of pre and post named EOL statement blocks. As usual, pre and post blocks will be run before and after all rules, respectively. Each merge rule defines a name, a left, a right, and one or more target parameters. It can also extend one or more other merge rules and be defined as having one or more of the following properties: abstract, greedy, lazy and primary. Concrete Syntax \u00b6 The listing below demonstrates the concrete syntax of EML merge-rules. (@abstract)? (@lazy)? (@primary)? (@greedy)? rule <name> merge <leftParameter> with <rightParameter> into (<targetParameter>(, <targetParameter>)*)? (extends <ruleName>(, <ruleName>)*)? { statementBlock } Pre and post blocks have a simple syntax that consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ } Execution Semantics \u00b6 Rule and Block Overriding \u00b6 An EML module can import a number of other EML and ETL modules. In this case, the importing EML module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively. Rule Scheduling \u00b6 When an EML module is executed, the pre blocks are executed in the order in which they have been defined. Following that, for each match of the established matchTrace the applicable non-abstract, non-lazy merge rules are executed. When all matches have been merged, the transformation rules of the module are executed on all applicable elements - that have not been merged - in the models. Finally, after all rules have been applied, the post blocks of the module are executed. Rule Applicability \u00b6 By default, for a merge-rule to apply to a match , the left and right elements of the match must have a type-of relationship with the leftParameter and rightParameter of the rule respectively. This can be relaxed to a kind-of relationship by specifying that the merge rule is greedy (using the \\@greedy annotation in terms of concrete syntax). Source Elements Resolution \u00b6 As with model transformation, in model merging it is often required to resolve the counterparts of an element of a source model into the target models. In EML, this is achieved by overloading the semantics of the equivalents() and equivalent() operations defined by ETL. In EML, in addition to inspecting the transformation trace and invoking any applicable transformation rules, the equivalents() operation also examines the mergeTrace (displayed in the figure below) that stores the results of the application of merge-rules and invokes any applicable (both lazy and non-lazy) rules. Similarly to ETL, the order of the results of the equivalents() operation respects the order of the (merge or transform) rules that have produced them. An exception to that occurs if one of the rules has been declared as primary, in which case its results are prepended to the list of elements returned by equivalent. classDiagram class Merge { -left: Object -right: Object -targets: Object[*] } EtlContext <|-- EmlContext EmlContext -- MatchTrace: matchTrace MergeTrace -- EmlContext: mergeTrace MergeTrace -- Merge: merges * Merge -- MergeRule Homogeneous Model Merging Example \u00b6 In this scenario, two models conforming to the Graph metamodel need to be merged. The first step is to compare the two graphs using the ECL module below. rule MatchNodes match l : Left!Node with r : Right!Node { compare : l.label = r.label } rule MatchEdges match l : Left!Edge with r : Right!Edge { compare : l.source.matches(r.source) and l.target.matches(r.target) } rule MatchGraphs match l : Left!Graph with r : Right!Graph { compare : true } The MatchNodes rule in line 1 defines that two nodes match if they have the same label. The MatchEdges rule in line 8 specifies that two edges match if both their source and target nodes match (regardless of whether the labels of the edges match or not as it is assumed that there can not be two distinct edges between the same nodes). Finally, since only one instance of Graph is expected to be in each model, the MatchGraphs rule in line 16 returns true for any pair of Graphs. Having established the necessary correspondences between matching elements of the two models, the EML specification below performs the merge. import \"Graphs.etl\"; rule MergeGraphs merge l : Left!Graph with r : Right!Graph into t : Target!Graph { t.label = l.label + \" and \" + r.label; } @abstract rule MergeGraphElements merge l : Left!GraphElement with r : Right!GraphElement into t : Target!GraphElement { t.graph ::= l.graph; } rule MergeNodes merge l : Left!Node with r : Right!Node into t : Target!Node extends GraphElements { t.label = \"c_\" + l.label; } rule MergeEdges merge l : Left!Edge with r : Right!Edge into t : Target!Edge extends GraphElements { t.source ::= l.source; t.target ::= l.target; } In line 3, the MergeGraphs merge rule specifies that two matching Graphs ( l and r ) are to be merged into one Graph t in the target model that has as a label, the concatenation of the labels of the two input graphs separated using 'and'. The mergeNodes rule In line 22 specifies that two matching Nodes are merged into a single Node in the target model. The label of the merged node is derived by concatenating the c (for common) static string with the label of the source Node from the left model. Similarly, the MergeEdges rule specifies that two matching Edges are merged into a single Edge in the target model. The source and target nodes of the merged Edge are set to the equivalents (::=) of the source and target nodes of the edge from the left model. To reduce duplication, the MergeNodes and MergeEdges rules extend the abstract MergeGraphElements rule specified in line 13 which assigns the graph property of the graph element to the equivalent of the left graph. The rules displayed above address only the matching elements of the two models. To also copy the elements for which no equivalent has been found in the opposite model, the EML module imports the ETL module below. rule TransformGraph transform s : Source!Graph to t : Target!Graph { t.label = s.label; } @abstract rule TransformGraphElement transform s : Source!GraphElement to t : Target!GraphElement { t.graph ::= s.graph; } rule TransformNode transform s : Source!Node to t : Target!Node extends TransformGraphElement { t.label = s.graph.label + \"_\" + s.label; } rule TransformEdge transform s : Source!Edge to t : Target!Edge extends TransformGraphElement { t.source ::= s.source; t.target ::= s.target; } The rules of the ETL module apply to model elements of both the Left and the Right model as both have been aliased as Source. Of special interest is the TransformNode rule in line 17 that specifies that non-matching nodes in the two input models will be transformed into nodes in the target model the labels of which will be a concatenation of their input graph and the label of their counterparts in the input models. Executing the ECL and EML modules on the exemplar models displayed in the following two figures creates the target model of the final figure. graph LR n1 --> n2 n1 --> n3 n3 --> n5 n2 --> n4 Left model graph LR n1 --> n8 n1 --> n6 n8 --> n6 n6 --> n3 Right model graph LR c_n1 --> g1_n2 g1_n2 --> c_n4 c_n1 --> g2_n8 g2_n8 --> g2_n6 c_n1 --> g2_n6 c_n1 --> c_n3 c_n3 --> g1_n5 g2_n6 --> c_n3 Merged model","title":"Model Merging (EML)"},{"location":"doc/eml/#the-epsilon-merging-language-eml","text":"The aim of EML is to contribute model merging capabilities to Epsilon. More specifically, EML can be used to merge an arbitrary number of input models of potentially diverse metamodels and modelling technologies. This section provides a discussion on the abstract and concrete syntax of EML, as well as its execution semantics. It also provides two examples of merging homogeneous and heterogeneous models.","title":"The Epsilon Merging Language (EML)"},{"location":"doc/eml/#abstract-syntax","text":"In EML, merging specifications are organized in modules ( EmlModule ). As displayed below, EmlModule inherits from EtlModule . classDiagram class MergeRule { -name: String -abstract: Boolean -lazy: Boolean -primary: Boolean -greedy: Boolean -guard: ExecutableBlock<Boolean> -compare: ExecutableBlock<Boolean> -do: ExecutableBlock<Void> } class Parameter { -name: String -type: EolType } class NamedStatementBlockRule { -name: String -body: StatementBlock } EolModule <|-- ErlModule EtlModule <|-- EmlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule EtlModule <|-- ErlModule ErlModule -- Pre: pre * ErlModule -- Post: post * EmlModule -- MergeRule: rules * MergeRule -- Parameter: left MergeRule -- Parameter: right MergeRule -- Parameter: target MergeRule -- MergeRule: extends * By extending EtlModule , an EML module can contain a number of transformation rules and user-defined operations. An EML module can also contain one or more merge rules as well as a set of pre and post named EOL statement blocks. As usual, pre and post blocks will be run before and after all rules, respectively. Each merge rule defines a name, a left, a right, and one or more target parameters. It can also extend one or more other merge rules and be defined as having one or more of the following properties: abstract, greedy, lazy and primary.","title":"Abstract Syntax"},{"location":"doc/eml/#concrete-syntax","text":"The listing below demonstrates the concrete syntax of EML merge-rules. (@abstract)? (@lazy)? (@primary)? (@greedy)? rule <name> merge <leftParameter> with <rightParameter> into (<targetParameter>(, <targetParameter>)*)? (extends <ruleName>(, <ruleName>)*)? { statementBlock } Pre and post blocks have a simple syntax that consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ }","title":"Concrete Syntax"},{"location":"doc/eml/#execution-semantics","text":"","title":"Execution Semantics"},{"location":"doc/eml/#rule-and-block-overriding","text":"An EML module can import a number of other EML and ETL modules. In this case, the importing EML module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.","title":"Rule and Block Overriding"},{"location":"doc/eml/#rule-scheduling","text":"When an EML module is executed, the pre blocks are executed in the order in which they have been defined. Following that, for each match of the established matchTrace the applicable non-abstract, non-lazy merge rules are executed. When all matches have been merged, the transformation rules of the module are executed on all applicable elements - that have not been merged - in the models. Finally, after all rules have been applied, the post blocks of the module are executed.","title":"Rule Scheduling"},{"location":"doc/eml/#rule-applicability","text":"By default, for a merge-rule to apply to a match , the left and right elements of the match must have a type-of relationship with the leftParameter and rightParameter of the rule respectively. This can be relaxed to a kind-of relationship by specifying that the merge rule is greedy (using the \\@greedy annotation in terms of concrete syntax).","title":"Rule Applicability"},{"location":"doc/eml/#source-elements-resolution","text":"As with model transformation, in model merging it is often required to resolve the counterparts of an element of a source model into the target models. In EML, this is achieved by overloading the semantics of the equivalents() and equivalent() operations defined by ETL. In EML, in addition to inspecting the transformation trace and invoking any applicable transformation rules, the equivalents() operation also examines the mergeTrace (displayed in the figure below) that stores the results of the application of merge-rules and invokes any applicable (both lazy and non-lazy) rules. Similarly to ETL, the order of the results of the equivalents() operation respects the order of the (merge or transform) rules that have produced them. An exception to that occurs if one of the rules has been declared as primary, in which case its results are prepended to the list of elements returned by equivalent. classDiagram class Merge { -left: Object -right: Object -targets: Object[*] } EtlContext <|-- EmlContext EmlContext -- MatchTrace: matchTrace MergeTrace -- EmlContext: mergeTrace MergeTrace -- Merge: merges * Merge -- MergeRule","title":"Source Elements Resolution"},{"location":"doc/eml/#homogeneous-model-merging-example","text":"In this scenario, two models conforming to the Graph metamodel need to be merged. The first step is to compare the two graphs using the ECL module below. rule MatchNodes match l : Left!Node with r : Right!Node { compare : l.label = r.label } rule MatchEdges match l : Left!Edge with r : Right!Edge { compare : l.source.matches(r.source) and l.target.matches(r.target) } rule MatchGraphs match l : Left!Graph with r : Right!Graph { compare : true } The MatchNodes rule in line 1 defines that two nodes match if they have the same label. The MatchEdges rule in line 8 specifies that two edges match if both their source and target nodes match (regardless of whether the labels of the edges match or not as it is assumed that there can not be two distinct edges between the same nodes). Finally, since only one instance of Graph is expected to be in each model, the MatchGraphs rule in line 16 returns true for any pair of Graphs. Having established the necessary correspondences between matching elements of the two models, the EML specification below performs the merge. import \"Graphs.etl\"; rule MergeGraphs merge l : Left!Graph with r : Right!Graph into t : Target!Graph { t.label = l.label + \" and \" + r.label; } @abstract rule MergeGraphElements merge l : Left!GraphElement with r : Right!GraphElement into t : Target!GraphElement { t.graph ::= l.graph; } rule MergeNodes merge l : Left!Node with r : Right!Node into t : Target!Node extends GraphElements { t.label = \"c_\" + l.label; } rule MergeEdges merge l : Left!Edge with r : Right!Edge into t : Target!Edge extends GraphElements { t.source ::= l.source; t.target ::= l.target; } In line 3, the MergeGraphs merge rule specifies that two matching Graphs ( l and r ) are to be merged into one Graph t in the target model that has as a label, the concatenation of the labels of the two input graphs separated using 'and'. The mergeNodes rule In line 22 specifies that two matching Nodes are merged into a single Node in the target model. The label of the merged node is derived by concatenating the c (for common) static string with the label of the source Node from the left model. Similarly, the MergeEdges rule specifies that two matching Edges are merged into a single Edge in the target model. The source and target nodes of the merged Edge are set to the equivalents (::=) of the source and target nodes of the edge from the left model. To reduce duplication, the MergeNodes and MergeEdges rules extend the abstract MergeGraphElements rule specified in line 13 which assigns the graph property of the graph element to the equivalent of the left graph. The rules displayed above address only the matching elements of the two models. To also copy the elements for which no equivalent has been found in the opposite model, the EML module imports the ETL module below. rule TransformGraph transform s : Source!Graph to t : Target!Graph { t.label = s.label; } @abstract rule TransformGraphElement transform s : Source!GraphElement to t : Target!GraphElement { t.graph ::= s.graph; } rule TransformNode transform s : Source!Node to t : Target!Node extends TransformGraphElement { t.label = s.graph.label + \"_\" + s.label; } rule TransformEdge transform s : Source!Edge to t : Target!Edge extends TransformGraphElement { t.source ::= s.source; t.target ::= s.target; } The rules of the ETL module apply to model elements of both the Left and the Right model as both have been aliased as Source. Of special interest is the TransformNode rule in line 17 that specifies that non-matching nodes in the two input models will be transformed into nodes in the target model the labels of which will be a concatenation of their input graph and the label of their counterparts in the input models. Executing the ECL and EML modules on the exemplar models displayed in the following two figures creates the target model of the final figure. graph LR n1 --> n2 n1 --> n3 n3 --> n5 n2 --> n4 Left model graph LR n1 --> n8 n1 --> n6 n8 --> n6 n6 --> n3 Right model graph LR c_n1 --> g1_n2 g1_n2 --> c_n4 c_n1 --> g2_n8 g2_n8 --> g2_n6 c_n1 --> g2_n6 c_n1 --> c_n3 c_n3 --> g1_n5 g2_n6 --> c_n3 Merged model","title":"Homogeneous Model Merging Example"},{"location":"doc/eol/","text":"The Epsilon Object Language (EOL) \u00b6 EOL is the core expression language of Epsilon, and the foundation for task-specific languages for tasks such as model-validation , model-to-text transformation , model-to-model transformation and model migration . EOL can also be used as a general-purpose standalone model management language for automating tasks that do not fall into the patterns targeted by task-specific languages. Try EOL online You can run and fiddle with an EOL program that queries a project scheduling model in the online Epsilon Playground . Syntax \u00b6 EOL programs are organized in modules . Each module defines a body and a number of operations . The body is a block of statements that are evaluated when the module is executed 1 . Each operation defines the kind of objects on which it is applicable ( context ), a name , a set of parameters and optionally a return type . Modules can also import other modules using import statements and access their operations, as shown in the listing below. // file imported.eol operation hello() { \"Hello world!\".println(); } // file importer.eol // We can use relative/absolute paths or platform:/ URIs import \"imported.eol\"; hello(); // main body // ... more operations could be placed here ... classDiagram class EolModule { +main:StatementBlock } class ImportStatement { +imported:EolModule } class Operation { +name: String +context: EolType +parameters: Parameter[*] +returnType: EolType } class ExecutableAnnotation { +expression: Expression } class SimpleAnnotation { +values: String[*] } EolModule -- ImportStatement: * EolModule -- Operation: operations * Operation -- Annotation: annotations * Operation -- StatementBlock: body EolModule -- StatementBlock: main StatementBlock -- Statement: statements * Annotation <|-- ExecutableAnnotation Annotation <|-- SimpleAnnotation User-Defined Operations \u00b6 In mainstream object oriented languages such as Java and C++, operations are defined inside classes and can be invoked on instances of those classes. EOL on the other hand is not object-oriented in the sense that it does not define classes itself, but nevertheless needs to manage objects of types defined externally to it (e.g. in metamodels). By defining the context-type of an operation explicitly, the operation can be called on instances of the type as if it was natively defined by the type. For example, consider the code excerpts displayed in the listings below. In the first listing, the operations add1 and add2 are defined in the context of the built-in Integer type, which is specified before their names. Therefore, they can be invoked in line 1 using the 1.add1().add2() expression: the context (the integer 1 ) will be assigned to the special variable self . On the other hand, in the second listing where no context is defined, they have to be invoked in a nested manner which follows an in-to-out direction instead of the left to right direction used by the former excerpt. As complex model queries often involve invoking multiple properties and operations, this technique is particularly beneficial to the overall readability of the code. 1.add1().add2().println(); operation Integer add1() : Integer { return self + 1; } operation Integer add2() : Integer { return self + 2; } add2(add1(1)).println(); operation add1(base : Integer) : Integer { return base + 1; } operation add2(base : Integer) : Integer { return base + 2; } EOL supports polymorphic operations using a runtime dispatch mechanism. Multiple operations with the same name and parameters can be defined, each defining a distinct context type. For example, in the listing below, the statement in line 1 invokes the test operation defined in line 4, while the statement in line 2 invokes the test operation defined in line 8. \"1\".test(); 1.test(); operation String test() { (self + \" is a string\").println(); } operation Integer test() { (self + \"is an integer\").println(); } Annotations \u00b6 EOL supports two types of annotations: simple and executable. A simple annotation specifies a name and a set of String values while an executable annotation specifies a name and an expression. The concrete syntaxes of simple and executable annotations are displayed in the listing below. // Simple annotation @name value(,value) // Executable annotation $name expression Several examples for simple annotations are shown the listing below. Examples for executable annotations will be given in the following sections. @colors red @colors red, blue @colors red, blue, green In stand-alone EOL, annotations are supported only in the context of operations, however as discussed in the sequel, task-specific languages also make use of annotations in their constructs, each with task-specific semantics. EOL operations support three particular annotations: the pre and post executable annotations for specifying pre and post-conditions, and the cached simple annotation, which are discussed below. Pre/post conditions in user-defined operations \u00b6 A number of pre and post executable annotations can be attached to EOL operations to specify the pre- and post-conditions of the operation. When an operation is invoked, before its body is evaluated, the expressions of the pre annotations are evaluated. If all of them return true , the body of the operation is executed, otherwise, an error is raised. Similarly, once the body of the operation has been executed, the expressions of the post annotations of the operation are executed to ensure that the operation has had the desired effects. Pre and post annotations can access all the variables in the parent scope, as well as the parameters of the operation and the object on which the operation is invoked (through the self variable). Moreover, in post annotations, the returned value of the operation is accessible through the built-in _result variable. An example of using pre and post conditions in EOL appears below. 1.add(2); 1.add(-1); $pre i > 0 $post _result > self operation Integer add(i : Integer) : Integer { return self + i; } In line 4 the add operation defines a pre-condition stating that the parameter i must be a positive number. In line 5, the operation defines that result of the operation ( _result ) must be greater than the number on which it was invoked ( self ). Thus, when executed in the context of the statement in line 1 the operation succeeds, while when executed in the context of the statement in line 2, the pre-condition is not satisfied and an error is raised. Operation Result Caching \u00b6 EOL supports caching the results of parameter-less operations using the @cached simple annotation. In the following example, the Fibonacci number of a given Integer is calculated using the fibonacci recursive operation displayed in the listing below. Since the fibonacci operation is declared as cached , it is only executed once for each distinct Integer and subsequent calls on the same target return the cached result. Therefore, when invoked in line 1, the body of the operation is called 16 times. By contrast, if no @cached annotation was specified, the body of the operation would be called recursively 1973 times. This feature is particularly useful for performing queries on large models and caching their results without needing to introduce explicit variables that store the cached results. It is worth noting that caching works by reference , which means that all clients of a cached method for a given context will receive the same returned object. As such, if the first client modifies the returned object in some way (e.g. sets a property in the case of an object or adds an element in the case of the collection), subsequent clients of the method for the same context will receive the modified object/collection. 15.fibonacci().println(); @cached operation Integer fibonacci() : Integer { if (self = 1 or self = 0) { return 1; } else { return (self-1).fibonacci() + (self-2).fibonacci(); } } Types \u00b6 As is the case for most programming languages, EOL defines a built-in system of types, illustrated in the figure below. The Any type, inspired by the OclAny type of OCL, is the basis of all types in EOL including Collection types. classDiagram class ModelElementType { -model: String -type: String } class Native { -implementation: String } ModelElementType --|> Any Any <|-- Native Any <|-- Collection Any <|-- Map Collection <|-- Bag Collection <|-- Set Collection <|-- OrderedSet Collection <|-- Sequence PrimitiveType --|> Any PrimitiveType <|-- Integer PrimitiveType <|-- String PrimitiveType <|-- Boolean PrimitiveType <|-- Real The operations supported by instances of the Any type are outlined in the table below 2 . Signature Description asBag() : Bag Returns a new Bag containing the object asBoolean() : Boolean Returns a Boolean based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asInteger() : Integer Returns an Integer based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asOrderedSet() : OrderedSet Returns a new OrderedSet containing the object asReal() : Real Returns a Real based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asDouble() : Double Returns a Java Double based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asFloat() : Float Returns a Java Float based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asSequence() : Sequence Returns a new Sequence containing the object asSet() : Set Returns a new Set containing the object asString() : String Returns a string representation of the object err([prefix : String]) : Any Prints a string representation of the object on which it is invoked to the error stream prefixed with the optional prefix string and returns the object on which it was invoked. In this way, the err operation can be used for debugging purposes in a non-invasive manner errln([prefix : String]) : Any Has the same effects as the err operation but also produces a new line in the output stream. format([pattern : String]) : String Uses the provided pattern to form a String representation of the object on which the method is invoked. The pattern argument must conform to the format string syntax defined by Java 3 . hasProperty(name : String) : Boolean Returns true if the object has a property with the specified name or false otherwise ifUndefined(alt : Any) : Any If the object is undefined, it returns alt else it returns the object isDefined() : Boolean Returns true if the object is defined and false otherwise isKindOf(type : Type) : Boolean Returns true if the object is of the given type or one of its subtypes and false otherwise isTypeOf(type : Type) : Boolean Returns true if the object is of the given type and false otherwise isUndefined() : Boolean Returns true if the object is undefined and false otherwise owningModel() : Model Returns the model that contains this object or an undefined value otherwise print([prefix : String]) : Any Prints a string representation of the object on which it is invoked to the regular output stream, prefixed with the optional prefix string and returns the object on which it was invoked. In this way, the print operation can be used for debugging purposes in a non-invasive manner println([prefix : String]) : Any Has the same effects as the print operation but also produces a new line in the output stream. type() : Type Returns the type of the object. Primitive Types \u00b6 EOL provides four primitive types: String, Integer, Real and Boolean. The String type represents a finite sequence of characters and supports the following operations which can be invoked on its instances. Signature Description characterAt(index : Integer) : String Returns the character in the specified index concat(str : String) : String Returns a concatenated form of the string with the str parameter endsWith(str : String) : Boolean Returns true iff the string ends with str escapeXml() : String Returns a new string with escaped XML-reserved characters firstToLowerCase() : String Returns a new string the first character of which has been converted to lower case ftlc() : String Alias for firstToLowerCase() firstToUpperCase() : String Returns a new string, the first character of which has been converted to upper case ftuc : String Alias for firstToUpperCase() isInteger() : Boolean Returns true iff the string is an integer isReal() : Boolean Returns true iff the string is a real number isSubstringOf(str : String) : Boolean Returns true iff the string the operation is invoked on is a substring of str length() : Integer Returns the number of characters in the string matches(reg : String) : Boolean Returns true if there are occurrences of the regular expression reg in the string pad(length : Integer, padding : String, right : Boolean) : String Pads the string up to the specified length with specified padding (e.g. \"foo\".pad(5, \"*\", true) returns \"foo**\" ) replace(source : String, target : String) : String Returns a new string in which all instances of source have been replaced with instances of target split(reg : String) : Sequence(String) Splits the string using as a delimiter the provided regular expression, reg , and returns a sequence containing the parts startsWith(str : String) : Boolean Returns true iff the string starts with str substring(index : Integer) : String Returns a sub-string of the string starting from the specified index and extending to the end of the original string substring(startIndex : Integer, endIndex : Integer) : String Returns a sub-string of the string starting from the specified startIndex and ending at endIndex toCharSequence() : Sequence(String) Returns a sequence containing all the characters of the string toLowerCase() : String Returns a new string where all the characters have been converted to lower case toUpperCase() : String Returns a new string where all the characters have been converted to upper case trim() : String Returns a trimmed copy of the string The Real type represents real numbers and provides the following operations. Signature Description abs() : Real Returns the absolute value of the real ceiling() : Integer Returns the nearest Integer that is greater than the real floor() : Integer Returns the nearest Integer that is less than the real log() : Real Returns the natural logarithm of the real log10() : Real Returns the 10-based logarithm of the real max(other : Real) : Real Returns the maximum of the two reals min(other : Real) : Real Returns the minimum of the two reals pow(exponent : Real) : Real Returns the real to the power of exponent round() : Integer Rounds the real to the nearest Integer The Integer type represents natural numbers and negatives and extends the Real primitive type. It also defines the following operations: Signature Description iota(end : Integer, step : Integer) : Sequence(Integer) Returns a sequence of integers up to end using the specified step (e.g. 1.iota(10,2) returns Sequence{1,3,5,7,9}) mod(divisor : Integer) : Integer Returns the remainder of dividing the integer by the divisor to(other : Integer) : Sequence(Integer) Returns a sequence of integers (e.g. 1.to(5) returns Sequence{1,2,3,4,5}) toBinary() : String Returns the binary representation of the integer (e.g. 6.toBinary() returns \"110\") toHex() : String Returns the hexadecimal representation of the integer (e.g. 42.toBinary() returns \"2a\") Finally, the Boolean type represents true/false states and provides no additional operations to those provided by the base Any type. Collections and Maps \u00b6 EOL provides four types of collections and a Map type. The Bag type represents non-unique, unordered collections and implements the java.util.Collection interface, the Sequence type represents non-unique, ordered collections and implements the java.util.List interface, the Set type represents unique and unordered collections and implements the java.util.Set interface, the OrderedSet represents unique and ordered collections. Since version 2.0, there are also two concurrent collection types, which can safely be modified from multiple threads. These are ConcurrentBag and ConcurrentSet , which are thread-safe variants of the Bag and Set types respectively. All collection types inherit from the abstract Collection type. Apart from simple operations, EOL also supports logic operations on collections. The following operations (along with any operations declared on the java.util.Collection interface) apply to all types of collections: Signature Description add(item : Any) : Boolean Adds an item to the collection. If the collection is a set, addition of duplicate items has no effect. Returns true if the collection increased in size: this is always the case for bags and sequences, and for sets and ordered sets it is true if the element was not part of the collection before. addAll(col : Collection) : Boolean Adds all the items of the col argument to the collection. If the collection is a set, it only adds items that do not already exist in the collection. Returns true if this collection changed as a result of the call asBag() Returns a Bag that contains the same elements as the collection. asOrderedSet() Returns a duplicate-free OrderedSet that contains the same elements as the collection. asSequence() Returns a Sequence that contains the same elements as the collection. asSet() Returns a duplicate-free Set that contains the same elements as the collection. clear() Empties the collection clone() : Collection Returns a new collection of the same type containing the same items with the original collection concat() : String Returns the string created by converting each element of the collection to a string (equivalent to the join method used in some other languages) concat(separator : String) : String Returns the string created by converting each element of the collection to a string, using the given argument as a separator (equivalent to the join method used in some other languages) count(item : Any) : Integer Returns the number of times the item exists in the collection excludes(item : Any) : Boolean Returns true if the collection excludes the item excludesAll(col : Collection) : Boolean Returns true if the collection excludes all the items of collection col excluding(item : Any) : Collection Returns a new collection that excludes the item -- unlike the remove() operation that removes the item from the collection itself excludingAll(col : Collection) : Collection Returns a new collection that excludes all the elements of the col collection flatten() : Collection Recursively flattens all items that are of collection type and returns a new collection where no item is a collection itself includes(item : Any) : Boolean Returns true if the collection includes the item includesAll(col : Collection) : Boolean Returns true if the collection includes all the items of collection col including(item : Any) : Collection Returns a new collection that also contains the item -- unlike the add() operation that adds the item to the collection itself includingAll(col : Collection) : Collection Returns a new collection that is a union of the two collections. The type of the returned collection (i.e. Bag, Sequence, Set, OrderedSet) is same as the type of the collection on which the operation is invoked isEmpty() : Boolean Returns true if the collection does not contain any elements and false otherwise min() : Real Returns the minimum of all reals/integers in the collection, or 0 if it is empty min(default : Real) : Real Returns the minimum of all reals/integers in the collection, or the default value if it is empty max() : Real Returns the maximum of all reals/integers in the collection, or 0 if it is empty max(default : Real) : Real Returns the maximum of all reals/integers in the collection, or the default value if it is empty notEmpty() : Boolean Returns true if the collection contains any elements and false otherwise powerset() : Set Returns the set of all subsets of the collection product() : Real Returns the product of all reals/integers in the collection random() : Any Returns a random item from the collection remove(item : Any) : Boolean Removes an item from the collection. Returns true if the collection contained the specified element removeAll(col : Collection) : Boolean Removes all the items of col from the collection. Returns true if the collection changed as a result of the call size() : Integer Returns the number of items the collection contains sum() : Real Returns the sum of all reals/integers in the collection The following operations apply to ordered collection types (i.e. Sequence and OrderedSet): Signature Description at(index : Integer) : Any Returns the item of the collection at the specified index first() : Any Returns the first item of the collection fourth() : Any Returns the fourth item of the collection indexOf(item : Any) : Integer Returns the index of the item in the collection or -1 if it does not exist invert() : Collection Returns an inverted copy of the collection last() : Any Returns the last item of the collection removeAt(index : Integer) : Any Removes and returns the item at the specified index. second() : Any Returns the second item of the collection third() : Any Returns the third item of the collection Also, EOL collections support the following first-order operations. Apart from aggregate and closure , all of these operations have a parallel variant which can take advantage of multiple cores to improve performance. All computations contained in these operations are assumed to be free from side-effects (i.e. do not mutate global variables). Aside from the following built-in first-order operations which are evaluated eagerly, all Collection types in the Java implementation of EOL support Streams. This allows for chains of queries and transformations on collections to be evaluated more efficiently. A stream can be obtained by calling the stream() method on the collection. The API is defined by the Java standard library 4 . Signature Description atLeastNMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are n or more items in the collection that satisfy the condition atMostNMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are n or fewer items in the collection that satisfy the condition aggregate(iterator : Type | keyExpression, valueExpression) : Map Returns a map containing key-value pairs produced by evaluating the key and value expressions on each item of the collection that is of the specified type closure(iterator : Type | expression) : Collection Returns a collection containing the results of evaluating the transitive closure of the results produced by the expression on each item of the collection that is of the specified type. For example, if t is a tree model element, t.closure(it|it.children) will return all its descendants collect(iterator : Type | expression) : Collection Returns a collection containing the results of evaluating the expression on each item of the collection that is of the specified type count(iterator : Type | condition) : Integer Returns the number of elements in the collection that satisfy the condition exists(iterator : Type | condition) : Boolean Returns true if there exists at least one item in the collection that satisfies the condition forAll(iterator : Type | condition) : Boolean Returns true if all items in the collection satisfy the condition mapBy(iterator : Type | expression) : Map Returns a map containing the results of the expression as keys and the respective items of the collection as values . nMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are exactly n items in the collection that satisfy the condition none(iterator : Type | condition) : Boolean Returns true if there are no items in the collection that satisfy the condition one(iterator : Type | condition) : Boolean Returns true if there exists exactly one item in the collection that satisfies the condition reject(iterator : Type | condition) : Collection Returns a sub-collection containing only items of the specified type that do not satisfy the condition rejectOne(iterator : Type | condition) : Collection Returns a sub-collection containing all elements except the first element which does not satisfy the condition select(iterator : Type | condition) : Collection Returns a sub-collection containing only items of the specified type that satisfy the condition selectByKind(Type) : Collection Returns a sub-collection containing only items of the specified type and subtypes selectByType(Type) : Collection Returns a sub-collection containing only items of the specified type only selectOne(iterator : Type | condition) : Any Returns any element that satisfies the condition sortBy(iterator: Type | expression) : Collection Returns a copy of the collection sorted by the results of evaluating the expression on each item of the collection that conforms to the iterator type. The expression should return either an Integer, a String or an object that is an instance of Comparable. The ordering is calculated as follows: for integers, smaller to greater; for Strings, as defined by the compareTo method of Java strings; for Comparable objects, according to the semantics of the type's compareTo method implementation. The Map type (which implements the java.util.Map interface) represents a Set of key-value pairs in which the keys are unique. Since version 2.0, there is also a thread-safe ConcurrentMap type, which implements the java.util.concurrent.ConcurrentMap interface. The following operations are supported: Signature Description clear() Clears the map containsKey(key : Any) : Boolean Returns true if the map contains the specified key containsValue(value : Any) : Boolean Returns true if this map maps one or more keys to the specified value. get(key : Any) : Any Returns the value for the specified key isEmpty() : Boolean Returns true if the map contains no key-value mappings. keySet() : Set Returns the keys of the map put(key : Any, value : Any) Adds the key-value pair to the map. If the map already contains the same key, the value is overwritten putAll(map : Map) Copies all of the mappings from the specified map to this map. remove(key : Any) : Any Removes the mapping for the specified key from this map if present. Returns the previous value associated with key. size() : Integer Returns the number of key-value mappings in this map. values() : Bag Returns the values of the map Tuples \u00b6 Since version 2.2, EOL supports Tuples, which can be used to compose arbitrary data structures on-the-fly. A Tuple in EOL behaves like a Map<String, Object> , except that the values of the map can be accessed using literal property call expressions. There are three ways to instantiate a tuple, as shown below. // After construction var alice = new Tuple; alice.name = \"Alice\"; alice.age = 32; // During construction var bob = new Tuple(name = \"Bob\", age = 28); // Map Literal var charlie = Tuple{\"name\" = \"Charlie\", \"age\" = 36}; If a non-existent property on a Tuple is accessed, an exception is thrown. var p = new Tuple(name = \"Alice\", age = 32); p.name.substring(0, 3); // \"Ali\" p.age; // 32 p.occupation.isDefined(); // false p.occupation.toUpperCase(); // Property 'occupation' not found Native Types \u00b6 As discussed earlier, while the purpose of EOL is to provide significant expressive power to enable users to manage models at a high level of abstraction, it is not intended to be a general-purpose programming language. Therefore, there may be cases where users need to implement some functionality that is either not efficiently supported by the EOL runtime (e.g. complex mathematical computations) or that EOL does not support at all (e.g. developing user interfaces, accessing databases). To overcome this problem, EOL enables users to create objects of the underlying programming environment by using native types. A native type specifies an implementation property that indicates the unique identifier for an underlying platform type. For instance, in a Java implementation of EOL the user can instantiate and use a Java class via its class identifier. Thus, the EOL excerpt in the listing below creates a Java window (Swing JFrame) and uses its methods to change its title and dimensions and make it visible. var frame = new Native(\"javax.swing.JFrame\"); frame.title = \"Opened with EOL\"; frame.setBounds(100,100,300,200); frame.visible = true; To pass arguments to the constructor of a native type, a parameter list must be added, such as that in the listing below. var file = new Native(\"java.io.File\")(\"myfile.txt\"); file.absolutePath.println(); Static types can also be referenced in EOL and stored in a variable for convenience, as shown below. var Collectors = Native(\"java.util.stream.Collectors\"); Model Element Types \u00b6 A model element type represents a meta-level classifier for model elements. Epsilon intentionally refrains from defining more details about the meaning of a model element type, to be able to support diverse modelling technologies where a type has different semantics. For instance an Ecore EClass, an XSD complex type and a Java class can all be regarded as model element types according to the implementation of the underlying modelling framework. Info As EOL is decoupled from modelling technologies (e.g. EMF, Simulink), through Epsilon's Model Connectivity Layer , we refrain from referring to specific modelling technologies in this section as much as possible. In case of multiple models, as well as the name of the type, the name of the model is also required to resolve a particular type since different models may contain elements of homonymous but different model element types. In case a model defines more than one type with the same name (e.g. in different packages), a fully qualified type name must be provided. In terms of concrete syntax, inspired by ATL , the ! character is used to separate the name of the type from the name of the model it is defined in. For instance, Ma!A represents the type A of model Ma . Also, to support modelling technologies that provide hierarchical grouping of types (e.g. using packages) the :: notation is used to separate between packages and classes. A model element type supports the following operations: Signature Description all() : Collection Alias for getAllOfKind() (for syntax-compactness purposes) allInstances() : Collection Alias for getAllOfKind() (for compatibility with OCL) getAllOfKind() : Collection Returns all the elements in the model that are instances either of the type itself or of one of its subtypes getAllOfType() : Collection Returns all the elements in the model that are instances of the type createInstance() : Any Creates an instance of the type in the model. The same can be achieved using the new operator (see below) isInstantiable() : Boolean Returns true if the type is instantiable (i.e. non-abstract) As an example of the concrete syntax, the listing below retrieves all the instances of the Class type (including instances of its subtypes) defined in the Core package of the UML 1.4 metamodel that are contained in the model named UML14. UML14!Core::Foundation::Class.allInstances(); Creating and Deleting Model Elements \u00b6 EOL provides the new and delete operators for creating and deleting model elements as shown below. The new operator is an alias for the createInstance() method above, and can also be used to create instances of primitive and native types (i.e Java classes). var t : new Tree; // Creates a new instance of type Tree var p : new Source!Person; // Creates a new Person in model Source delete t; // Deletes the element created in line 1 Expressions \u00b6 Literal Values \u00b6 EOL provides special syntax constructs to create instances of each of the built-in types: Integer literals are defined by using one or more decimal digits (such as 42 or 999 ). Optionally, long integers (with the same precision as a Java Long ) can be produced by adding a \"l\" suffix, such as 42l . Real literals are defined by: Adding a decimal separator and non-empty fractional part to the integer part, such as 42.0 or 3.14 . Please note that .2 and 2. are not valid literals. Adding a floating point suffix: \"f\" and \"F\" denote single precision, and \"d\" and \"D\" denote double precision. For example, 2f or 3D . Adding an exponent, such as 2e+1 (equal to 2e1 ) or 2e-1 . Using any combination of the above options. String literals are sequences of characters delimited by single ( 'hi' ) or double ( \"hi\" ) quotes. Quotes inside the string can be escaped by using a backslash, such as in 'A\\'s' or \"A\\\"s\" . Literal backslashes need to be escaped as well, such as in 'A\\\\B' . Special escape sequences are also provided: \\n for a newline, \\t for a horizontal tab and \\r for a carriage return, among others. Boolean literals use the true reserved keyword for the true Boolean value, and false reserved keyword for the false Boolean value. Sequence and most other collections (except Map s) also have literals. Their format is T {e} , where T is the name of the type and e are zero or more elements, separated by commas. For instance, Sequence{} is the empty sequence, and Set {1, 2, 3} is the set of numbers between 1 and 3. Map literals are similar to the sequential collection literals, but their elements are of the form key = value . For instance, Map{\"a\" = 1, \"b\" = 2} is a map which has two keys, \"a\" and \"b\", which map to the integer values 1 and 2, respectively. Please note that, when defining an element such as 1 = 2 = 3 , the key would be 1 and the value would be the result of evaluating 2 = 3 (false). If you would like to use the result of the expression 1 = 2 as key, you will need to enclose it in parenthesis, such as in (1 = 2) = 3 . Feature Navigation \u00b6 Since EOL needs to manage models defined using object oriented modelling technologies, it provides expressions to navigate properties and invoke simple and declarative operations on objects. In terms of concrete syntax, . is used as a uniform operator to access a property of an object and to invoke an operation on it. The -> operator, which is used in OCL to invoke first-order logic operations on sets, has been also preserved for syntax compatibility reasons. In EOL, every operation can be invoked both using the . or the -> operators, with a slightly different semantics to enable overriding the built-in operations. If the . operator is used, precedence is given to the user-defined operations, otherwise precedence is given to the built-in operations. For instance, the Any type defines a println() method that prints the string representation of an object to the standard output stream. In the listing below, the user has defined another parameterless println() operation in the context of Any. Therefore the call to println() in line 1 will be dispatched to the user-defined println() operation defined in line 3. In its body the operation uses the -> operator to invoke the built-in println() operation (line 4). \"Something\".println(); operation Any println() : Any { (\"Printing : \" + self)->println(); } Navigating to the parent/children of model elements EOL does not provide a technology-independent way of navigating to the parent/children of a model element. If you need to do this, you should use any methods provided by the underlying modelling platform. For example, as all elements of EMF models are instances of the EObject Java class, the me.eContainer() and me.eContents() method calls in EMF return the parent and children of element me respectively. Escaping Reserved Keywords \u00b6 Due to the variable nature of (meta-)models and the various domain-specific languages of Epsilon (including EOL itself), feature navigation calls may clash with reserved keywords, leading to a parsing error. Back-ticks can be used to escape such keywords. For example, if a model element contains a feature called operation , then this can be navigated as shown in the listing below. var op = modelElement.`operation`; Arithmetical and Comparison Operators \u00b6 EOL provides common operators for performing arithmetical computations and comparisons illustrated in the following two tables respectively. Operator Description + Adds reals/integers and concatenates strings - Subtracts reals/integers - (unary). Returns the negative of a real/integer * Multiplies reals/integers / Divides reals/integers += Adds the r-value to the l-value -= Subtracts the r-value from the l-value *= Multiplies the l-value by the r-value /= Divides the l-value by the r-value ++ Increments the integer by one -- Decrements the integer by one Operator Description = Returns true if the left hand side equals the right hand side. In the case of primitive types (String, Boolean, Integer, Real) the operator compares the values; in the case of objects it returns true if the two expressions evaluate to the same object == Same as = <> Is the logical negation of the (=) operator != Same as <> > For reals/integers returns true if the left hand side is greater than the right hand side number < For reals/integers returns true if the left hand side is less than the right hand side number >= For reals/integers returns true if the left hand side is greater or equal to the right hand side number <= For reals/integers returns true if the left hand side is less or equal to then right hand side number Logical Operators \u00b6 EOL provides common operators for performing logical computations illustrated in the table below. Logical operations apply only to instances of the Boolean primitive type. Operator Precedence All logical operators in EOL have the same priority. This is in contrast to other languages like Java where e.g. and has a higher priority than or . As a result, while true || true && false returns true in Java, the equivalent true or true and false expression in EOL returns false . Default priorities can be overridden using brackets ( true or (true and false) in this case.) Operator Description and Returns the logical conjunction of the two expressions or Returns the logical disjunction of the two expressions not Returns the logical negation of the expression implies Returns the logical implication of the two expressions (see below) xor Returns true if only one of the involved expressions evaluates to true and false otherwise The truth table for the implies logical operator is below. Left Right Result true true true true false false false true true false false true Ternary Operator \u00b6 As of version 2.0, EOL has a ternary operator which is a concise way of using if/else as an expression. The semantics and syntax are similar to Java, but can be used anywhere as an expression, not only in variable assignments or return statements. The listing below shows some examples of this 5 . Note that is also possible to use the else keyword in place of the colon for separating the true and false expressions for greater clarity. As one would expect, the branches are evaluated lazily: only one of the branches is executed and returned as the result of the expression depending on the value of the Boolean expression before the question mark. var result = 2+2==4 ? \"Yes\" else \"No\"; return ((result == \"Yes\" ? 1 : 0) * 2 == 2).mod(2) == 0; Safe Navigation and Elvis Operator \u00b6 As of version 2.1, EOL supports safe null navigation ?. , which makes it more concise to chain feature call expressions without resorting to defensive null / isDefined() checks. In the following example, the variable result will be null , and the program won't crash since the safe navigation operator is used. var a = null; var result = a?.someProperty?.anotherProperty; The null variant of the \"Elvis operator\" can also be used to simplify null check ternary expressions, as shown in the example below. var a = null; var b = \"result\"; var c = a != null ? a : b; var d = a ?: b; assert(c == d); As with the ternary operator, the Elvis operator can also be used anywhere an expression is expected, not just in assignments. As of Epsilon 2.2, there is also the ?= shortcut assignment operator. This is useful for reassigning a variable if it is null. In other words, a ?= b is equivalent to if (a == null) a = b; . var a = null; var b = \"result\"; a ?= b; assert(a == b); Enumerations \u00b6 EOL provides the # operator for accessing enumeration literals. For example, the VisibilityEnum#vk_public expression returns the value of the literal vk_public of the VisibilityEnum enumeration. For EMF metamodels, VisibilityEnum#vk_public.instance can also be used. Statements \u00b6 Variable Declaration Statement \u00b6 A variable declaration statement declares the name and (optionally) the type and initial value of a variable in an EOL program. If no type is explicitly declared, the variable is assumed to be of type Any . For variables of primitive type, declaration automatically creates an instance of the type with the default values presented in the table below. For non-primitive types the user has to explicitly assign the value of the variable either by using the new keyword or by providing an initial value expression. If neither is done the value of the variable is undefined. Variables in EOL are strongly-typed. Therefore a variable can only be assigned values that conform to its type (or a sub-type of it). Type Default value Integer 0 Boolean false String \"\" Real 0.0 Scope \u00b6 The scope of variables in EOL is generally limited to the block of statements where they are defined, including any nested blocks. Nevertheless, as discussed in the sequel, there are cases in task-specific languages that build atop EOL where the scope of variables is expanded to other non-nested blocks as well. EOL also allows variable shadowing; that is to define a variable with the same name in a nested block that overrides a variable defined in an outer block. The listing below provides an example of declaring and using variables. Line 1 defines a variable named i of type Integer and assigns it an initial value of 5 . Line 2 defines a variable named c of type Class (from model Uml) and creates a new instance of the type in the model (by using the new keyword). The commented out assignment statement of line 3 would raise a runtime error since it would attempt to assign a String value to an Integer variable. The condition of line 4 returns true since the c variable has been initialized before. Line 5 defines a new variable also named i that is of type String and which overrides the Integer variable declared in line 1. Therefore the assignment statement of line 6 is legitimate as it assigns a string value to a variable of type String. Finally, as the program has exited the scope of the if statement, the assignment statement of line 7 is also legitimate as it refers to the i variable defined in line 1. var i : Integer = 5; var c : new Uml!Class; //i = \"somevalue\"; if (c.isDefined()) { var i : String; i = \"somevalue\"; } i = 3; Assignment Statement \u00b6 The assignment statement is used to update the values of variables and properties of native objects and model elements. Variable Assignment \u00b6 When the left hand side of an assignment statement is a variable, the value of the variable is updated to the object to which the right hand side evaluates to. If the type of the right hand side is not compatible (kind-of relationship) with the type of the variable, the assignment is illegal and a runtime error is raised. Assignment to objects of primitive types is performed by value while assignment to instances of non-primitive values is performed by reference. For example, in the listing below, in line 1 the value of the a variable is set to a new Class in the Uml model. In line 2, a new untyped variable b is declared and its value is assigned to a. In line 3 the name of the class is updated to Customer and thus, line 4 prints Customer to the standard output stream. var a : new Uml!Class; var b = a; a.name = \"Customer\"; b.name.println(); On the other hand, in the listing below, in line 1 the a String variable is declared. In line 2 an untyped variable b is declared. In line 3, the value of a is changed to Customer (which is an instance of the primitive String type). This has no effect on b and thus line 4 prints an empty string to the standard output stream. var a : String; var b = a; a = \"Customer\"; b.println(); Native Object Property Assignment \u00b6 When the left hand side of the assignment is a property of a native object, deciding on the legality and providing the semantics of the assignment is delegated to the execution engine. For example, in a Java-based execution engine, given that x is a native object, the statement x.y = a may be interpreted as x.setY(a) or if x is an instance of a map x.put(\"y\",a) . By contrast, in a C# implementation, it can be interpreted as x.y = a since the language natively supports properties in classes. Model Element Property Assignment \u00b6 When the left hand side of the assignment is a property of a model element, the model that owns the particular model element (accessible using the ModelRepository.getOwningModel() operation) is responsible for implementing the semantics of the assignment using its associated propertyGetter . For example, if x is a model element, the statement x.y = a may be interpreted using the Java code of the first listing below if x belongs to an EMF-based model or using the Java code of the second listing if it belongs to an MDR-based model. EStructuralFeature feature = x . eClass (). getEStructuralFeature ( \"y\" ); x . eSet ( feature , a ); StructuralFeature feature = findStructuralFeature ( x . refClass (), \"y\" ); x . refSetValue ( feature , a ); Special Assignment Statement \u00b6 In task-specific languages, an assignment operator with task-specific semantics is often required. Therefore, EOL provides an additional assignment operator. In standalone EOL, the operator has the same semantics with the primary assignment operator discussed above, however task-specific languages can redefine its semantics to implement custom assignment behaviour. For example, consider the simple model-to-model transformation of the listing below where a simple object oriented model is transformed to a simple database model using an ETL transformation. rule Class2Table transform c : OO!Class to t : DB!Table { t.name = c.name; } rule Attribute2Column transform a : OO!Attribute to c : DB!Column { c.name = a.name; //c.owningTable = a.owningClass; c.owningTable ::= a.owningClass; } The Class2Table rule transforms a Class of the OO model into a Table in the DB model and sets the name of the table to be the same as the name of the class. Rule Atribute2Column transforms an Attribute from the OO model into a Column in the DB model. Except for setting its name (line 12), it also needs to define that the column belongs to the table which corresponds to the class that defines the source attribute. The commented-out assignment statement of line 13 cannot be used for this purpose since it would illegally attempt to assign the owningTable feature of the column to a model element of an inappropriate type ( OO!Class ). However, the special assignment operator in ETL has language-specific semantics , and thus in line 14 it assigns to the owningTable feature not the class that owns the attribute but its corresponding table (calculated using the Class2Table rule) in the DB model. If Statement \u00b6 As in most programming languages, an if statement consists of a condition, a block of statements that is executed if the condition is satisfied and (optionally) a block of statements that is executed otherwise. As an example, in the listing below, if variable a holds a value that is greater than 0 the statement of line 3 is executed, otherwise the statement of line 5 is executed. if (a > 0) { \"A is greater than 0\".println(); } else { \"A is less equal than 0\".println(); } Switch Statement \u00b6 A switch statement consists of an expression and a set of cases, and can be used to implement multi-branching. Unlike Java/C, switch in EOL doesn't by default fall through to the next case after a successful one. Therefore, it is not necessary to add a break statement after each case. To enable falling through to all subsequent cases you can use the continue statement. Also, unlike Java/C, the switch expression can return anything (not only integers). As an example, when executed, the code in the listing below prints 2 while the code in the following listing prints 2,3,default . var i = \"2\"; switch (i) { case \"1\" : \"1\".println(); case \"2\" : \"2\".println(); case \"3\" : \"3\".println(); default : \"default\".println(); } var i = \"2\"; switch (i) { case \"1\" : \"1\".println(); case \"2\" : \"2\".println(); continue; case \"3\" : \"3\".println(); default : \"default\".println(); } While Statement \u00b6 A while statement consists of a condition and a block of statements which are executed as long as the condition is satisfied. For example, in the listing below, the body of the while statement is executed 5 times printing the numbers 0 to 4 to the output console. Inside the body of a while statement, the built-in read-only loopCount integer variable holds the number of times the innermost loop has been executed so far (including the current iteration). Right after entering the loop for the first time and before running the first statement in its body, loopCount is set to 1, and it is incremented after each following iteration. var i : Integer = 0; while (i < 5) { // both lines print the same thing i.println(); (loopCount - 1).println(); // increment the counter i = i+1; } For Statement \u00b6 In EOL, for statements are used to iterate the contents of collections. A for statement defines a typed iterator and an iterated collection as well as a block of statements that is executed for every item in the collection that has a kind-of relationship with the type defined by the iterator. As with the majority of programming languages, modifying a collection while iterating it raises a runtime error. To avoid this situation, users can use the clone() built-in operation of the Collection type. var col : Sequence = Sequence{\"a\", 1, 2, 2.5, \"b\"}; for (r : Real in col) { r.print(); if (hasMore){\",\".print();} } Inside the body of a for statement, two built-in read-only variables are visible: the loopCount integer variable and the hasMore boolean variable. hasMore is used to determine if there are more items if the collection for which the loop will be executed. For example, in the listing below the col heterogeneous Sequence is defined that contains two strings ( a and b ), two integers ( 1 , 2 ) and one real ( 2.5 ). The for loop of line 2 only iterates through the items of the collection that are of kind Real and therefore prints 1,2,2.5 to the standard output stream. Break, BreakAll and Continue Statements \u00b6 To exit from for and while loops on demand, EOL provides the break and breakAll statements. The break statement exits the innermost loop while the breakAll statement exits all outer loops as well. On the other hand, to skip a particular loop and proceed with the next one, EOL provides the continue statement. For example, the program in the listing below, prints 2,1 3,1 to the standard output stream. for (i in Sequence{1..3}) { if (i = 1) {continue;} for (j in Sequence{1..4}) { if (j = 2) {break;} if (j = 3) {breakAll;} (i + \",\" + j).println(); } } Throw Statement \u00b6 EOL provides the throw statement for throwing a value as an Java exception. This is especially useful when invoking EOL scripts from Java code: by catching and processing the exception, the Java code may be able to automatically handle the problem without requiring user input. Any value can be thrown, as shown in the listing below where we throw a number and a string. throw 42; throw \"Error!\"; Transaction Statement \u00b6 The underlying EMC layer provides support for transactions in models. To utilize this feature EOL provides the transaction statement. A transaction statement (optionally) defines the models that participate in the transaction. If no models are defined, it is assumed that all the models that are accessible from the enclosing program participate. When the statement is executed, a transaction is started on each participating model. If no errors are raised during the execution of the contained statements, any changes made to model elements are committed. On the other hand, if an error is raised the transaction is rolled back and any changes made to the models in the context of the transaction are undone. The user can also use the abort statement to explicitly exit a transaction and roll-back any changes done in its context. In the listing below, an example of using this feature in a simulation problem is illustrated. var system : System.allInstances.first(); for (i in Sequence {1..100}) { transaction { var failedProcessors : Set; while (failedProcessors.size() < 10) { failedProcessors.add(system.processors.random()); } for (processor in failedProcessors) { processor.failed = true; processor.moveTasksElsewhere(); } system.evaluateAvailability(); abort; } } In this problem, a system consists of a number of processors. A processor manages some tasks and can fail at any time. The EOL program in the listing above performs 100 simulation steps, in every one of which 10 random processors from the model (lines 7-11) are marked as failed by setting their failed property to true (line 14). Then, the tasks that the failed processors manage are moved to other processors (line 15). Finally the availability of the system in this state is evaluated. After a simulation step, the state of the model has been drastically changed since processors have failed and tasks have been relocated. To be able to restore the model to its original state after every simulation step, each step is executed in the context of a transaction which is explicitly aborted (line 20) after evaluating the availability of the system. Therefore after each simulation step the model is restored to its original state for the next step to be executed. Extended Properties \u00b6 Quite often, during a model management operation it is necessary to associate model elements with information that is not supported by the metamodel they conform to. For instance, the EOL program in the listing below calculates the depth of each Tree element in a model that conforms to the Tree metamodel displayed below. classDiagram class Tree { +label: String +parent: Tree +children: Tree[*] } Tree -- Tree As the Tree metamodel doesn't support a depth property in the Tree metaclass, each Tree has to be associated with its calculated depth using the depths map defined in line 1. Another approach would be to extend the Tree metamodel to support the desired depth property; however, applying this technique every time an additional property is needed for some model management operation would quickly pollute the metamodel with properties of secondary importance. var depths = new Map; for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + depths.get(n)).println(); } operation Tree setDepth(depth : Integer) { depths.put(self,depth); for (c in self.children) { c.setDepth(depth + 1); } } To simplify the code required in such cases, EOL provides the concept of extended properties . In terms of concrete syntax, an extended property is a normal property, the name of which starts with the tilde character ( ~ ). With regards to its execution semantics, the first time the value of an extended property of an object is assigned, the property is created and associated with the object. Then, the property can be accessed as a normal property. If an extended property is accessed before it is assigned, it returns null . The listing below demonstrates using a ~depth extended property to eliminate the need for using the depths map in the listing that follows it. for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + n.~depth).println(); } operation Tree setDepth(depth : Integer) { self.~depth = depth; for (c in self.children) { c.setDepth(depth + 1); } } Context-Independent User Input \u00b6 A common assumption in model management languages is that model management tasks are only executed in a batch-manner without human intervention. However, as demonstrated in the sequel, it is often useful for the user to provide feedback that can precisely drive the execution of a model management operation. Model management operations can be executed in a number of runtime environments in each of which a different user-input method is more appropriate. For instance when executed in the context of an IDE (such as Eclipse) visual dialogs are preferable, while when executed in the context of a server or from within an ANT workflow, a command-line user input interface is deemed more suitable. To abstract away from the different runtime environments and enable the user to specify user interaction statements uniformly and regardless of the runtime context, EOL provides the IUserInput interface that can be realized in different ways according to the execution environment and attached to the runtime context via the IEolContext.setUserInput(IUserInput userInput) method. The IUserInput specifies the methods presented in the table below. Signature Description inform(message : String) Displays the specified message to the user confirm(message : String, [default : Boolean]) : Boolean Prompts the user to confirm if the condition described by the message holds prompt(message : String, [default : String]) : String Prompts the user for a string in response to the message promptInteger(message : String, [default : Integer]) : Integer Prompts the user for an Integer promptReal(message : String, [default : Real]) : Real Prompts the user for a Real choose(message : String, options : Sequence, [default : Any]) : Any Prompts the user to select one of the options chooseMany(message : String, options : Sequence, [default : Sequence]) : Sequence Prompts the user to select one or more of the options As displayed above, all the methods of the IUserInput interface accept a default parameter. The purpose of this parameter is dual. First, it enables the designer of the model management program to prompt the user with the most likely value as a default choice and secondly it enables a concrete implementation of the interface ( UnattendedExecutionUserInput ) which returns the default values without prompting the user at all and thus, can be used for unattended execution of interactive Epsilon programs. The figures below demonstrate the interfaces through which input is required by the user when the exemplar System.user.promptInteger(\"Please enter a number\", 1); statement is executed using an Eclipse-based and a command-line-based IUserInput implementation respectively. User-input facilities have been found to be particularly useful in all model management tasks. Such facilities are essential for performing operations on live models such as model validation and model refactoring but can also be useful in model comparison where marginal matching decisions can be delegated to the user and model transformation where the user can interactively specify the elements that will be transformed into corresponding elements in the target model. Additional Resources \u00b6 Additional resources about EOL are available here . Although the EOL parser permits loose statements (e.g. not contained in operations) between/after operations, these are ignored at runtime. \u21a9 Parameters within square brackets are optional \u21a9 http://download.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax \u21a9 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html \u21a9 For further examples of ternary operator, see https://github.com/eclipse/epsilon/tree/main/tests/org.eclipse.epsilon.eol.engine.test.acceptance/src/org/eclipse/epsilon/eol/engine/test/acceptance/TernaryTests.eol \u21a9","title":"Object Language (EOL)"},{"location":"doc/eol/#the-epsilon-object-language-eol","text":"EOL is the core expression language of Epsilon, and the foundation for task-specific languages for tasks such as model-validation , model-to-text transformation , model-to-model transformation and model migration . EOL can also be used as a general-purpose standalone model management language for automating tasks that do not fall into the patterns targeted by task-specific languages. Try EOL online You can run and fiddle with an EOL program that queries a project scheduling model in the online Epsilon Playground .","title":"The Epsilon Object Language (EOL)"},{"location":"doc/eol/#syntax","text":"EOL programs are organized in modules . Each module defines a body and a number of operations . The body is a block of statements that are evaluated when the module is executed 1 . Each operation defines the kind of objects on which it is applicable ( context ), a name , a set of parameters and optionally a return type . Modules can also import other modules using import statements and access their operations, as shown in the listing below. // file imported.eol operation hello() { \"Hello world!\".println(); } // file importer.eol // We can use relative/absolute paths or platform:/ URIs import \"imported.eol\"; hello(); // main body // ... more operations could be placed here ... classDiagram class EolModule { +main:StatementBlock } class ImportStatement { +imported:EolModule } class Operation { +name: String +context: EolType +parameters: Parameter[*] +returnType: EolType } class ExecutableAnnotation { +expression: Expression } class SimpleAnnotation { +values: String[*] } EolModule -- ImportStatement: * EolModule -- Operation: operations * Operation -- Annotation: annotations * Operation -- StatementBlock: body EolModule -- StatementBlock: main StatementBlock -- Statement: statements * Annotation <|-- ExecutableAnnotation Annotation <|-- SimpleAnnotation","title":"Syntax"},{"location":"doc/eol/#user-defined-operations","text":"In mainstream object oriented languages such as Java and C++, operations are defined inside classes and can be invoked on instances of those classes. EOL on the other hand is not object-oriented in the sense that it does not define classes itself, but nevertheless needs to manage objects of types defined externally to it (e.g. in metamodels). By defining the context-type of an operation explicitly, the operation can be called on instances of the type as if it was natively defined by the type. For example, consider the code excerpts displayed in the listings below. In the first listing, the operations add1 and add2 are defined in the context of the built-in Integer type, which is specified before their names. Therefore, they can be invoked in line 1 using the 1.add1().add2() expression: the context (the integer 1 ) will be assigned to the special variable self . On the other hand, in the second listing where no context is defined, they have to be invoked in a nested manner which follows an in-to-out direction instead of the left to right direction used by the former excerpt. As complex model queries often involve invoking multiple properties and operations, this technique is particularly beneficial to the overall readability of the code. 1.add1().add2().println(); operation Integer add1() : Integer { return self + 1; } operation Integer add2() : Integer { return self + 2; } add2(add1(1)).println(); operation add1(base : Integer) : Integer { return base + 1; } operation add2(base : Integer) : Integer { return base + 2; } EOL supports polymorphic operations using a runtime dispatch mechanism. Multiple operations with the same name and parameters can be defined, each defining a distinct context type. For example, in the listing below, the statement in line 1 invokes the test operation defined in line 4, while the statement in line 2 invokes the test operation defined in line 8. \"1\".test(); 1.test(); operation String test() { (self + \" is a string\").println(); } operation Integer test() { (self + \"is an integer\").println(); }","title":"User-Defined Operations"},{"location":"doc/eol/#annotations","text":"EOL supports two types of annotations: simple and executable. A simple annotation specifies a name and a set of String values while an executable annotation specifies a name and an expression. The concrete syntaxes of simple and executable annotations are displayed in the listing below. // Simple annotation @name value(,value) // Executable annotation $name expression Several examples for simple annotations are shown the listing below. Examples for executable annotations will be given in the following sections. @colors red @colors red, blue @colors red, blue, green In stand-alone EOL, annotations are supported only in the context of operations, however as discussed in the sequel, task-specific languages also make use of annotations in their constructs, each with task-specific semantics. EOL operations support three particular annotations: the pre and post executable annotations for specifying pre and post-conditions, and the cached simple annotation, which are discussed below.","title":"Annotations"},{"location":"doc/eol/#prepost-conditions-in-user-defined-operations","text":"A number of pre and post executable annotations can be attached to EOL operations to specify the pre- and post-conditions of the operation. When an operation is invoked, before its body is evaluated, the expressions of the pre annotations are evaluated. If all of them return true , the body of the operation is executed, otherwise, an error is raised. Similarly, once the body of the operation has been executed, the expressions of the post annotations of the operation are executed to ensure that the operation has had the desired effects. Pre and post annotations can access all the variables in the parent scope, as well as the parameters of the operation and the object on which the operation is invoked (through the self variable). Moreover, in post annotations, the returned value of the operation is accessible through the built-in _result variable. An example of using pre and post conditions in EOL appears below. 1.add(2); 1.add(-1); $pre i > 0 $post _result > self operation Integer add(i : Integer) : Integer { return self + i; } In line 4 the add operation defines a pre-condition stating that the parameter i must be a positive number. In line 5, the operation defines that result of the operation ( _result ) must be greater than the number on which it was invoked ( self ). Thus, when executed in the context of the statement in line 1 the operation succeeds, while when executed in the context of the statement in line 2, the pre-condition is not satisfied and an error is raised.","title":"Pre/post conditions in user-defined operations"},{"location":"doc/eol/#operation-result-caching","text":"EOL supports caching the results of parameter-less operations using the @cached simple annotation. In the following example, the Fibonacci number of a given Integer is calculated using the fibonacci recursive operation displayed in the listing below. Since the fibonacci operation is declared as cached , it is only executed once for each distinct Integer and subsequent calls on the same target return the cached result. Therefore, when invoked in line 1, the body of the operation is called 16 times. By contrast, if no @cached annotation was specified, the body of the operation would be called recursively 1973 times. This feature is particularly useful for performing queries on large models and caching their results without needing to introduce explicit variables that store the cached results. It is worth noting that caching works by reference , which means that all clients of a cached method for a given context will receive the same returned object. As such, if the first client modifies the returned object in some way (e.g. sets a property in the case of an object or adds an element in the case of the collection), subsequent clients of the method for the same context will receive the modified object/collection. 15.fibonacci().println(); @cached operation Integer fibonacci() : Integer { if (self = 1 or self = 0) { return 1; } else { return (self-1).fibonacci() + (self-2).fibonacci(); } }","title":"Operation Result Caching"},{"location":"doc/eol/#types","text":"As is the case for most programming languages, EOL defines a built-in system of types, illustrated in the figure below. The Any type, inspired by the OclAny type of OCL, is the basis of all types in EOL including Collection types. classDiagram class ModelElementType { -model: String -type: String } class Native { -implementation: String } ModelElementType --|> Any Any <|-- Native Any <|-- Collection Any <|-- Map Collection <|-- Bag Collection <|-- Set Collection <|-- OrderedSet Collection <|-- Sequence PrimitiveType --|> Any PrimitiveType <|-- Integer PrimitiveType <|-- String PrimitiveType <|-- Boolean PrimitiveType <|-- Real The operations supported by instances of the Any type are outlined in the table below 2 . Signature Description asBag() : Bag Returns a new Bag containing the object asBoolean() : Boolean Returns a Boolean based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asInteger() : Integer Returns an Integer based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asOrderedSet() : OrderedSet Returns a new OrderedSet containing the object asReal() : Real Returns a Real based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asDouble() : Double Returns a Java Double based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asFloat() : Float Returns a Java Float based on the string representation of the object. If the string representation is not of an acceptable format, an error is raised asSequence() : Sequence Returns a new Sequence containing the object asSet() : Set Returns a new Set containing the object asString() : String Returns a string representation of the object err([prefix : String]) : Any Prints a string representation of the object on which it is invoked to the error stream prefixed with the optional prefix string and returns the object on which it was invoked. In this way, the err operation can be used for debugging purposes in a non-invasive manner errln([prefix : String]) : Any Has the same effects as the err operation but also produces a new line in the output stream. format([pattern : String]) : String Uses the provided pattern to form a String representation of the object on which the method is invoked. The pattern argument must conform to the format string syntax defined by Java 3 . hasProperty(name : String) : Boolean Returns true if the object has a property with the specified name or false otherwise ifUndefined(alt : Any) : Any If the object is undefined, it returns alt else it returns the object isDefined() : Boolean Returns true if the object is defined and false otherwise isKindOf(type : Type) : Boolean Returns true if the object is of the given type or one of its subtypes and false otherwise isTypeOf(type : Type) : Boolean Returns true if the object is of the given type and false otherwise isUndefined() : Boolean Returns true if the object is undefined and false otherwise owningModel() : Model Returns the model that contains this object or an undefined value otherwise print([prefix : String]) : Any Prints a string representation of the object on which it is invoked to the regular output stream, prefixed with the optional prefix string and returns the object on which it was invoked. In this way, the print operation can be used for debugging purposes in a non-invasive manner println([prefix : String]) : Any Has the same effects as the print operation but also produces a new line in the output stream. type() : Type Returns the type of the object.","title":"Types"},{"location":"doc/eol/#primitive-types","text":"EOL provides four primitive types: String, Integer, Real and Boolean. The String type represents a finite sequence of characters and supports the following operations which can be invoked on its instances. Signature Description characterAt(index : Integer) : String Returns the character in the specified index concat(str : String) : String Returns a concatenated form of the string with the str parameter endsWith(str : String) : Boolean Returns true iff the string ends with str escapeXml() : String Returns a new string with escaped XML-reserved characters firstToLowerCase() : String Returns a new string the first character of which has been converted to lower case ftlc() : String Alias for firstToLowerCase() firstToUpperCase() : String Returns a new string, the first character of which has been converted to upper case ftuc : String Alias for firstToUpperCase() isInteger() : Boolean Returns true iff the string is an integer isReal() : Boolean Returns true iff the string is a real number isSubstringOf(str : String) : Boolean Returns true iff the string the operation is invoked on is a substring of str length() : Integer Returns the number of characters in the string matches(reg : String) : Boolean Returns true if there are occurrences of the regular expression reg in the string pad(length : Integer, padding : String, right : Boolean) : String Pads the string up to the specified length with specified padding (e.g. \"foo\".pad(5, \"*\", true) returns \"foo**\" ) replace(source : String, target : String) : String Returns a new string in which all instances of source have been replaced with instances of target split(reg : String) : Sequence(String) Splits the string using as a delimiter the provided regular expression, reg , and returns a sequence containing the parts startsWith(str : String) : Boolean Returns true iff the string starts with str substring(index : Integer) : String Returns a sub-string of the string starting from the specified index and extending to the end of the original string substring(startIndex : Integer, endIndex : Integer) : String Returns a sub-string of the string starting from the specified startIndex and ending at endIndex toCharSequence() : Sequence(String) Returns a sequence containing all the characters of the string toLowerCase() : String Returns a new string where all the characters have been converted to lower case toUpperCase() : String Returns a new string where all the characters have been converted to upper case trim() : String Returns a trimmed copy of the string The Real type represents real numbers and provides the following operations. Signature Description abs() : Real Returns the absolute value of the real ceiling() : Integer Returns the nearest Integer that is greater than the real floor() : Integer Returns the nearest Integer that is less than the real log() : Real Returns the natural logarithm of the real log10() : Real Returns the 10-based logarithm of the real max(other : Real) : Real Returns the maximum of the two reals min(other : Real) : Real Returns the minimum of the two reals pow(exponent : Real) : Real Returns the real to the power of exponent round() : Integer Rounds the real to the nearest Integer The Integer type represents natural numbers and negatives and extends the Real primitive type. It also defines the following operations: Signature Description iota(end : Integer, step : Integer) : Sequence(Integer) Returns a sequence of integers up to end using the specified step (e.g. 1.iota(10,2) returns Sequence{1,3,5,7,9}) mod(divisor : Integer) : Integer Returns the remainder of dividing the integer by the divisor to(other : Integer) : Sequence(Integer) Returns a sequence of integers (e.g. 1.to(5) returns Sequence{1,2,3,4,5}) toBinary() : String Returns the binary representation of the integer (e.g. 6.toBinary() returns \"110\") toHex() : String Returns the hexadecimal representation of the integer (e.g. 42.toBinary() returns \"2a\") Finally, the Boolean type represents true/false states and provides no additional operations to those provided by the base Any type.","title":"Primitive Types"},{"location":"doc/eol/#collections-and-maps","text":"EOL provides four types of collections and a Map type. The Bag type represents non-unique, unordered collections and implements the java.util.Collection interface, the Sequence type represents non-unique, ordered collections and implements the java.util.List interface, the Set type represents unique and unordered collections and implements the java.util.Set interface, the OrderedSet represents unique and ordered collections. Since version 2.0, there are also two concurrent collection types, which can safely be modified from multiple threads. These are ConcurrentBag and ConcurrentSet , which are thread-safe variants of the Bag and Set types respectively. All collection types inherit from the abstract Collection type. Apart from simple operations, EOL also supports logic operations on collections. The following operations (along with any operations declared on the java.util.Collection interface) apply to all types of collections: Signature Description add(item : Any) : Boolean Adds an item to the collection. If the collection is a set, addition of duplicate items has no effect. Returns true if the collection increased in size: this is always the case for bags and sequences, and for sets and ordered sets it is true if the element was not part of the collection before. addAll(col : Collection) : Boolean Adds all the items of the col argument to the collection. If the collection is a set, it only adds items that do not already exist in the collection. Returns true if this collection changed as a result of the call asBag() Returns a Bag that contains the same elements as the collection. asOrderedSet() Returns a duplicate-free OrderedSet that contains the same elements as the collection. asSequence() Returns a Sequence that contains the same elements as the collection. asSet() Returns a duplicate-free Set that contains the same elements as the collection. clear() Empties the collection clone() : Collection Returns a new collection of the same type containing the same items with the original collection concat() : String Returns the string created by converting each element of the collection to a string (equivalent to the join method used in some other languages) concat(separator : String) : String Returns the string created by converting each element of the collection to a string, using the given argument as a separator (equivalent to the join method used in some other languages) count(item : Any) : Integer Returns the number of times the item exists in the collection excludes(item : Any) : Boolean Returns true if the collection excludes the item excludesAll(col : Collection) : Boolean Returns true if the collection excludes all the items of collection col excluding(item : Any) : Collection Returns a new collection that excludes the item -- unlike the remove() operation that removes the item from the collection itself excludingAll(col : Collection) : Collection Returns a new collection that excludes all the elements of the col collection flatten() : Collection Recursively flattens all items that are of collection type and returns a new collection where no item is a collection itself includes(item : Any) : Boolean Returns true if the collection includes the item includesAll(col : Collection) : Boolean Returns true if the collection includes all the items of collection col including(item : Any) : Collection Returns a new collection that also contains the item -- unlike the add() operation that adds the item to the collection itself includingAll(col : Collection) : Collection Returns a new collection that is a union of the two collections. The type of the returned collection (i.e. Bag, Sequence, Set, OrderedSet) is same as the type of the collection on which the operation is invoked isEmpty() : Boolean Returns true if the collection does not contain any elements and false otherwise min() : Real Returns the minimum of all reals/integers in the collection, or 0 if it is empty min(default : Real) : Real Returns the minimum of all reals/integers in the collection, or the default value if it is empty max() : Real Returns the maximum of all reals/integers in the collection, or 0 if it is empty max(default : Real) : Real Returns the maximum of all reals/integers in the collection, or the default value if it is empty notEmpty() : Boolean Returns true if the collection contains any elements and false otherwise powerset() : Set Returns the set of all subsets of the collection product() : Real Returns the product of all reals/integers in the collection random() : Any Returns a random item from the collection remove(item : Any) : Boolean Removes an item from the collection. Returns true if the collection contained the specified element removeAll(col : Collection) : Boolean Removes all the items of col from the collection. Returns true if the collection changed as a result of the call size() : Integer Returns the number of items the collection contains sum() : Real Returns the sum of all reals/integers in the collection The following operations apply to ordered collection types (i.e. Sequence and OrderedSet): Signature Description at(index : Integer) : Any Returns the item of the collection at the specified index first() : Any Returns the first item of the collection fourth() : Any Returns the fourth item of the collection indexOf(item : Any) : Integer Returns the index of the item in the collection or -1 if it does not exist invert() : Collection Returns an inverted copy of the collection last() : Any Returns the last item of the collection removeAt(index : Integer) : Any Removes and returns the item at the specified index. second() : Any Returns the second item of the collection third() : Any Returns the third item of the collection Also, EOL collections support the following first-order operations. Apart from aggregate and closure , all of these operations have a parallel variant which can take advantage of multiple cores to improve performance. All computations contained in these operations are assumed to be free from side-effects (i.e. do not mutate global variables). Aside from the following built-in first-order operations which are evaluated eagerly, all Collection types in the Java implementation of EOL support Streams. This allows for chains of queries and transformations on collections to be evaluated more efficiently. A stream can be obtained by calling the stream() method on the collection. The API is defined by the Java standard library 4 . Signature Description atLeastNMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are n or more items in the collection that satisfy the condition atMostNMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are n or fewer items in the collection that satisfy the condition aggregate(iterator : Type | keyExpression, valueExpression) : Map Returns a map containing key-value pairs produced by evaluating the key and value expressions on each item of the collection that is of the specified type closure(iterator : Type | expression) : Collection Returns a collection containing the results of evaluating the transitive closure of the results produced by the expression on each item of the collection that is of the specified type. For example, if t is a tree model element, t.closure(it|it.children) will return all its descendants collect(iterator : Type | expression) : Collection Returns a collection containing the results of evaluating the expression on each item of the collection that is of the specified type count(iterator : Type | condition) : Integer Returns the number of elements in the collection that satisfy the condition exists(iterator : Type | condition) : Boolean Returns true if there exists at least one item in the collection that satisfies the condition forAll(iterator : Type | condition) : Boolean Returns true if all items in the collection satisfy the condition mapBy(iterator : Type | expression) : Map Returns a map containing the results of the expression as keys and the respective items of the collection as values . nMatch(iterator : Type | condition, n : Integer) : Boolean Returns true if there are exactly n items in the collection that satisfy the condition none(iterator : Type | condition) : Boolean Returns true if there are no items in the collection that satisfy the condition one(iterator : Type | condition) : Boolean Returns true if there exists exactly one item in the collection that satisfies the condition reject(iterator : Type | condition) : Collection Returns a sub-collection containing only items of the specified type that do not satisfy the condition rejectOne(iterator : Type | condition) : Collection Returns a sub-collection containing all elements except the first element which does not satisfy the condition select(iterator : Type | condition) : Collection Returns a sub-collection containing only items of the specified type that satisfy the condition selectByKind(Type) : Collection Returns a sub-collection containing only items of the specified type and subtypes selectByType(Type) : Collection Returns a sub-collection containing only items of the specified type only selectOne(iterator : Type | condition) : Any Returns any element that satisfies the condition sortBy(iterator: Type | expression) : Collection Returns a copy of the collection sorted by the results of evaluating the expression on each item of the collection that conforms to the iterator type. The expression should return either an Integer, a String or an object that is an instance of Comparable. The ordering is calculated as follows: for integers, smaller to greater; for Strings, as defined by the compareTo method of Java strings; for Comparable objects, according to the semantics of the type's compareTo method implementation. The Map type (which implements the java.util.Map interface) represents a Set of key-value pairs in which the keys are unique. Since version 2.0, there is also a thread-safe ConcurrentMap type, which implements the java.util.concurrent.ConcurrentMap interface. The following operations are supported: Signature Description clear() Clears the map containsKey(key : Any) : Boolean Returns true if the map contains the specified key containsValue(value : Any) : Boolean Returns true if this map maps one or more keys to the specified value. get(key : Any) : Any Returns the value for the specified key isEmpty() : Boolean Returns true if the map contains no key-value mappings. keySet() : Set Returns the keys of the map put(key : Any, value : Any) Adds the key-value pair to the map. If the map already contains the same key, the value is overwritten putAll(map : Map) Copies all of the mappings from the specified map to this map. remove(key : Any) : Any Removes the mapping for the specified key from this map if present. Returns the previous value associated with key. size() : Integer Returns the number of key-value mappings in this map. values() : Bag Returns the values of the map","title":"Collections and Maps"},{"location":"doc/eol/#tuples","text":"Since version 2.2, EOL supports Tuples, which can be used to compose arbitrary data structures on-the-fly. A Tuple in EOL behaves like a Map<String, Object> , except that the values of the map can be accessed using literal property call expressions. There are three ways to instantiate a tuple, as shown below. // After construction var alice = new Tuple; alice.name = \"Alice\"; alice.age = 32; // During construction var bob = new Tuple(name = \"Bob\", age = 28); // Map Literal var charlie = Tuple{\"name\" = \"Charlie\", \"age\" = 36}; If a non-existent property on a Tuple is accessed, an exception is thrown. var p = new Tuple(name = \"Alice\", age = 32); p.name.substring(0, 3); // \"Ali\" p.age; // 32 p.occupation.isDefined(); // false p.occupation.toUpperCase(); // Property 'occupation' not found","title":"Tuples"},{"location":"doc/eol/#native-types","text":"As discussed earlier, while the purpose of EOL is to provide significant expressive power to enable users to manage models at a high level of abstraction, it is not intended to be a general-purpose programming language. Therefore, there may be cases where users need to implement some functionality that is either not efficiently supported by the EOL runtime (e.g. complex mathematical computations) or that EOL does not support at all (e.g. developing user interfaces, accessing databases). To overcome this problem, EOL enables users to create objects of the underlying programming environment by using native types. A native type specifies an implementation property that indicates the unique identifier for an underlying platform type. For instance, in a Java implementation of EOL the user can instantiate and use a Java class via its class identifier. Thus, the EOL excerpt in the listing below creates a Java window (Swing JFrame) and uses its methods to change its title and dimensions and make it visible. var frame = new Native(\"javax.swing.JFrame\"); frame.title = \"Opened with EOL\"; frame.setBounds(100,100,300,200); frame.visible = true; To pass arguments to the constructor of a native type, a parameter list must be added, such as that in the listing below. var file = new Native(\"java.io.File\")(\"myfile.txt\"); file.absolutePath.println(); Static types can also be referenced in EOL and stored in a variable for convenience, as shown below. var Collectors = Native(\"java.util.stream.Collectors\");","title":"Native Types"},{"location":"doc/eol/#model-element-types","text":"A model element type represents a meta-level classifier for model elements. Epsilon intentionally refrains from defining more details about the meaning of a model element type, to be able to support diverse modelling technologies where a type has different semantics. For instance an Ecore EClass, an XSD complex type and a Java class can all be regarded as model element types according to the implementation of the underlying modelling framework. Info As EOL is decoupled from modelling technologies (e.g. EMF, Simulink), through Epsilon's Model Connectivity Layer , we refrain from referring to specific modelling technologies in this section as much as possible. In case of multiple models, as well as the name of the type, the name of the model is also required to resolve a particular type since different models may contain elements of homonymous but different model element types. In case a model defines more than one type with the same name (e.g. in different packages), a fully qualified type name must be provided. In terms of concrete syntax, inspired by ATL , the ! character is used to separate the name of the type from the name of the model it is defined in. For instance, Ma!A represents the type A of model Ma . Also, to support modelling technologies that provide hierarchical grouping of types (e.g. using packages) the :: notation is used to separate between packages and classes. A model element type supports the following operations: Signature Description all() : Collection Alias for getAllOfKind() (for syntax-compactness purposes) allInstances() : Collection Alias for getAllOfKind() (for compatibility with OCL) getAllOfKind() : Collection Returns all the elements in the model that are instances either of the type itself or of one of its subtypes getAllOfType() : Collection Returns all the elements in the model that are instances of the type createInstance() : Any Creates an instance of the type in the model. The same can be achieved using the new operator (see below) isInstantiable() : Boolean Returns true if the type is instantiable (i.e. non-abstract) As an example of the concrete syntax, the listing below retrieves all the instances of the Class type (including instances of its subtypes) defined in the Core package of the UML 1.4 metamodel that are contained in the model named UML14. UML14!Core::Foundation::Class.allInstances();","title":"Model Element Types"},{"location":"doc/eol/#creating-and-deleting-model-elements","text":"EOL provides the new and delete operators for creating and deleting model elements as shown below. The new operator is an alias for the createInstance() method above, and can also be used to create instances of primitive and native types (i.e Java classes). var t : new Tree; // Creates a new instance of type Tree var p : new Source!Person; // Creates a new Person in model Source delete t; // Deletes the element created in line 1","title":"Creating and Deleting Model Elements"},{"location":"doc/eol/#expressions","text":"","title":"Expressions"},{"location":"doc/eol/#literal-values","text":"EOL provides special syntax constructs to create instances of each of the built-in types: Integer literals are defined by using one or more decimal digits (such as 42 or 999 ). Optionally, long integers (with the same precision as a Java Long ) can be produced by adding a \"l\" suffix, such as 42l . Real literals are defined by: Adding a decimal separator and non-empty fractional part to the integer part, such as 42.0 or 3.14 . Please note that .2 and 2. are not valid literals. Adding a floating point suffix: \"f\" and \"F\" denote single precision, and \"d\" and \"D\" denote double precision. For example, 2f or 3D . Adding an exponent, such as 2e+1 (equal to 2e1 ) or 2e-1 . Using any combination of the above options. String literals are sequences of characters delimited by single ( 'hi' ) or double ( \"hi\" ) quotes. Quotes inside the string can be escaped by using a backslash, such as in 'A\\'s' or \"A\\\"s\" . Literal backslashes need to be escaped as well, such as in 'A\\\\B' . Special escape sequences are also provided: \\n for a newline, \\t for a horizontal tab and \\r for a carriage return, among others. Boolean literals use the true reserved keyword for the true Boolean value, and false reserved keyword for the false Boolean value. Sequence and most other collections (except Map s) also have literals. Their format is T {e} , where T is the name of the type and e are zero or more elements, separated by commas. For instance, Sequence{} is the empty sequence, and Set {1, 2, 3} is the set of numbers between 1 and 3. Map literals are similar to the sequential collection literals, but their elements are of the form key = value . For instance, Map{\"a\" = 1, \"b\" = 2} is a map which has two keys, \"a\" and \"b\", which map to the integer values 1 and 2, respectively. Please note that, when defining an element such as 1 = 2 = 3 , the key would be 1 and the value would be the result of evaluating 2 = 3 (false). If you would like to use the result of the expression 1 = 2 as key, you will need to enclose it in parenthesis, such as in (1 = 2) = 3 .","title":"Literal Values"},{"location":"doc/eol/#feature-navigation","text":"Since EOL needs to manage models defined using object oriented modelling technologies, it provides expressions to navigate properties and invoke simple and declarative operations on objects. In terms of concrete syntax, . is used as a uniform operator to access a property of an object and to invoke an operation on it. The -> operator, which is used in OCL to invoke first-order logic operations on sets, has been also preserved for syntax compatibility reasons. In EOL, every operation can be invoked both using the . or the -> operators, with a slightly different semantics to enable overriding the built-in operations. If the . operator is used, precedence is given to the user-defined operations, otherwise precedence is given to the built-in operations. For instance, the Any type defines a println() method that prints the string representation of an object to the standard output stream. In the listing below, the user has defined another parameterless println() operation in the context of Any. Therefore the call to println() in line 1 will be dispatched to the user-defined println() operation defined in line 3. In its body the operation uses the -> operator to invoke the built-in println() operation (line 4). \"Something\".println(); operation Any println() : Any { (\"Printing : \" + self)->println(); } Navigating to the parent/children of model elements EOL does not provide a technology-independent way of navigating to the parent/children of a model element. If you need to do this, you should use any methods provided by the underlying modelling platform. For example, as all elements of EMF models are instances of the EObject Java class, the me.eContainer() and me.eContents() method calls in EMF return the parent and children of element me respectively.","title":"Feature Navigation"},{"location":"doc/eol/#escaping-reserved-keywords","text":"Due to the variable nature of (meta-)models and the various domain-specific languages of Epsilon (including EOL itself), feature navigation calls may clash with reserved keywords, leading to a parsing error. Back-ticks can be used to escape such keywords. For example, if a model element contains a feature called operation , then this can be navigated as shown in the listing below. var op = modelElement.`operation`;","title":"Escaping Reserved Keywords"},{"location":"doc/eol/#arithmetical-and-comparison-operators","text":"EOL provides common operators for performing arithmetical computations and comparisons illustrated in the following two tables respectively. Operator Description + Adds reals/integers and concatenates strings - Subtracts reals/integers - (unary). Returns the negative of a real/integer * Multiplies reals/integers / Divides reals/integers += Adds the r-value to the l-value -= Subtracts the r-value from the l-value *= Multiplies the l-value by the r-value /= Divides the l-value by the r-value ++ Increments the integer by one -- Decrements the integer by one Operator Description = Returns true if the left hand side equals the right hand side. In the case of primitive types (String, Boolean, Integer, Real) the operator compares the values; in the case of objects it returns true if the two expressions evaluate to the same object == Same as = <> Is the logical negation of the (=) operator != Same as <> > For reals/integers returns true if the left hand side is greater than the right hand side number < For reals/integers returns true if the left hand side is less than the right hand side number >= For reals/integers returns true if the left hand side is greater or equal to the right hand side number <= For reals/integers returns true if the left hand side is less or equal to then right hand side number","title":"Arithmetical and Comparison Operators"},{"location":"doc/eol/#logical-operators","text":"EOL provides common operators for performing logical computations illustrated in the table below. Logical operations apply only to instances of the Boolean primitive type. Operator Precedence All logical operators in EOL have the same priority. This is in contrast to other languages like Java where e.g. and has a higher priority than or . As a result, while true || true && false returns true in Java, the equivalent true or true and false expression in EOL returns false . Default priorities can be overridden using brackets ( true or (true and false) in this case.) Operator Description and Returns the logical conjunction of the two expressions or Returns the logical disjunction of the two expressions not Returns the logical negation of the expression implies Returns the logical implication of the two expressions (see below) xor Returns true if only one of the involved expressions evaluates to true and false otherwise The truth table for the implies logical operator is below. Left Right Result true true true true false false false true true false false true","title":"Logical Operators"},{"location":"doc/eol/#ternary-operator","text":"As of version 2.0, EOL has a ternary operator which is a concise way of using if/else as an expression. The semantics and syntax are similar to Java, but can be used anywhere as an expression, not only in variable assignments or return statements. The listing below shows some examples of this 5 . Note that is also possible to use the else keyword in place of the colon for separating the true and false expressions for greater clarity. As one would expect, the branches are evaluated lazily: only one of the branches is executed and returned as the result of the expression depending on the value of the Boolean expression before the question mark. var result = 2+2==4 ? \"Yes\" else \"No\"; return ((result == \"Yes\" ? 1 : 0) * 2 == 2).mod(2) == 0;","title":"Ternary Operator"},{"location":"doc/eol/#safe-navigation-and-elvis-operator","text":"As of version 2.1, EOL supports safe null navigation ?. , which makes it more concise to chain feature call expressions without resorting to defensive null / isDefined() checks. In the following example, the variable result will be null , and the program won't crash since the safe navigation operator is used. var a = null; var result = a?.someProperty?.anotherProperty; The null variant of the \"Elvis operator\" can also be used to simplify null check ternary expressions, as shown in the example below. var a = null; var b = \"result\"; var c = a != null ? a : b; var d = a ?: b; assert(c == d); As with the ternary operator, the Elvis operator can also be used anywhere an expression is expected, not just in assignments. As of Epsilon 2.2, there is also the ?= shortcut assignment operator. This is useful for reassigning a variable if it is null. In other words, a ?= b is equivalent to if (a == null) a = b; . var a = null; var b = \"result\"; a ?= b; assert(a == b);","title":"Safe Navigation and Elvis Operator"},{"location":"doc/eol/#enumerations","text":"EOL provides the # operator for accessing enumeration literals. For example, the VisibilityEnum#vk_public expression returns the value of the literal vk_public of the VisibilityEnum enumeration. For EMF metamodels, VisibilityEnum#vk_public.instance can also be used.","title":"Enumerations"},{"location":"doc/eol/#statements","text":"","title":"Statements"},{"location":"doc/eol/#variable-declaration-statement","text":"A variable declaration statement declares the name and (optionally) the type and initial value of a variable in an EOL program. If no type is explicitly declared, the variable is assumed to be of type Any . For variables of primitive type, declaration automatically creates an instance of the type with the default values presented in the table below. For non-primitive types the user has to explicitly assign the value of the variable either by using the new keyword or by providing an initial value expression. If neither is done the value of the variable is undefined. Variables in EOL are strongly-typed. Therefore a variable can only be assigned values that conform to its type (or a sub-type of it). Type Default value Integer 0 Boolean false String \"\" Real 0.0","title":"Variable Declaration Statement"},{"location":"doc/eol/#scope","text":"The scope of variables in EOL is generally limited to the block of statements where they are defined, including any nested blocks. Nevertheless, as discussed in the sequel, there are cases in task-specific languages that build atop EOL where the scope of variables is expanded to other non-nested blocks as well. EOL also allows variable shadowing; that is to define a variable with the same name in a nested block that overrides a variable defined in an outer block. The listing below provides an example of declaring and using variables. Line 1 defines a variable named i of type Integer and assigns it an initial value of 5 . Line 2 defines a variable named c of type Class (from model Uml) and creates a new instance of the type in the model (by using the new keyword). The commented out assignment statement of line 3 would raise a runtime error since it would attempt to assign a String value to an Integer variable. The condition of line 4 returns true since the c variable has been initialized before. Line 5 defines a new variable also named i that is of type String and which overrides the Integer variable declared in line 1. Therefore the assignment statement of line 6 is legitimate as it assigns a string value to a variable of type String. Finally, as the program has exited the scope of the if statement, the assignment statement of line 7 is also legitimate as it refers to the i variable defined in line 1. var i : Integer = 5; var c : new Uml!Class; //i = \"somevalue\"; if (c.isDefined()) { var i : String; i = \"somevalue\"; } i = 3;","title":"Scope"},{"location":"doc/eol/#assignment-statement","text":"The assignment statement is used to update the values of variables and properties of native objects and model elements.","title":"Assignment Statement"},{"location":"doc/eol/#variable-assignment","text":"When the left hand side of an assignment statement is a variable, the value of the variable is updated to the object to which the right hand side evaluates to. If the type of the right hand side is not compatible (kind-of relationship) with the type of the variable, the assignment is illegal and a runtime error is raised. Assignment to objects of primitive types is performed by value while assignment to instances of non-primitive values is performed by reference. For example, in the listing below, in line 1 the value of the a variable is set to a new Class in the Uml model. In line 2, a new untyped variable b is declared and its value is assigned to a. In line 3 the name of the class is updated to Customer and thus, line 4 prints Customer to the standard output stream. var a : new Uml!Class; var b = a; a.name = \"Customer\"; b.name.println(); On the other hand, in the listing below, in line 1 the a String variable is declared. In line 2 an untyped variable b is declared. In line 3, the value of a is changed to Customer (which is an instance of the primitive String type). This has no effect on b and thus line 4 prints an empty string to the standard output stream. var a : String; var b = a; a = \"Customer\"; b.println();","title":"Variable Assignment"},{"location":"doc/eol/#native-object-property-assignment","text":"When the left hand side of the assignment is a property of a native object, deciding on the legality and providing the semantics of the assignment is delegated to the execution engine. For example, in a Java-based execution engine, given that x is a native object, the statement x.y = a may be interpreted as x.setY(a) or if x is an instance of a map x.put(\"y\",a) . By contrast, in a C# implementation, it can be interpreted as x.y = a since the language natively supports properties in classes.","title":"Native Object Property Assignment"},{"location":"doc/eol/#model-element-property-assignment","text":"When the left hand side of the assignment is a property of a model element, the model that owns the particular model element (accessible using the ModelRepository.getOwningModel() operation) is responsible for implementing the semantics of the assignment using its associated propertyGetter . For example, if x is a model element, the statement x.y = a may be interpreted using the Java code of the first listing below if x belongs to an EMF-based model or using the Java code of the second listing if it belongs to an MDR-based model. EStructuralFeature feature = x . eClass (). getEStructuralFeature ( \"y\" ); x . eSet ( feature , a ); StructuralFeature feature = findStructuralFeature ( x . refClass (), \"y\" ); x . refSetValue ( feature , a );","title":"Model Element Property Assignment"},{"location":"doc/eol/#special-assignment-statement","text":"In task-specific languages, an assignment operator with task-specific semantics is often required. Therefore, EOL provides an additional assignment operator. In standalone EOL, the operator has the same semantics with the primary assignment operator discussed above, however task-specific languages can redefine its semantics to implement custom assignment behaviour. For example, consider the simple model-to-model transformation of the listing below where a simple object oriented model is transformed to a simple database model using an ETL transformation. rule Class2Table transform c : OO!Class to t : DB!Table { t.name = c.name; } rule Attribute2Column transform a : OO!Attribute to c : DB!Column { c.name = a.name; //c.owningTable = a.owningClass; c.owningTable ::= a.owningClass; } The Class2Table rule transforms a Class of the OO model into a Table in the DB model and sets the name of the table to be the same as the name of the class. Rule Atribute2Column transforms an Attribute from the OO model into a Column in the DB model. Except for setting its name (line 12), it also needs to define that the column belongs to the table which corresponds to the class that defines the source attribute. The commented-out assignment statement of line 13 cannot be used for this purpose since it would illegally attempt to assign the owningTable feature of the column to a model element of an inappropriate type ( OO!Class ). However, the special assignment operator in ETL has language-specific semantics , and thus in line 14 it assigns to the owningTable feature not the class that owns the attribute but its corresponding table (calculated using the Class2Table rule) in the DB model.","title":"Special Assignment Statement"},{"location":"doc/eol/#if-statement","text":"As in most programming languages, an if statement consists of a condition, a block of statements that is executed if the condition is satisfied and (optionally) a block of statements that is executed otherwise. As an example, in the listing below, if variable a holds a value that is greater than 0 the statement of line 3 is executed, otherwise the statement of line 5 is executed. if (a > 0) { \"A is greater than 0\".println(); } else { \"A is less equal than 0\".println(); }","title":"If Statement"},{"location":"doc/eol/#switch-statement","text":"A switch statement consists of an expression and a set of cases, and can be used to implement multi-branching. Unlike Java/C, switch in EOL doesn't by default fall through to the next case after a successful one. Therefore, it is not necessary to add a break statement after each case. To enable falling through to all subsequent cases you can use the continue statement. Also, unlike Java/C, the switch expression can return anything (not only integers). As an example, when executed, the code in the listing below prints 2 while the code in the following listing prints 2,3,default . var i = \"2\"; switch (i) { case \"1\" : \"1\".println(); case \"2\" : \"2\".println(); case \"3\" : \"3\".println(); default : \"default\".println(); } var i = \"2\"; switch (i) { case \"1\" : \"1\".println(); case \"2\" : \"2\".println(); continue; case \"3\" : \"3\".println(); default : \"default\".println(); }","title":"Switch Statement"},{"location":"doc/eol/#while-statement","text":"A while statement consists of a condition and a block of statements which are executed as long as the condition is satisfied. For example, in the listing below, the body of the while statement is executed 5 times printing the numbers 0 to 4 to the output console. Inside the body of a while statement, the built-in read-only loopCount integer variable holds the number of times the innermost loop has been executed so far (including the current iteration). Right after entering the loop for the first time and before running the first statement in its body, loopCount is set to 1, and it is incremented after each following iteration. var i : Integer = 0; while (i < 5) { // both lines print the same thing i.println(); (loopCount - 1).println(); // increment the counter i = i+1; }","title":"While Statement"},{"location":"doc/eol/#for-statement","text":"In EOL, for statements are used to iterate the contents of collections. A for statement defines a typed iterator and an iterated collection as well as a block of statements that is executed for every item in the collection that has a kind-of relationship with the type defined by the iterator. As with the majority of programming languages, modifying a collection while iterating it raises a runtime error. To avoid this situation, users can use the clone() built-in operation of the Collection type. var col : Sequence = Sequence{\"a\", 1, 2, 2.5, \"b\"}; for (r : Real in col) { r.print(); if (hasMore){\",\".print();} } Inside the body of a for statement, two built-in read-only variables are visible: the loopCount integer variable and the hasMore boolean variable. hasMore is used to determine if there are more items if the collection for which the loop will be executed. For example, in the listing below the col heterogeneous Sequence is defined that contains two strings ( a and b ), two integers ( 1 , 2 ) and one real ( 2.5 ). The for loop of line 2 only iterates through the items of the collection that are of kind Real and therefore prints 1,2,2.5 to the standard output stream.","title":"For Statement"},{"location":"doc/eol/#break-breakall-and-continue-statements","text":"To exit from for and while loops on demand, EOL provides the break and breakAll statements. The break statement exits the innermost loop while the breakAll statement exits all outer loops as well. On the other hand, to skip a particular loop and proceed with the next one, EOL provides the continue statement. For example, the program in the listing below, prints 2,1 3,1 to the standard output stream. for (i in Sequence{1..3}) { if (i = 1) {continue;} for (j in Sequence{1..4}) { if (j = 2) {break;} if (j = 3) {breakAll;} (i + \",\" + j).println(); } }","title":"Break, BreakAll and Continue Statements"},{"location":"doc/eol/#throw-statement","text":"EOL provides the throw statement for throwing a value as an Java exception. This is especially useful when invoking EOL scripts from Java code: by catching and processing the exception, the Java code may be able to automatically handle the problem without requiring user input. Any value can be thrown, as shown in the listing below where we throw a number and a string. throw 42; throw \"Error!\";","title":"Throw Statement"},{"location":"doc/eol/#transaction-statement","text":"The underlying EMC layer provides support for transactions in models. To utilize this feature EOL provides the transaction statement. A transaction statement (optionally) defines the models that participate in the transaction. If no models are defined, it is assumed that all the models that are accessible from the enclosing program participate. When the statement is executed, a transaction is started on each participating model. If no errors are raised during the execution of the contained statements, any changes made to model elements are committed. On the other hand, if an error is raised the transaction is rolled back and any changes made to the models in the context of the transaction are undone. The user can also use the abort statement to explicitly exit a transaction and roll-back any changes done in its context. In the listing below, an example of using this feature in a simulation problem is illustrated. var system : System.allInstances.first(); for (i in Sequence {1..100}) { transaction { var failedProcessors : Set; while (failedProcessors.size() < 10) { failedProcessors.add(system.processors.random()); } for (processor in failedProcessors) { processor.failed = true; processor.moveTasksElsewhere(); } system.evaluateAvailability(); abort; } } In this problem, a system consists of a number of processors. A processor manages some tasks and can fail at any time. The EOL program in the listing above performs 100 simulation steps, in every one of which 10 random processors from the model (lines 7-11) are marked as failed by setting their failed property to true (line 14). Then, the tasks that the failed processors manage are moved to other processors (line 15). Finally the availability of the system in this state is evaluated. After a simulation step, the state of the model has been drastically changed since processors have failed and tasks have been relocated. To be able to restore the model to its original state after every simulation step, each step is executed in the context of a transaction which is explicitly aborted (line 20) after evaluating the availability of the system. Therefore after each simulation step the model is restored to its original state for the next step to be executed.","title":"Transaction Statement"},{"location":"doc/eol/#extended-properties","text":"Quite often, during a model management operation it is necessary to associate model elements with information that is not supported by the metamodel they conform to. For instance, the EOL program in the listing below calculates the depth of each Tree element in a model that conforms to the Tree metamodel displayed below. classDiagram class Tree { +label: String +parent: Tree +children: Tree[*] } Tree -- Tree As the Tree metamodel doesn't support a depth property in the Tree metaclass, each Tree has to be associated with its calculated depth using the depths map defined in line 1. Another approach would be to extend the Tree metamodel to support the desired depth property; however, applying this technique every time an additional property is needed for some model management operation would quickly pollute the metamodel with properties of secondary importance. var depths = new Map; for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + depths.get(n)).println(); } operation Tree setDepth(depth : Integer) { depths.put(self,depth); for (c in self.children) { c.setDepth(depth + 1); } } To simplify the code required in such cases, EOL provides the concept of extended properties . In terms of concrete syntax, an extended property is a normal property, the name of which starts with the tilde character ( ~ ). With regards to its execution semantics, the first time the value of an extended property of an object is assigned, the property is created and associated with the object. Then, the property can be accessed as a normal property. If an extended property is accessed before it is assigned, it returns null . The listing below demonstrates using a ~depth extended property to eliminate the need for using the depths map in the listing that follows it. for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + n.~depth).println(); } operation Tree setDepth(depth : Integer) { self.~depth = depth; for (c in self.children) { c.setDepth(depth + 1); } }","title":"Extended Properties"},{"location":"doc/eol/#context-independent-user-input","text":"A common assumption in model management languages is that model management tasks are only executed in a batch-manner without human intervention. However, as demonstrated in the sequel, it is often useful for the user to provide feedback that can precisely drive the execution of a model management operation. Model management operations can be executed in a number of runtime environments in each of which a different user-input method is more appropriate. For instance when executed in the context of an IDE (such as Eclipse) visual dialogs are preferable, while when executed in the context of a server or from within an ANT workflow, a command-line user input interface is deemed more suitable. To abstract away from the different runtime environments and enable the user to specify user interaction statements uniformly and regardless of the runtime context, EOL provides the IUserInput interface that can be realized in different ways according to the execution environment and attached to the runtime context via the IEolContext.setUserInput(IUserInput userInput) method. The IUserInput specifies the methods presented in the table below. Signature Description inform(message : String) Displays the specified message to the user confirm(message : String, [default : Boolean]) : Boolean Prompts the user to confirm if the condition described by the message holds prompt(message : String, [default : String]) : String Prompts the user for a string in response to the message promptInteger(message : String, [default : Integer]) : Integer Prompts the user for an Integer promptReal(message : String, [default : Real]) : Real Prompts the user for a Real choose(message : String, options : Sequence, [default : Any]) : Any Prompts the user to select one of the options chooseMany(message : String, options : Sequence, [default : Sequence]) : Sequence Prompts the user to select one or more of the options As displayed above, all the methods of the IUserInput interface accept a default parameter. The purpose of this parameter is dual. First, it enables the designer of the model management program to prompt the user with the most likely value as a default choice and secondly it enables a concrete implementation of the interface ( UnattendedExecutionUserInput ) which returns the default values without prompting the user at all and thus, can be used for unattended execution of interactive Epsilon programs. The figures below demonstrate the interfaces through which input is required by the user when the exemplar System.user.promptInteger(\"Please enter a number\", 1); statement is executed using an Eclipse-based and a command-line-based IUserInput implementation respectively. User-input facilities have been found to be particularly useful in all model management tasks. Such facilities are essential for performing operations on live models such as model validation and model refactoring but can also be useful in model comparison where marginal matching decisions can be delegated to the user and model transformation where the user can interactively specify the elements that will be transformed into corresponding elements in the target model.","title":"Context-Independent User Input"},{"location":"doc/eol/#additional-resources","text":"Additional resources about EOL are available here . Although the EOL parser permits loose statements (e.g. not contained in operations) between/after operations, these are ignored at runtime. \u21a9 Parameters within square brackets are optional \u21a9 http://download.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax \u21a9 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html \u21a9 For further examples of ternary operator, see https://github.com/eclipse/epsilon/tree/main/tests/org.eclipse.epsilon.eol.engine.test.acceptance/src/org/eclipse/epsilon/eol/engine/test/acceptance/TernaryTests.eol \u21a9","title":"Additional Resources"},{"location":"doc/epl/","text":"The Epsilon Pattern Language (EPL) \u00b6 The aim of EPL is to contribute pattern matching capabilities to Epsilon. This chapter discusses the abstract and concrete syntax of EPL as well as its execution semantics. To aid understanding, the discussion of the syntax and the semantics of the language revolves around an exemplar pattern which is developed incrementally throughout the chapter. The exemplar pattern is matched against models extracted from Java source code using tooling provided by the MoDisco project. MoDisco is an Eclipse project that provides a fine-grained Ecore-based metamodel of the Java language as well as tooling for extracting models that conform to this Java metamodel from Java source code. A simplified view of the relevant part of the MoDisco Java metamodel used in this running example is presented below. The aim of the pattern developed here (which we will call PublicField ) is to identify quartets of <ClassDeclaration, FieldDeclaration, MethodDeclaration, MethodDeclaration> , each representing a field of a Java class for which appropriately named accessor/getter (getX/isX) and mutator/setter (setX) methods are defined by the class. classDiagram class ClassDeclaration { +name: String +bodyDeclarations: BodyDeclaration[*] } class BodyDeclaration { +name: String +modifiers: Modifier[*] } class VariableDeclarationFragment { +name: String } class FieldDeclaration { +fragments: VariableDeclarationFragment[*] +type: TypeAccess } class MethodDeclaration { +returnType: TypeAccess } class VariableDeclarationFragment { +name: String } class Modifier { +visibility: VisibilityKind } class VisibilityKind { #none #public #protected #private } ClassDeclaration -- BodyDeclaration: bodyDeclarations * BodyDeclaration -- Modifier: modifiers * Modifier -- VisibilityKind: visibility BodyDeclaration <|-- FieldDeclaration MethodDeclaration --|> BodyDeclaration FieldDeclaration -- VariableDeclarationFragment: fragments * FieldDeclaration -- TypeAccess: type MethodDeclaration -- TypeAccess: returnType Syntax \u00b6 The syntax of EPL is an extension of the syntax of the EOL language , which is the core language of Epsilon. As such, any references to expression and statement block in this chapter, refer to EOL expressions and blocks of EOL statements respectively. It is also worth noting that EOL expressions and statements can produce side-effects on models, and therefore, it is the responsibility of the developer to decide which expressions used in the context of EPL patterns should be side-effect free and which not. As illustrated in the figure below, EPL patterns are organised in modules . Each module contains a number of named patterns and optionally, pre and post statement blocks that are executed before and after the pattern matching process, and helper EOL operations. EPL modules can import other EPL and EOL modules to facilitate reuse and modularity. classDiagram class EplModule { -iterative: Boolean -maxLoops: Integer } class Pattern { -name: String -match: ExecutableBlock<Boolean> -onMatch: ExecutableBlock<Void> -noMatch: ExecutableBlock<Void> -do: ExecutableBlock<Void> } class Role { -names: String[1..*] -negative: Boolean -type: EolType -guard: ExecutableBlock<Boolean> -active: ExecutableBlock<Boolean> -optional: ExecutableBlock<Boolean> } class Cardinality { -lowerBound: Integer -upperBound: Integer } EolModule <|-- ErlModule ErlModule <|-- EplModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EplModule -- Pattern: patterns * Pattern -- Role: roles * Role -- Domain: domain Domain <|-- StaticDomain Domain <|-- DynamicDomain Role -- Cardinality: cardinality In its simplest form a pattern consists of a number of named and typed roles and a match condition. For example, in lines 2-3, the PublicField pattern below, defines four roles ( class , field , setter and getter ). The match condition of the pattern specifies that for a quartet to be a valid match, the field, setter and getter must all belong to the class (lines 5-7, and that the setter and getter methods must be appropriately named 1 . pattern PublicField class : ClassDeclaration, field : FieldDeclaration, setter : MethodDeclaration, getter : MethodDeclaration { match : class.bodyDeclarations.includes(field) class.bodyDeclarations.includes(setter) and class.bodyDeclarations.includes(getter) and setter.name = \"set\" + field.getName() and (getter.name = \"get\" + field.getName() or getter.name = \"is\" + field.getName()) } @cached operation FieldDeclaration getName() { return self.fragments.at(0).name.firstToUpperCase(); } The implementation of the PublicField pattern above is fully functional but not particularly efficient as the match condition needs to be evaluated #ClassDefinition * #FieldDeclaration * #MethodDeclaration^2 times. To enable pattern developers to reduce the search space, each role in an EPL pattern can specify a domain which is an EOL expression that returns a collection of model elements from which the role will draw values. There are two types of domains in EPL: static domains which are computed once for all applications of the pattern, and which are not dependent on the bindings of other roles of the pattern (denoted using the in keyword in terms of the concrete syntax), and dynamic domains which are recomputed every time the candidate values of the role are iterated, and which are dependent on the bindings of other roles (denoted using the from keyword). Beyond a domain, each role can also specify a guard expression that further prunes unnecessary evaluations of the match condition. Using dynamic domains and guards, the PublicField pattern can be expressed in a more efficient way, as illustrated below. To further illustrate the difference between dynamic and static domains, changing from to in in line 4 would trigger a runtime exception as the domain would become static and therefore not able to access bindings of other roles (i.e. class ). pattern PublicField class : ClassDeclaration, field : FieldDeclaration from: class.bodyDeclarations, setter : MethodDeclaration from: class.bodyDeclarations guard: setter.name = \"set\" + field.getName(), getter : MethodDeclaration from: class.bodyDeclarations guard : (getter.name = \"get\" + field.getName() or getter.name = \"is\" + field.getName()) { } The implementation above is significantly more efficient than the previous implementation but can still be improved by further reducing the number of name comparisons of candidate setter and getter methods. To achieve this we can employ memoisation: we create a hash map of method names and methods once before pattern matching (line 2), and use it to identify candidate setters and getters (lines 9 and 12-13). pre { var methodMap = MethodDeclaration.all.mapBy(m|m.name); } pattern PublicField class : ClassDeclaration, field : FieldDeclaration from: class.bodyDeclarations, setter : MethodDeclaration from: getMethods(\"set\" + field.getName()) guard: setter.abstractTypeDeclaration = class, getter : MethodDeclaration from: getMethods(\"get\" + field.getName()) .includingAll(getMethods(\"is\" + field.getName())), guard: getter.abstractTypeDeclaration = class { } operation getMethods(name : String) : Sequence(MethodDeclaration) { var methods = methodMap.get(name); if (methods.isDefined()) return methods; else return new Sequence; } The sections below discuss the remainder of the syntax of EPL. Negative Roles \u00b6 Pattern roles can be negated using the no keyword. For instance, by adding the no keyword before the setter role in line 8 of the listing above, the pattern will match fields that have getters but no setters (i.e. read-only fields). Optional and Active Roles \u00b6 Pattern roles can be designated as optional using the optional EOL expression. For example, adding optional: true to the setter role would also match all fields that only have a getter. By adding optional: true to the setter role and optional: setter.isDefined() to the getter role, the pattern would match fields that have at least a setter or a getter. Roles can be completely deactivated depending on the bindings of other roles through the active construct. For example, if the pattern developer prefers to specify separate roles for getX and isX getters, with a preference over getX getters, the pattern can be formulated as illustrated in the listing below so that if a getX getter is found, no attempt is even made to match an isX getter. pattern PublicField class : ClassDeclaration, field : FieldDeclaration ..., setter : MethodDeclaration ..., getGetter : MethodDeclaration ..., isGetter: MethodDeclaration ... active: getGetter.isUndefined() { } Role Cardinality \u00b6 The cardinality of a role (lower and upper bound) can be defined in square brackets following the type of the role. Roles that have a cardinality with an upper bound > 1 are bound to the subset of elements from the domain of the role which also satisfy the guard, if the size of that subset is within the bounds of the role's cardinality. The listing below demonstrates the ClassAndPrivateFields pattern that detects instances of classes and all their private fields. If the cardinality of the field role in line 3 was [1..3] instead of [*], the pattern would only detect classes that own 1 to 3 private fields. pattern ClassAndPrivateFields class : ClassDeclaration, field : FieldDeclaration[*] from: class.bodyDeclarations guard: field.getVisibility() = VisibilityKind#private { onmatch { var message : String; message = class.name + \" matches\"; message.println(); } do { // More actions here } nomatch : (class.name + \" does not match\").println() } operation FieldDeclaration getVisibility() { if (self.modifier.isDefined()) { return self.modifier.visibility; } else { return null; } } Execution Semantics \u00b6 When an EPL module is executed, all of its pre statement blocks are first executed in order to define and initialise any global variables needed (e.g. the methodMap variable in the listing above or to print diagnostic messages to the user. Subsequently, patterns are executed in the order in which they appear. For each pattern, all combinations that conform to the type and constraints of the roles of the pattern are iterated, and the validity of each combination is evaluated in the match statement block of the pattern. In the absence of a match block, every combination that satisfies the constraints of the roles of the pattern is accepted as a valid instance of the pattern. Immediately after every successful match, the optional onmatch statement block of the pattern is invoked (see lines 7-11 of the listing above) and after every unsuccessful matching attempt, for combinations which however satisfy the constraints specified by the roles of the pattern, the optional nomatch statement block of the pattern (line 17) is executed . When matching of all patterns is complete, the do part (line 13) of each successful match is executed. In the do part, developers can modify the involved models (e.g to perform in-place transformation), without the risk of concurrent list modification errors (which can occur if elements are created/deleted during pattern matching). After pattern matching has been completed, the post statement blocks of the module are executed in order to perform any necessary finalisation actions. An EPL module can be executed in a one-off or iterative mode. In the one-off mode, patterns are only evaluated once, while in the iterative mode, the process is repeated until no more matches have been found or until the maximum number of iterations (specified by the developer) has been reached. The iterative mode is particularly suitable for patterns that perform reduction of the models they are evaluated against. Pattern Matching Output \u00b6 The output of the execution of an EPL module on a set of models is a collection of matches encapsulated in a PatternMatchModel , as illustrated in the figure below. As PatternMatchModel implements the IModel EMC interface, its instances can be accessed from other programs expressed in languages of the Epsilon family. classDiagram class Match { +bindings: Map<String, Object> } IModel --|> PatternMatchModel PatternMatchModel -- Pattern: patterns * PatternMatchModel -- Match: matches * A PatternMatchModel introduces one model element type for each pattern and one type for each field of each pattern (the name of these types are derived by concatenating the name of the pattern with a camel-case version of the name of the field). Instances of the prior are the matches of the pattern while instances of the latter are elements that have been matched in this particular role. For example, after executing the EPL module above, the produced PatternMatchModel contains 5 types: PublicField , instances of which are all the identified matches of the PublicField pattern, PublicFieldClass , instances of which are all the classes in the input model which have been matched to the class role in instances of the PublicField pattern, and similarly PublicFieldField , PublicFieldSetter and PublicFieldGetter . Interoperability with Other Model Management Tasks \u00b6 As a PatternMatchModel is an instance of IModel , after its computation it can be manipulated by other Epsilon programs. For example, the listing below demonstrates running the EPL module and passing its output to the EVL constraints that follow and, if validation is successful, to an ETL transformation where it is used to guide the generation of a UML model. In lines 4-7, the Java model is loaded and is assigned the name Java . Then, in line 9, the Java model is passed on to publicfield.epl for pattern matching. The result of pattern matching, which is an instance of the PatternMatchModel class (and therefore also an instance of IModel ) is exported to the global context under the name Patterns . Then, in line 13, both the Patterns and the Java models are passed on to the EVL model validation task which performs validation of the identified pattern matches. <project default= \"main\" > <target name= \"main\" > <epsilon.emf.loadModel name= \"Java\" modelfile= \"org.eclipse.epsilon.eol.engine_java.xmi\" metamodeluri= \"...MoDisco/Java/0.2.incubation/java\" read= \"true\" store= \"false\" /> <epsilon.epl src= \"publicfield.epl\" exportAs= \"Patterns\" > <model ref= \"Java\" /> </epsilon.epl> <epsilon.evl src= \"constraints.evl\" > <model ref= \"Patterns\" /> <model ref= \"Java\" /> </epsilon.evl> <epsilon.etl src= \"java2uml.etl\" > <model ref= \"Patterns\" /> <model ref= \"Java\" /> </epsilon.etl> </target> </project> Line 1 below defines a set of constraints that will be applied to instances of the PublicField type from the Patterns model. As discussed above, these are all matched instances of the PublicField pattern. Line 4, specifies the condition that needs to be satisfied by instances of the pattern. Notice the self.getter and self.field expressions which return the MethodDeclaration and FieldDeclaration bound to the instance of the pattern. Then, line 5 defines the message that should be produced for instances of PublicField that do not satisfy this constraint. context Patterns!PublicField { guard: self.field.type.isDefined() constraint GetterAndFieldSameType { check : self.getter.returnType.type = self.field.type.type message : \"The getter of \" + self.class.name + \".\" + self.field.fragments.at(0).name + \" does not have the same type as the field itself\" } } If validation is successful, both the Java and the Patterns model are passed on to an ETL transformation that transforms the Java model to a UML model, a fragment of which is presented below. The transformation encodes <field, setter, getter> triplets in the Java model as public properties in the UML model. As such, in line 6 of the transformation, the Patterns model is used to check whether field s has been matched under the PublicField pattern, and if so, the next line ignores the field's declared visibility and sets the visibility of the respective UML property to public . rule FieldDeclaration2Property transform s: Java!FieldDeclaration to t: Uml!Property { t.name = s.getName(); if (s.instanceOf(Patterns!PublicFieldField)) { t.visibility = Uml!VisibilityKind#public; } else { t.visibility = s.toUmlVisibility(); } ... } As Epsilon provides ANT tasks for all its languages, the same technique can be used to pass the result of pattern matching on to model-to-text transformations, as well as model comparison and model merging programs. To maintain the running example simple and concise, the pattern does not check aspects such as matching/compatible parameter/return types in the field, setter and getter but the reader should easily be able to envision how this would be supported through additional clauses in the match condition. \u21a9","title":"Pattern Matching (EPL)"},{"location":"doc/epl/#the-epsilon-pattern-language-epl","text":"The aim of EPL is to contribute pattern matching capabilities to Epsilon. This chapter discusses the abstract and concrete syntax of EPL as well as its execution semantics. To aid understanding, the discussion of the syntax and the semantics of the language revolves around an exemplar pattern which is developed incrementally throughout the chapter. The exemplar pattern is matched against models extracted from Java source code using tooling provided by the MoDisco project. MoDisco is an Eclipse project that provides a fine-grained Ecore-based metamodel of the Java language as well as tooling for extracting models that conform to this Java metamodel from Java source code. A simplified view of the relevant part of the MoDisco Java metamodel used in this running example is presented below. The aim of the pattern developed here (which we will call PublicField ) is to identify quartets of <ClassDeclaration, FieldDeclaration, MethodDeclaration, MethodDeclaration> , each representing a field of a Java class for which appropriately named accessor/getter (getX/isX) and mutator/setter (setX) methods are defined by the class. classDiagram class ClassDeclaration { +name: String +bodyDeclarations: BodyDeclaration[*] } class BodyDeclaration { +name: String +modifiers: Modifier[*] } class VariableDeclarationFragment { +name: String } class FieldDeclaration { +fragments: VariableDeclarationFragment[*] +type: TypeAccess } class MethodDeclaration { +returnType: TypeAccess } class VariableDeclarationFragment { +name: String } class Modifier { +visibility: VisibilityKind } class VisibilityKind { #none #public #protected #private } ClassDeclaration -- BodyDeclaration: bodyDeclarations * BodyDeclaration -- Modifier: modifiers * Modifier -- VisibilityKind: visibility BodyDeclaration <|-- FieldDeclaration MethodDeclaration --|> BodyDeclaration FieldDeclaration -- VariableDeclarationFragment: fragments * FieldDeclaration -- TypeAccess: type MethodDeclaration -- TypeAccess: returnType","title":"The Epsilon Pattern Language (EPL)"},{"location":"doc/epl/#syntax","text":"The syntax of EPL is an extension of the syntax of the EOL language , which is the core language of Epsilon. As such, any references to expression and statement block in this chapter, refer to EOL expressions and blocks of EOL statements respectively. It is also worth noting that EOL expressions and statements can produce side-effects on models, and therefore, it is the responsibility of the developer to decide which expressions used in the context of EPL patterns should be side-effect free and which not. As illustrated in the figure below, EPL patterns are organised in modules . Each module contains a number of named patterns and optionally, pre and post statement blocks that are executed before and after the pattern matching process, and helper EOL operations. EPL modules can import other EPL and EOL modules to facilitate reuse and modularity. classDiagram class EplModule { -iterative: Boolean -maxLoops: Integer } class Pattern { -name: String -match: ExecutableBlock<Boolean> -onMatch: ExecutableBlock<Void> -noMatch: ExecutableBlock<Void> -do: ExecutableBlock<Void> } class Role { -names: String[1..*] -negative: Boolean -type: EolType -guard: ExecutableBlock<Boolean> -active: ExecutableBlock<Boolean> -optional: ExecutableBlock<Boolean> } class Cardinality { -lowerBound: Integer -upperBound: Integer } EolModule <|-- ErlModule ErlModule <|-- EplModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EplModule -- Pattern: patterns * Pattern -- Role: roles * Role -- Domain: domain Domain <|-- StaticDomain Domain <|-- DynamicDomain Role -- Cardinality: cardinality In its simplest form a pattern consists of a number of named and typed roles and a match condition. For example, in lines 2-3, the PublicField pattern below, defines four roles ( class , field , setter and getter ). The match condition of the pattern specifies that for a quartet to be a valid match, the field, setter and getter must all belong to the class (lines 5-7, and that the setter and getter methods must be appropriately named 1 . pattern PublicField class : ClassDeclaration, field : FieldDeclaration, setter : MethodDeclaration, getter : MethodDeclaration { match : class.bodyDeclarations.includes(field) class.bodyDeclarations.includes(setter) and class.bodyDeclarations.includes(getter) and setter.name = \"set\" + field.getName() and (getter.name = \"get\" + field.getName() or getter.name = \"is\" + field.getName()) } @cached operation FieldDeclaration getName() { return self.fragments.at(0).name.firstToUpperCase(); } The implementation of the PublicField pattern above is fully functional but not particularly efficient as the match condition needs to be evaluated #ClassDefinition * #FieldDeclaration * #MethodDeclaration^2 times. To enable pattern developers to reduce the search space, each role in an EPL pattern can specify a domain which is an EOL expression that returns a collection of model elements from which the role will draw values. There are two types of domains in EPL: static domains which are computed once for all applications of the pattern, and which are not dependent on the bindings of other roles of the pattern (denoted using the in keyword in terms of the concrete syntax), and dynamic domains which are recomputed every time the candidate values of the role are iterated, and which are dependent on the bindings of other roles (denoted using the from keyword). Beyond a domain, each role can also specify a guard expression that further prunes unnecessary evaluations of the match condition. Using dynamic domains and guards, the PublicField pattern can be expressed in a more efficient way, as illustrated below. To further illustrate the difference between dynamic and static domains, changing from to in in line 4 would trigger a runtime exception as the domain would become static and therefore not able to access bindings of other roles (i.e. class ). pattern PublicField class : ClassDeclaration, field : FieldDeclaration from: class.bodyDeclarations, setter : MethodDeclaration from: class.bodyDeclarations guard: setter.name = \"set\" + field.getName(), getter : MethodDeclaration from: class.bodyDeclarations guard : (getter.name = \"get\" + field.getName() or getter.name = \"is\" + field.getName()) { } The implementation above is significantly more efficient than the previous implementation but can still be improved by further reducing the number of name comparisons of candidate setter and getter methods. To achieve this we can employ memoisation: we create a hash map of method names and methods once before pattern matching (line 2), and use it to identify candidate setters and getters (lines 9 and 12-13). pre { var methodMap = MethodDeclaration.all.mapBy(m|m.name); } pattern PublicField class : ClassDeclaration, field : FieldDeclaration from: class.bodyDeclarations, setter : MethodDeclaration from: getMethods(\"set\" + field.getName()) guard: setter.abstractTypeDeclaration = class, getter : MethodDeclaration from: getMethods(\"get\" + field.getName()) .includingAll(getMethods(\"is\" + field.getName())), guard: getter.abstractTypeDeclaration = class { } operation getMethods(name : String) : Sequence(MethodDeclaration) { var methods = methodMap.get(name); if (methods.isDefined()) return methods; else return new Sequence; } The sections below discuss the remainder of the syntax of EPL.","title":"Syntax"},{"location":"doc/epl/#negative-roles","text":"Pattern roles can be negated using the no keyword. For instance, by adding the no keyword before the setter role in line 8 of the listing above, the pattern will match fields that have getters but no setters (i.e. read-only fields).","title":"Negative Roles"},{"location":"doc/epl/#optional-and-active-roles","text":"Pattern roles can be designated as optional using the optional EOL expression. For example, adding optional: true to the setter role would also match all fields that only have a getter. By adding optional: true to the setter role and optional: setter.isDefined() to the getter role, the pattern would match fields that have at least a setter or a getter. Roles can be completely deactivated depending on the bindings of other roles through the active construct. For example, if the pattern developer prefers to specify separate roles for getX and isX getters, with a preference over getX getters, the pattern can be formulated as illustrated in the listing below so that if a getX getter is found, no attempt is even made to match an isX getter. pattern PublicField class : ClassDeclaration, field : FieldDeclaration ..., setter : MethodDeclaration ..., getGetter : MethodDeclaration ..., isGetter: MethodDeclaration ... active: getGetter.isUndefined() { }","title":"Optional and Active Roles"},{"location":"doc/epl/#role-cardinality","text":"The cardinality of a role (lower and upper bound) can be defined in square brackets following the type of the role. Roles that have a cardinality with an upper bound > 1 are bound to the subset of elements from the domain of the role which also satisfy the guard, if the size of that subset is within the bounds of the role's cardinality. The listing below demonstrates the ClassAndPrivateFields pattern that detects instances of classes and all their private fields. If the cardinality of the field role in line 3 was [1..3] instead of [*], the pattern would only detect classes that own 1 to 3 private fields. pattern ClassAndPrivateFields class : ClassDeclaration, field : FieldDeclaration[*] from: class.bodyDeclarations guard: field.getVisibility() = VisibilityKind#private { onmatch { var message : String; message = class.name + \" matches\"; message.println(); } do { // More actions here } nomatch : (class.name + \" does not match\").println() } operation FieldDeclaration getVisibility() { if (self.modifier.isDefined()) { return self.modifier.visibility; } else { return null; } }","title":"Role Cardinality"},{"location":"doc/epl/#execution-semantics","text":"When an EPL module is executed, all of its pre statement blocks are first executed in order to define and initialise any global variables needed (e.g. the methodMap variable in the listing above or to print diagnostic messages to the user. Subsequently, patterns are executed in the order in which they appear. For each pattern, all combinations that conform to the type and constraints of the roles of the pattern are iterated, and the validity of each combination is evaluated in the match statement block of the pattern. In the absence of a match block, every combination that satisfies the constraints of the roles of the pattern is accepted as a valid instance of the pattern. Immediately after every successful match, the optional onmatch statement block of the pattern is invoked (see lines 7-11 of the listing above) and after every unsuccessful matching attempt, for combinations which however satisfy the constraints specified by the roles of the pattern, the optional nomatch statement block of the pattern (line 17) is executed . When matching of all patterns is complete, the do part (line 13) of each successful match is executed. In the do part, developers can modify the involved models (e.g to perform in-place transformation), without the risk of concurrent list modification errors (which can occur if elements are created/deleted during pattern matching). After pattern matching has been completed, the post statement blocks of the module are executed in order to perform any necessary finalisation actions. An EPL module can be executed in a one-off or iterative mode. In the one-off mode, patterns are only evaluated once, while in the iterative mode, the process is repeated until no more matches have been found or until the maximum number of iterations (specified by the developer) has been reached. The iterative mode is particularly suitable for patterns that perform reduction of the models they are evaluated against.","title":"Execution Semantics"},{"location":"doc/epl/#pattern-matching-output","text":"The output of the execution of an EPL module on a set of models is a collection of matches encapsulated in a PatternMatchModel , as illustrated in the figure below. As PatternMatchModel implements the IModel EMC interface, its instances can be accessed from other programs expressed in languages of the Epsilon family. classDiagram class Match { +bindings: Map<String, Object> } IModel --|> PatternMatchModel PatternMatchModel -- Pattern: patterns * PatternMatchModel -- Match: matches * A PatternMatchModel introduces one model element type for each pattern and one type for each field of each pattern (the name of these types are derived by concatenating the name of the pattern with a camel-case version of the name of the field). Instances of the prior are the matches of the pattern while instances of the latter are elements that have been matched in this particular role. For example, after executing the EPL module above, the produced PatternMatchModel contains 5 types: PublicField , instances of which are all the identified matches of the PublicField pattern, PublicFieldClass , instances of which are all the classes in the input model which have been matched to the class role in instances of the PublicField pattern, and similarly PublicFieldField , PublicFieldSetter and PublicFieldGetter .","title":"Pattern Matching Output"},{"location":"doc/epl/#interoperability-with-other-model-management-tasks","text":"As a PatternMatchModel is an instance of IModel , after its computation it can be manipulated by other Epsilon programs. For example, the listing below demonstrates running the EPL module and passing its output to the EVL constraints that follow and, if validation is successful, to an ETL transformation where it is used to guide the generation of a UML model. In lines 4-7, the Java model is loaded and is assigned the name Java . Then, in line 9, the Java model is passed on to publicfield.epl for pattern matching. The result of pattern matching, which is an instance of the PatternMatchModel class (and therefore also an instance of IModel ) is exported to the global context under the name Patterns . Then, in line 13, both the Patterns and the Java models are passed on to the EVL model validation task which performs validation of the identified pattern matches. <project default= \"main\" > <target name= \"main\" > <epsilon.emf.loadModel name= \"Java\" modelfile= \"org.eclipse.epsilon.eol.engine_java.xmi\" metamodeluri= \"...MoDisco/Java/0.2.incubation/java\" read= \"true\" store= \"false\" /> <epsilon.epl src= \"publicfield.epl\" exportAs= \"Patterns\" > <model ref= \"Java\" /> </epsilon.epl> <epsilon.evl src= \"constraints.evl\" > <model ref= \"Patterns\" /> <model ref= \"Java\" /> </epsilon.evl> <epsilon.etl src= \"java2uml.etl\" > <model ref= \"Patterns\" /> <model ref= \"Java\" /> </epsilon.etl> </target> </project> Line 1 below defines a set of constraints that will be applied to instances of the PublicField type from the Patterns model. As discussed above, these are all matched instances of the PublicField pattern. Line 4, specifies the condition that needs to be satisfied by instances of the pattern. Notice the self.getter and self.field expressions which return the MethodDeclaration and FieldDeclaration bound to the instance of the pattern. Then, line 5 defines the message that should be produced for instances of PublicField that do not satisfy this constraint. context Patterns!PublicField { guard: self.field.type.isDefined() constraint GetterAndFieldSameType { check : self.getter.returnType.type = self.field.type.type message : \"The getter of \" + self.class.name + \".\" + self.field.fragments.at(0).name + \" does not have the same type as the field itself\" } } If validation is successful, both the Java and the Patterns model are passed on to an ETL transformation that transforms the Java model to a UML model, a fragment of which is presented below. The transformation encodes <field, setter, getter> triplets in the Java model as public properties in the UML model. As such, in line 6 of the transformation, the Patterns model is used to check whether field s has been matched under the PublicField pattern, and if so, the next line ignores the field's declared visibility and sets the visibility of the respective UML property to public . rule FieldDeclaration2Property transform s: Java!FieldDeclaration to t: Uml!Property { t.name = s.getName(); if (s.instanceOf(Patterns!PublicFieldField)) { t.visibility = Uml!VisibilityKind#public; } else { t.visibility = s.toUmlVisibility(); } ... } As Epsilon provides ANT tasks for all its languages, the same technique can be used to pass the result of pattern matching on to model-to-text transformations, as well as model comparison and model merging programs. To maintain the running example simple and concise, the pattern does not check aspects such as matching/compatible parameter/return types in the field, setter and getter but the reader should easily be able to envision how this would be supported through additional clauses in the match condition. \u21a9","title":"Interoperability with Other Model Management Tasks"},{"location":"doc/etl/","text":"The Epsilon Transformation Language (ETL) \u00b6 The aim of ETL is to contribute model-to-model transformation capabilities to Epsilon. More specifically, ETL can be used to transform an arbitrary number of input models into an arbitrary number of output models of different modelling languages and technologies in a rule-based and modular manner. Try ETL online You can run and fiddle with an ETL transformation that transforms a tree model to a graph model in the online Epsilon Playground . Abstract Syntax \u00b6 As illustrated in the figure below, ETL transformations are organized in modules ( EtlModule ). A module can contain a number of transformation rules ( TransformRule ). Each rule has a unique name (in the context of the module) and also specifies one source and many target parameters. A transformation rule can also extend a number of other transformation rules and be declared as abstract , primary and/or lazy 1 . To limit its applicability to a subset of elements that conform to the type of the source parameter, a rule can optionally define a guard which is either an EOL expression or a block of EOL statements. Finally, each rule defines a block of EOL statements ( body ) where the logic for populating the property values of the target model elements is specified. Besides transformation rules, an ETL module can also optionally contain a number of pre and post named blocks of EOL statements which, as discussed later, are executed before and after the transformation rules respectively. These should not be confused with the pre-/post-condition annotations available for EOL user-defined operations. classDiagram class TransformRule { -name: String -abstract: Boolean -lazy: Boolean -primary: Boolean -greedy: Boolean -type: EolModelElementType -guard: ExecutableBlock<Boolean> -body: ExecutableBlock<Void> } class Parameter { -name: String -type: EolType } class NamedStatementBlockRule { -name: String -body: StatementBlock } EolModule <|-- ErlModule EtlModule --|> ErlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EtlModule -- TransformRule: rules * TransformRule -- Parameter: source TransformRule -- Parameter: targets * TransformRule -- TransformRule: extends * Concrete Syntax \u00b6 The concrete syntax of a transformation rule is displayed in the listing below. The optional abstract , lazy and primary attributes of the rule are specified using respective annotations. The name of the rule follows the rule keyword and the source and target parameters are defined after the transform and to keywords. Also, the rule can define an optional comma-separated list of rules it extends after the extends keyword. Inside the curly braces ({}), the rule can optionally specify its guard either as an EOL expression following a colon (:) (for simple guards) or as a block of statements in curly braces (for more complex guards). Finally, the body of the rule is specified as a sequence of EOL statements. (@abstract)? (@lazy)? (@primary)? rule <name> transform <sourceParameterName>:<sourceParameterType> to <targetParameterName>:<targetParameterType> (,<targetParameterName>:<targetParameterType>)* (extends <ruleName> (, <ruleName>*)? { (guard (:expression)|({statementBlock}))? statement+ } Pre and post blocks have a simple syntax that, as presented the listing below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ } Execution Semantics \u00b6 Rule and Block Overriding \u00b6 Similarly to EOL, an ETL module can import a number of other ETL modules. In this case, the importing ETL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively. Rule Execution Scheduling \u00b6 When an ETL module is executed, the pre blocks of the module are executed first in the order in which they have been specified. Following that, each non-abstract and non-lazy rule is executed for all the elements on which it is applicable. To be applicable on a particular element, the element must have a type-of relationship with the type defined in the rule's sourceParameter (or a kind-of relationship if the rule is annotated as @greedy ) and must also satisfy the guard of the rule (and all the rules it extends). When a rule is executed on an applicable element, the target elements are initially created by instantiating the targetParameters of the rules, and then their contents are populated using the EOL statements of the body of the rule. Finally, when all rules have been executed, the post blocks of the module are executed in the order in which they have been declared. Source Elements Resolution \u00b6 Resolving target elements that have been (or can be) transformed from source elements by other rules is a frequent task in the body of a transformation rule. To automate this task and reduce coupling between rules, ETL contributes the equivalents() and equivalent() built-in operations that automatically resolve source elements to their transformed counterparts in the target models. When the equivalents() operation is applied on a single source element (as opposed to a collection of them), it inspects the established transformation trace (displayed in the figure below) and invokes the applicable rules (if necessary) to calculate the counterparts of the element in the target model. When applied to a collection it returns a Bag containing Bag s that in turn contain the counterparts of the source elements contained in the collection. The equivalents() operation can be also invoked with an arbitrary number of rule names as parameters to invoke and return only the equivalents created by specific rules. Unlike the main execution scheduling scheme discussed above, the equivalents() operation invokes both lazy and non-lazy rules. It is worth noting that lazy rules are computationally expensive and should be used with caution as they can significantly degrade the performance of the overall transformation. With regard to the ordering of the results of the equivalents() operations, the returned elements appear in the respective order of the rules that have created them. An exception to this occurs when one of the rules is declared as primary , in which case its results precede the results of all other rules. classDiagram class Transformation { -source: Object -targets: Object[*] } class ITransformationStrategy { +transformModels(context : EtlContext) } EolContext <|-- EtlContext EtlContext -- TransformationTrace EtlContext -- ITransformationStrategy: strategy TransformationTrace -- Transformation: transformations * Transformation -- TransformRule: rule ETL also provides the convenient equivalent() operation which, when applied to a single element, returns only the first element of the respective result that would have been returned by the equivalents() operation discussed above. Also, when applied to a collection the equivalent() operation returns a flattened collection (as opposed to the result of equivalents() which is a Bag of Bag s in this case). As with the equivalents() operation, the equivalent() operation can also be invoked with or without parameters. The semantics of the equivalent() operation is further illustrated through a simple example. In this example, we need to transform a model that conforms to the Tree metamodel displayed below into a model that conforms to the Graph metamodel, also displayed below. classDiagram class Node { +label: String +incoming: Edge[*] +outgoing: Edge[*] } class Edge { +source: Node +target: Node } class Tree { +name: String +parent: Tree +children: Tree[*] } Tree -- Tree Node -- Edge Edge -- Node More specifically, we need to transform each Tree element to a Node , and an Edge that connects it with the Node that is equivalent to the tree's parent . This is achieved using the rule below. rule Tree2Node transform t : Tree!Tree to n : Graph!Node { n.label = t.label; if (t.parent.isDefined()) { var edge = new Graph!Edge; edge.source = n; edge.target = t.parent.equivalent(); } } In lines 1--3, the Tree2Node rule specifies that it can transform elements of the Tree type in the Tree model into elements of the Node type in the Graph model. In line 5 it specifies that the label of the created Node should be the same as the label of the source Tree. If the parent of the source Tree is defined (line 7), the rule creates a new Edge (line 8) and sets its source property to the created Node (line 9) and its target property to the equivalent Node of the source Tree 's parent (line 10). Persisting the transformation trace \u00b6 ETL does not provide built-in support for persisting the transformation trace, however, you can access it through System.context.transformationTrace and persist (parts of) it in a format of your choice (e.g. in a post block of your transformation). Overriding the semantics of the EOL Special Assignment Operator \u00b6 As discussed above, resolving the equivalent(s) or source model elements in the target model is a recurring task in model transformation. Furthermore, in most cases resolving the equivalent of a model element is immediately followed by assigning/adding the obtained target model elements to the value(s) of a property of another target model element. For example, in line 10 of the listing above, the equivalent obtained is immediately assigned to the target property of the generated Edge . To make transformation specifications more readable, ETL overrides the semantics of the SpecialAssignmentStatement ( ::= in terms of concrete syntax), to set its left-hand side, not to the element its right-hand side evaluates to, but to its equivalent as calculated using the equivalent() operation discussed above. Using this feature, line 10 of the Tree2Node rule can be rewritten as shown below. edge.target ::= t.parent; Interactive Transformations \u00b6 Using the user interaction facilities of EOL, an ETL transformation can become interactive by prompting the user for input during its execution. For example in the listing below, we modify the Tree2Node rule by adding a guard part that uses the user-input facilities of EOL (more specifically the UserInput.confirm(String,Boolean) operation) to enable the user select manually at runtime which of the Tree elements need to be transformed to respective Node elements in the target model and which not. rule Tree2Node transform t : Tree!Tree to n : Graph!Node { guard : UserInput.confirm (\"Transform tree \" + t.label + \"?\", true) n.label = t.label; var target : Graph!Node ::= t.parent; if (target.isDefined()) { var edge = new Graph!Edge; edge.source = n; edge.target = target; } } Additional Resources \u00b6 Additional resources about ETL are available here . The concept of lazy rules was first introduced in ATL \u21a9","title":"Model Transformation (ETL)"},{"location":"doc/etl/#the-epsilon-transformation-language-etl","text":"The aim of ETL is to contribute model-to-model transformation capabilities to Epsilon. More specifically, ETL can be used to transform an arbitrary number of input models into an arbitrary number of output models of different modelling languages and technologies in a rule-based and modular manner. Try ETL online You can run and fiddle with an ETL transformation that transforms a tree model to a graph model in the online Epsilon Playground .","title":"The Epsilon Transformation Language (ETL)"},{"location":"doc/etl/#abstract-syntax","text":"As illustrated in the figure below, ETL transformations are organized in modules ( EtlModule ). A module can contain a number of transformation rules ( TransformRule ). Each rule has a unique name (in the context of the module) and also specifies one source and many target parameters. A transformation rule can also extend a number of other transformation rules and be declared as abstract , primary and/or lazy 1 . To limit its applicability to a subset of elements that conform to the type of the source parameter, a rule can optionally define a guard which is either an EOL expression or a block of EOL statements. Finally, each rule defines a block of EOL statements ( body ) where the logic for populating the property values of the target model elements is specified. Besides transformation rules, an ETL module can also optionally contain a number of pre and post named blocks of EOL statements which, as discussed later, are executed before and after the transformation rules respectively. These should not be confused with the pre-/post-condition annotations available for EOL user-defined operations. classDiagram class TransformRule { -name: String -abstract: Boolean -lazy: Boolean -primary: Boolean -greedy: Boolean -type: EolModelElementType -guard: ExecutableBlock<Boolean> -body: ExecutableBlock<Void> } class Parameter { -name: String -type: EolType } class NamedStatementBlockRule { -name: String -body: StatementBlock } EolModule <|-- ErlModule EtlModule --|> ErlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EtlModule -- TransformRule: rules * TransformRule -- Parameter: source TransformRule -- Parameter: targets * TransformRule -- TransformRule: extends *","title":"Abstract Syntax"},{"location":"doc/etl/#concrete-syntax","text":"The concrete syntax of a transformation rule is displayed in the listing below. The optional abstract , lazy and primary attributes of the rule are specified using respective annotations. The name of the rule follows the rule keyword and the source and target parameters are defined after the transform and to keywords. Also, the rule can define an optional comma-separated list of rules it extends after the extends keyword. Inside the curly braces ({}), the rule can optionally specify its guard either as an EOL expression following a colon (:) (for simple guards) or as a block of statements in curly braces (for more complex guards). Finally, the body of the rule is specified as a sequence of EOL statements. (@abstract)? (@lazy)? (@primary)? rule <name> transform <sourceParameterName>:<sourceParameterType> to <targetParameterName>:<targetParameterType> (,<targetParameterName>:<targetParameterType>)* (extends <ruleName> (, <ruleName>*)? { (guard (:expression)|({statementBlock}))? statement+ } Pre and post blocks have a simple syntax that, as presented the listing below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ }","title":"Concrete Syntax"},{"location":"doc/etl/#execution-semantics","text":"","title":"Execution Semantics"},{"location":"doc/etl/#rule-and-block-overriding","text":"Similarly to EOL, an ETL module can import a number of other ETL modules. In this case, the importing ETL module inherits all the rules and pre/post blocks specified in the modules it imports (recursively). If the module specifies a rule or a pre/post block with the same name, the local rule/block overrides the imported one respectively.","title":"Rule and Block Overriding"},{"location":"doc/etl/#rule-execution-scheduling","text":"When an ETL module is executed, the pre blocks of the module are executed first in the order in which they have been specified. Following that, each non-abstract and non-lazy rule is executed for all the elements on which it is applicable. To be applicable on a particular element, the element must have a type-of relationship with the type defined in the rule's sourceParameter (or a kind-of relationship if the rule is annotated as @greedy ) and must also satisfy the guard of the rule (and all the rules it extends). When a rule is executed on an applicable element, the target elements are initially created by instantiating the targetParameters of the rules, and then their contents are populated using the EOL statements of the body of the rule. Finally, when all rules have been executed, the post blocks of the module are executed in the order in which they have been declared.","title":"Rule Execution Scheduling"},{"location":"doc/etl/#source-elements-resolution","text":"Resolving target elements that have been (or can be) transformed from source elements by other rules is a frequent task in the body of a transformation rule. To automate this task and reduce coupling between rules, ETL contributes the equivalents() and equivalent() built-in operations that automatically resolve source elements to their transformed counterparts in the target models. When the equivalents() operation is applied on a single source element (as opposed to a collection of them), it inspects the established transformation trace (displayed in the figure below) and invokes the applicable rules (if necessary) to calculate the counterparts of the element in the target model. When applied to a collection it returns a Bag containing Bag s that in turn contain the counterparts of the source elements contained in the collection. The equivalents() operation can be also invoked with an arbitrary number of rule names as parameters to invoke and return only the equivalents created by specific rules. Unlike the main execution scheduling scheme discussed above, the equivalents() operation invokes both lazy and non-lazy rules. It is worth noting that lazy rules are computationally expensive and should be used with caution as they can significantly degrade the performance of the overall transformation. With regard to the ordering of the results of the equivalents() operations, the returned elements appear in the respective order of the rules that have created them. An exception to this occurs when one of the rules is declared as primary , in which case its results precede the results of all other rules. classDiagram class Transformation { -source: Object -targets: Object[*] } class ITransformationStrategy { +transformModels(context : EtlContext) } EolContext <|-- EtlContext EtlContext -- TransformationTrace EtlContext -- ITransformationStrategy: strategy TransformationTrace -- Transformation: transformations * Transformation -- TransformRule: rule ETL also provides the convenient equivalent() operation which, when applied to a single element, returns only the first element of the respective result that would have been returned by the equivalents() operation discussed above. Also, when applied to a collection the equivalent() operation returns a flattened collection (as opposed to the result of equivalents() which is a Bag of Bag s in this case). As with the equivalents() operation, the equivalent() operation can also be invoked with or without parameters. The semantics of the equivalent() operation is further illustrated through a simple example. In this example, we need to transform a model that conforms to the Tree metamodel displayed below into a model that conforms to the Graph metamodel, also displayed below. classDiagram class Node { +label: String +incoming: Edge[*] +outgoing: Edge[*] } class Edge { +source: Node +target: Node } class Tree { +name: String +parent: Tree +children: Tree[*] } Tree -- Tree Node -- Edge Edge -- Node More specifically, we need to transform each Tree element to a Node , and an Edge that connects it with the Node that is equivalent to the tree's parent . This is achieved using the rule below. rule Tree2Node transform t : Tree!Tree to n : Graph!Node { n.label = t.label; if (t.parent.isDefined()) { var edge = new Graph!Edge; edge.source = n; edge.target = t.parent.equivalent(); } } In lines 1--3, the Tree2Node rule specifies that it can transform elements of the Tree type in the Tree model into elements of the Node type in the Graph model. In line 5 it specifies that the label of the created Node should be the same as the label of the source Tree. If the parent of the source Tree is defined (line 7), the rule creates a new Edge (line 8) and sets its source property to the created Node (line 9) and its target property to the equivalent Node of the source Tree 's parent (line 10).","title":"Source Elements Resolution"},{"location":"doc/etl/#persisting-the-transformation-trace","text":"ETL does not provide built-in support for persisting the transformation trace, however, you can access it through System.context.transformationTrace and persist (parts of) it in a format of your choice (e.g. in a post block of your transformation).","title":"Persisting the transformation trace"},{"location":"doc/etl/#overriding-the-semantics-of-the-eol-special-assignment-operator","text":"As discussed above, resolving the equivalent(s) or source model elements in the target model is a recurring task in model transformation. Furthermore, in most cases resolving the equivalent of a model element is immediately followed by assigning/adding the obtained target model elements to the value(s) of a property of another target model element. For example, in line 10 of the listing above, the equivalent obtained is immediately assigned to the target property of the generated Edge . To make transformation specifications more readable, ETL overrides the semantics of the SpecialAssignmentStatement ( ::= in terms of concrete syntax), to set its left-hand side, not to the element its right-hand side evaluates to, but to its equivalent as calculated using the equivalent() operation discussed above. Using this feature, line 10 of the Tree2Node rule can be rewritten as shown below. edge.target ::= t.parent;","title":"Overriding the semantics of the EOL Special Assignment Operator"},{"location":"doc/etl/#interactive-transformations","text":"Using the user interaction facilities of EOL, an ETL transformation can become interactive by prompting the user for input during its execution. For example in the listing below, we modify the Tree2Node rule by adding a guard part that uses the user-input facilities of EOL (more specifically the UserInput.confirm(String,Boolean) operation) to enable the user select manually at runtime which of the Tree elements need to be transformed to respective Node elements in the target model and which not. rule Tree2Node transform t : Tree!Tree to n : Graph!Node { guard : UserInput.confirm (\"Transform tree \" + t.label + \"?\", true) n.label = t.label; var target : Graph!Node ::= t.parent; if (target.isDefined()) { var edge = new Graph!Edge; edge.source = n; edge.target = target; } }","title":"Interactive Transformations"},{"location":"doc/etl/#additional-resources","text":"Additional resources about ETL are available here . The concept of lazy rules was first introduced in ATL \u21a9","title":"Additional Resources"},{"location":"doc/eunit/","text":"The Epsilon Unit Testing Framework (EUnit) \u00b6 EUnit is an unit testing framework specifically designed to test model management tasks, based on EOL and the Ant workflow tasks. It provides assertions for comparing models, files and directories. Tests can be reused with different sets of models and input data, and differences between the expected and actual models can be graphically visualized. This chapter describes how tests are organized and written and shows two examples of how a model-to-model transformation can be tested with EUnit. This chapter ends with a discussion of how EUnit can be extended to support other modelling and model management technologies. Common Issues \u00b6 While each type of model management task does have specific complexity, below is a list of common concerns: There is usually a large number of models to be handled. Some may be created by hand, some may be generated using hand-written programs, and some may be generated automatically following certain coverage criteria. A single model or set of models may be used in several tasks. For instance, a model may be validated before performing an in-place transformation to assist the user, and later on it may be transformed to another model or merged with a different model. This requires having at least one test for each valid combination of models and sets of tasks. Test oracles are more complex than in traditional unit testing: instead of checking scalar values or simple lists, entire graphs of model objects or file trees may have to be compared. In some cases, complex properties in the generated artifacts may have to be checked. Models and model management tasks may use a wide range of technologies. Models may be based on Ecore, XML files or Java object graphs, among many others. At the same time, tasks may use technologies from different platforms, such as Epsilon, or AMMA. Many of these technologies offer high-level tools for running and debugging the different tasks using several models. However, users wishing to do automated unit testing need to learn low-level implementation details about their modelling and model management technologies. This increases the initial cost of testing these tasks and hampers the adoption of new technologies. Existing testing tools tend to focus on the testing technique itself, and lack integration with external systems. Some tools provide graphical user interfaces, but most do not generate reports which can be consumed by a continuous integration server, for instance. Testing with JUnit \u00b6 The previous issues are easier to understand with a concrete example. This section shows how a simple transformation between two EMF models in ETL using JUnit 4 would be normally tested, and points out several issues due to JUnit's limitations as a general-purpose unit testing framework for Java programs. For the sake of brevity, only an outline of the JUnit test suite is included. All JUnit test suites are defined as Java classes. This test suite has three methods: The test setup method (marked with the @Before JUnit annotation) loads the required models by creating and configuring instances of EmfModel . After that, it prepares the transformation by creating and configuring an instance of EtlModule , adding the input and output models to its model repository. The test case itself (marked with @Test ) runs the ETL transformation and uses the generic comparison algorithm implemented by EMF Compare to perform the model comparison. The test teardown method (marked with @After ) disposes of the models. Several issues can be identified in each part of the test suite. First, test setup is tightly bound to the technologies used: it depends on the API of the EmfModel and EtlModule classes, which are both part of Epsilon. Later refactorings in these classes may break existing tests. The test case can only be used for a single combination of input and output models. Testing several combinations requires either repeating the same code and therefore making the suite less maintainable, or using parametric testing, which may be wasteful if not all tests need the same combinations of models. Model comparison requires the user to manually select a model comparison engine and integrate it with the test. For comparing EMF models, EMF Compare is easy to use and readily available. However, generic model comparison engines may not be available for some modelling technologies, or may be harder to integrate. Finally, instead of comparing the obtained and expected models, several properties could have been checked in the obtained model. However, querying models through Java code can be quite verbose. Selected Approach \u00b6 Several approaches could be followed to address these issues. Our first instinct would be to extend JUnit and reuse all the tooling available for it. A custom test runner would simplify setup and teardown, and modelling platforms would integrate their technologies into it. Since Java is very verbose when querying models, the custom runner should run tests in a higher-level language, such as EOL. However, JUnit is very tightly coupled to Java, and this would impose limits on the level of integration we could obtain. For instance, errors in the model management tasks or the EOL tests could not be reported from their original source, but rather from the Java code which invoked them. Another problem with this approach is that new integration code would need to be written for each of the existing platforms. Alternatively, we could add a new language exclusively dedicated to testing to the Epsilon family. Being based on EOL, model querying would be very concise, and with a test runner written from scratch, test execution would be very flexible. However, this would still require all platforms to write new code to integrate with it, and this code would be tightly coupled to Epsilon. As a middle ground, we could decorate EOL to guide its execution through a new test runner, while reusing the Apache Ant tasks already provided by several of the existing platforms, such as AMMA or Epsilon. Like Make, Ant is a tool focused on automating the execution of processes such as program builds. Unlike Make, Ant defines processes using XML buildfiles with sets of interrelated targets . Each target contains in turn a sequence of tasks . Many Ant tasks and Ant-based tools already exist, and it is easy to create a new Ant task. Among these three approaches, EUnit follows the last one. Ant tasks take care of model setup and management, and tests are written in EOL and executed by a new test runner, written from the ground up. Test Organization \u00b6 EUnit has a rich data model: test suites are organized as trees of tests, and each test is divided into many parts which can be extended by the user. This section is dedicated to describing how test suites and tests are organized. The next section indicates how they are written. Test Suites \u00b6 EUnit test suites are organized as trees: inner nodes group related test cases and define data bindings. Leaf nodes define model bindings and run the test cases. Data bindings repeat all test cases with different values in one or more variables. They can implement parametric testing, as in JUnit 4. EUnit can nest several data bindings, running all test cases once for each combination. Model bindings are specific to EUnit: they allow developers to repeat a single test case with different subsets of models. Data and model bindings can be combined. One interesting approach is to set the names of the models to be used in the model binding from the data binding, as a quick way to try several test cases with the same subsets of models. The figure below shows an example of an EUnit test tree: nodes with data bindings are marked with data , and nodes with model bindings are marked with model . graph TD data1[data<br/>x=1] data2[data<br/>x=2] testa1[test A] testb1[test B] testa2[test A] testb2[test B] modelx1[model X] modely1[model Y] modelx2[model X] modely2[model Y] root --> data1 root --> data2 data1 --> testa1 data1 --> testb1 data2 --> testa2 data2 --> testb2 testa1 --> modelx1 testa1 --> modely1 testa2 --> modelx2 testa2 --> modely2 EUnit will perform a preorder traversal of this tree, running the following tests: A with x = 1 and model X. A with x = 1 and model Y. B with x = 1 and both models. A with x = 2 and model X. A with x = 2 and model Y. B with x = 2 and both models. Optionally, EUnit can filter tests by name, running only A or B . Similarly to JUnit, EUnit logs start and finish times for each node in the tree, so the most expensive test cases can be quickly detected. However, EUnit logs CPU time 1 in addition to the usual wallclock time. Parametric testing is not to be confused with theories : both repeat a test case with different values, but results are reported quite differently. While parametric testing produces separate test cases with independent results, theories produce aggregated tests which only pass if the original test case passes for every data point. The figures below illustrate these differences. EUnit does not support theories yet: however, they can be approximated with data bindings. graph TD data1[data 1] data2[data 2] testa1[test 1] testb1[test 2] testa2[test 1] testb2[test 2] root --> data1 root --> data2 data1 --> testa1 data1 --> testb1 data2 --> testa2 data2 --> testb2 Parametric Testing graph TD data1[test 1] data2[test 2] testa1[data 1] testb1[data 2] testa2[data 1] testb2[data 2] root --> data1 root --> data2 data1 --> testa1 data1 --> testb1 data2 --> testa2 data2 --> testb2 Theories Test Cases \u00b6 The execution of a test case is divided into the following steps: Apply the data bindings of its ancestors. Run the model setup sections defined by the user. Apply the model bindings of this node. Run the regular setup sections defined by the user. Run the test case itself. Run the teardown sections defined by the user. Tear down the data bindings and models for this test. An important difference between JUnit and EUnit is that setup is split into two parts: model setup and regular setup. This split allows users to add code before and after model bindings are applied. Normally, the model setup sections will load all the models needed by the test suite, and the regular setup sections will further prepare the models selected by the model binding. Explicit teardown sections are usually not needed, as models are disposed automatically by EUnit. EUnit includes them for consistency with the xUnit frameworks. Due to its focus on model management, model setup in EUnit is very flexible. Developers can combine several ways to set up models, such as model references, individual Apache Ant tasks, Apache Ant targets or Human-Usable Text Notation (HUTN) fragments. A test case may produce one among several results. SUCCESS is obtained if all assertions passed and no exceptions were thrown. FAILURE is obtained if an assertion failed. ERROR is obtained if an unexpected exception was thrown while running the test. Finally, tests may be SKIPPED by the user. Test Specification \u00b6 In the previous section, we described how test suites and test cases are organized. In this section, we will show how to write them. As discussed before, after evaluating several approaches, we decided to combine the expressive power of EOL and the extensibility of Apache Ant. For this reason, EUnit test suites are split into two files: an Ant buildfile and an EOL script with some special-purpose annotations. The next subsections describe the contents of these two files and revisit the previous example with EUnit. Ant Buildfile \u00b6 EUnit uses standard Ant buildfiles: running EUnit is as simple as using its Ant task. Users may run EUnit more than once in a single Ant launch: the graphical user interface will automatically aggregate the results of all test suites. EUnit Invocations \u00b6 An example invocation of the EUnit Ant task using the most common features is shown in the listing below. Users will normally only use some of these features at a time, though. Optional attributes have been listed between brackets. Some nested elements can be repeated 0+ times ( * ) or 0-1 times ( ? ). Valid alternatives for an attribute are separated with | . <epsilon.eunit src= \"...\" [ failOnErrors= \"...\" ] [ package= \"..\" ] [ toDir= \"...\" ] [ report= \"yes|no\" ] [ saveModelDeltas= \"yes|no\" ] > ( <model ref= \"OldName\" [ as= \"NewName\" ] /> )* ( <uses ref= \"x\" [ as= \"y\" ] /> )* ( <exports ref= \"z\" [ as= \"w\" ] /> )* ( <parameter name= \"myparam\" value= \"myvalue\" /> )* ( <modelTasks> <!-- Zero or more Ant tasks --> </modelTasks> )? </epsilon.eunit> The EUnit Ant task is based on the Epsilon abstract executable module task, inheriting some useful features. The attribute src points to the path of the EOL file, and the optional attribute failOnErrors can be set to false to prevent EUnit from aborting the Ant launch if a test case fails. EUnit also inherits support for importing and exporting global variables through the <uses> and <exports> elements: the original name is set in ref , and the optional as attribute allows for using a different name. For receiving parameters as name-value piars, the <parameter> element can be used. Model references (using the <model> nested element) are also inherited from the Epsilon abstract executable module task. These allow model management tasks to refer by name to models previously loaded in the Ant buildfile. However, EUnit implicitly reloads the models after each test case. This ensures that test cases are isolated from each other. The optional <modelTasks> nested element contains a sequence of Ant tasks which will be run after reloading the model references and before running the model setup sections in the EOL file. This allows users to run workflows more advanced than simply reloading model references. The EUnit Ant task adds several new features to customize the test result reports and perform more advanced model setup. By default, EUnit generates reports in the XML format of the Ant <junit> task. This format is also used by many other tools, such as the TestNG unit testing framework, the Jenkins continuous integration server or the JUnit Eclipse plug-ins. To suppress these reports, report must be set to no. By default, the XML report is generated in the same directory as the Ant buildfile, but it can be changed with the toDir attribute. Test names in JUnit are formed by its Java package, class and method: EUnit uses the filename of the EOL script as the class and the name of the EOL operation as the method. By default, the package is set to the string \"default\": users are encouraged to customize it with the package attribute. Since v2.4.0, saveModelDeltas can be set to \"yes\" to have EUnit save any detected differences to \"delta\" files in the native representation of the chosen comparator, which will refer to \"frozen\" copies of the models in a eunit-tmp subfolder of the build. Helper Targets \u00b6 Ant buildfiles for EUnit may include helper targets . These targets can be invoked using from anywhere in the EOL script. Helper targets are quite versatile: called from an EOL model setup section, they allow for reusing model loading fragments between different EUnit test suites. They can also be used to invoke the model management tasks under test. EOL script \u00b6 The Epsilon Object Language script is the second half of the EUnit test suite. EOL annotations are used to tag some of the operations as data binding definitions ( @data or @Data ), additional model setup sections ( @model / @Model ), test setup and teardown sections ( @setup / @Before and @teardown / @After ), and test cases ( @test / @Test ). Suite setup and teardown sections can also be defined with @suitesetup / @BeforeClass and @suiteteardown / @AfterClass annotations: these operations will be run before and after all tests, respectively. Data bindings \u00b6 Data bindings repeat all test cases with different values in some variables. To define a data binding, users must define an operation which returns a sequence of elements and is marked with @data variable. All test cases will be repeated once for each element of the returned sequence, setting the specified variable to the corresponding element. Listing 15.2 shows two nested data bindings and a test case which will be run four times: with x=1 and y=5, x=1 and y=6, x=2 and y=5 and finally x=2 and y=6. The example shows how x and y could be used by the setup section to generate an input model for the test. This can be useful if the intent of the test is ensuring that a certain property holds in a class of models, rather than a single model. @data x operation firstLevel() { return 1.to(2); } @data y operation secondLevel() { return 5.to(6); } @setup operation generateModel() { /* generate model using x and y */ } @test operation mytest() { /* test with the generated model */ } Alternatively, if both x and y were to use the same sets of values, we could add two @data annotations to the same operation. For instance, the listing below shows how we could test with 4 cases: x=1 and y=1, x=1 and y=2, x=2 and y=1 and x=2 and y=2. @data x @data y operation levels() { return 1.to(2); } @setup operation generateModel() { /* generate model using x and y */ } @test operation mytest() { /* test with the generated model */ } Model bindings \u00b6 Model bindings repeat a test case with different subsets of models. They can be defined by annotating a test case with $with map or $onlyWith map one or more times, where map is an EOL expression that produces a MAP . For each key-value pair key = value , EUnit will rename the model named value to key . The difference between $with and $onlyWith is how they handle the models not mentioned in the MAP : $with will preserve them as is, and $onlyWith will make them unavailable during the test. $onlyWith is useful for tightly restricting the set of available models in a test and for avoiding ambiguous type references when handling multiple models using the same metamodel. The listing below shows two tests which will be each run twice. The first test uses $with , which preserves models not mentioned in the MAP: the first time, model \"A\" will be the default model and model \"B\" will be the \"Other\" model, and the second time, model \"B\" will be the default model and model \"A\" will be the \"Other\" model. The second test uses two $onlyWith annotations: on the first run, \"A\" will be available as \"Model\" and \"B\" will not unavailable, and on the second run, only \"B\" will be available as \"Model\" and \"A\" will be unavailable. $with Map {\"\" = \"A\", \"Other\" = \"B\"} $with Map {\"\" = \"B\", \"Other\" = \"A\"} @test operation mytest() { /* use the default and Other models, while keeping the rest as is */ } $onlyWith Map { \"Model\" = \"A\" } $onlyWith Map { \"Model\" = \"B\" } @test operation mytest2() { // first time: A as 'Model', B is unavailable // second time: B as 'Model', A is unavailable } Additional variables and built-in operations \u00b6 EUnit provides several variables and operations which are useful for testing. These are listed in the table below. Signature Description runTarget(name : String) Runs the specified target of the Ant buildfile which invoked EUnit. exportVariable(name : String) Exports the specified variable, to be used by another executable module. useVariable(name : String) Imports the specified variable, which should have been previously exported by another executable module. loadHutn(name : String, hutn : String) Loads an EMF model with the specified name, by parsing the second argument as an HUTN fragment. antProject : org.apache.tools.ant.Project Global variable which refers to the Ant project being executed. This can be used to create and run Ant tasks from inside the EOL code. Assertions \u00b6 EUnit implements some common assertions for equality and inequality, with special versions for comparing floating-point numbers. EUnit also supports a limited form of exception testing with , which checks that the expression inside it throws an exception. Custom assertions can be defined by the user with the operation, which fails a test with a custom message. The available assertions are shown in the table below. Signature Description assertEqualDirectories(expectedPath : String,obtainedPath : String) Fails the test if the contents of the directory in differ from those of the directory in . Directory comparisons are performed on recursive snapshots of both directories. assertEqualFiles(expectedPath : String,obtainedPath : String) Fails the test if the contents of the file in differ from those of the file in . File comparisons are performed on snapshots of both files. assertEqualModels([msg : String,]expectedModel : String,obtainedModel : String[, options : Map]) Fails the test with the optional message if the model named is not equal to the model named . Model comparisons are performed on snapshots of the resource sets of both models. During EMF comparisons, XMI identifiers are ignored. Additional comparator-specific options can be specified through . assertEquals([msg : String,]expected : Any,obtained : Any) Fails the test with the optional message if the values of and are not equal. assertEquals([msg : String,]expected : Real,obtained : Real,ulps : Integer) Fails the test with the optional message if the values of and differ in more than units of least precision. See this site for details. assertError(expr : Any) Fails the test if no exception is thrown during the evaluation of . assertFalse([msg : String,]cond : Boolean) Fails the test with the optional message if is . It is a negated version of assertTrue. assertLineWithMatch([msg : String,]path : String,regexp : String) Fails the test with the optional message if the file at does not have a line containing a substring matching the regular expression 2 . assertMatchingLine([msg : String,]path : String,regexp : String) Fails the test with the optional message if the file at does not have a line that matches the regular expression 3 from start to finish. assertNotEqualDirectories(expectedPath : String,obtainedPath : String) Negated version of assertEqualDirectories. assertNotEqualFiles(expectedPath : String,obtainedPath : String) Negated version of assertEqualFiles. assertNotEqualModels([msg : String,]expectedModel : String,obtainedModel : String) Negated version of assertNotEqualModels. assertNotEquals([msg : String,]expected : Any,obtained : Any) Negated version of assertEquals([msg : String,] expected : Any, obtained : Any). assertNotEquals([msg : String,]expected : Real,obtained : Real,ulps : Integer) Negated version of assertEquals([msg : String,] expected : Real, obtained : Real, ulps : Integer). assertTrue([msg : String,]cond : Boolean) Fails the test with the optional message if is . fail(msg : String) Fails a test with the message . The table below lists the available option keys which can be used with the model equality assertions, by comparator. Comparator and Key Usage EMF, \"whitespace\" When set to \"ignore\", differences in EString attribute values due to whitespace will be ignored. Disabled by default. EMF, \"ignoreAttributeValueChanges\" Can contain a collection of strings of the form \"package.class.attribute\". Differences in the values for these attributes will be ignored. However, if the attribute is set on one side and not on the other, the difference will be reported as normal. Empty by default. EMF, \"unorderedMoves\" When set to \"ignore\", differences in the order of the elements within an unordered EReference. Enabled by default. More importantly, EUnit implements specific assertions for comparing models, files and trees of files. Model comparison is not implemented by the assertions themselves: it is an optional service implemented by some EMC drivers. Currently, EMF models will automatically use EMF Compare as their comparison engine. The rest of the EMC drivers do not support comparison yet. The main advantage of having an abstraction layer implement model comparison as a service is that the test case definition is decoupled from the concrete model comparison engine used. Model, file and directory comparisons take a snapshot of their operands before comparing them, so EUnit can show the differences right at the moment when the comparison was performed. This is especially important when some of the models are generated on the fly by the EUnit test suite, or when a test case for code generation may overwrite the results of the previous one. The following figure shows a screenshot of the EUnit graphical user interface. On the left, an Eclipse view shows the results of several EUnit test suites. We can see that the load- models-with-hutn suite failed. The Compare button to the right of \"Failure Trace\" can be pressed to show the differences between the expected and obtained models, as shown on the right side. EUnit implements a pluggable architecture where difference viewers are automatically selected based on the types of the operands. There are difference viewers for EMF models, file trees and a fallback viewer which converts both operands to strings. Examples \u00b6 Models and Tasks in the Buildfile \u00b6 After describing the basic syntax, we will show how to use EUnit to test an ETL transformation. The Ant buildfile is shown in the listing below. It has two targets: run-tests (lines 2-19) invokes the EUnit suite, and tree2graph (lines 23-28) is a helper target which transforms model Tree into model Graph using ETL. The <modelTasks> nested element is used to load the input, expected output and output EMF models. Graph is loaded with read set to false : the model will be initially empty, and will be populated by the ETL transformation. <project> <target name= \"run-tests\" > <epsilon.eunit src= \"test-external.eunit\" > <modelTasks> <epsilon.emf.loadModel name= \"Tree\" modelfile= \"tree.model\" metamodelfile= \"tree.ecore\" read= \"true\" store= \"false\" /> <epsilon.emf.loadModel name= \"GraphExpected\" modelfile= \"graph.model\" metamodelfile= \"graph.ecore\" read= \"true\" store= \"false\" /> <epsilon.emf.loadModel name= \"Graph\" modelfile= \"transformed.model\" metamodelfile= \"graph.ecore\" read= \"false\" store= \"false\" /> </modelTasks> </epsilon.eunit> </target> <target name= \"tree2graph\" > <epsilon.etl src= \"${basedir}/resources/Tree2Graph.etl\" > <model ref= \"Tree\" /> <model ref= \"Graph\" /> </epsilon.etl> </target> </project> The EOL script is shown in the listing below: it invokes the helper task (line 3) and checks that the obtained model is equal to the expected model (line 4). Internally, EMC will perform the comparison using EMF Compare. @test operation transformationWorksAsExpected() { runTarget(\"tree2graph\"); assertEqualModels(\"GraphExpected\", \"Graph\"); } Models and Tasks in the EOL Script \u00b6 In the previous section, the EOL file is kept very concise because the model setup and model management tasks under test were specified in the Ant buildfile. In this section, we will inline the models and the tasks into the EOL script instead. The Ant buildfile is shown in the listing below. It is now very simple: all it needs to do is run the EOL script. However, since we will parse HUTN in the EOL script, we must make sure the s of the metamodels are registered. <project> <target name= \"run-tests\" > <epsilon.emf.register file= \"tree.ecore\" /> <epsilon.emf.register file= \"graph.ecore\" /> <epsilon.eunit src= \"test-inlined.eunit\" /> </target> </project> The EOL script used is shown below. Instead of loading models through the Ant tasks, the loadHutn operation has been used to load the models. The test itself is almost the same, but instead of running a helper target, it invokes an operation which creates and runs the ETL Ant task through the antProject variable provided by EUnit, taking advantage of the support in EOL for invoking Java code through reflection. @model operation loadModels() { loadHutn(\"Tree\", '@Spec {Metamodel {nsUri: \"Tree\" }} Model { Tree \"t1\" { label : \"t1\" } Tree \"t2\" { label : \"t2\" parent : Tree \"t1\" } } '); loadHutn(\"GraphExpected\", '@Spec {Metamodel {nsUri: \"Graph\"}} Graph { nodes : Node \"t1\" { name : \"t1\" outgoing : Edge { source : Node \"t1\" target : Node \"t2\" } }, Node \"t2\" { name : \"t2\" } } '); loadHutn(\"Graph\", '@Spec {Metamodel {nsUri: \"Graph\"}}'); } @test operation transformationWorksAsExpected() { runETL(); assertEqualModels(\"GraphExpected\", \"Graph\"); } operation runETL() { var etlTask := antProject.createTask(\"epsilon.etl\"); etlTask.setSrc(new Native('java.io.File')( antProject.getBaseDir(), 'resources/etl/Tree2Graph.etl')); etlTask.createModel().setRef(\"Tree\"); etlTask.createModel().setRef(\"Graph\"); etlTask.execute(); } Extending EUnit \u00b6 EUnit is based on the Epsilon platform, but it is designed to accommodate other technologies. In this section we will explain several strategies to add support for these technologies to EUnit. EUnit uses the Epsilon Model Connectivity abstraction layer to handle different modelling technologies. Adding support for a different modelling technology only requires implementing another driver for EMC. Depending on the modelling technology, the driver can provide optional services such as model comparison, caching or reflection. EUnit uses Ant as a workflow language: all model management tasks must be exposed through Ant tasks. It is highly encouraged, however, that the Ant task is aware of the EMC model repository linked to the Ant project. Otherwise, users will have to shuffle the models out from and back into the repository between model management tasks. As an example, a helper target for an ATL transformation with the existing Ant tasks needs to: Save the input model in the EMC model repository to a file, by invoking the <epsilon.storeModel> task. Load the metamodels and the input model with <atl.loadModel> . Run the ATL transformation with <atl.launch> . Save the result of the ATL transformation with <atl.saveModel> . Load it into the EMC model repository with <epsilon.emf.loadModel> . The listing below shows the Ant buildfile which would be required for running these steps, showing that while EUnit can use the existing ATL tasks as-is, the required helper task is quite longer than the one shown above. Ideally, Ant tasks should be adapted or wrapped to use models directly from the EMC model repository. <project> <!-- ... omitted ... --> <target name= \"atl\" > <!-- Create temporary files for input and output models --> <tempfile property= \"atl.temp.srcfile\" /> <tempfile property= \"atl.temp.dstfile\" /> <!-- Save input model to a file --> <epsilon.storeModel model= \"Tree\" target= \"${atl.temp.srcfile}\" /> <!-- Load the metamodels and the source model --> <atl.loadModel name= \"TreeMM\" metamodel= \"MOF\" path= \"metamodels/tree.ecore\" /> <atl.loadModel name= \"GraphMM\" metamodel= \"MOF\" path= \"metamodels/graph.ecore\" /> <atl.loadModel name= \"Tree\" metamodel= \"TreeMM\" path= \"${atl.temp.srcfile}\" /> <!-- Run ATL and save the model --> <atl.launch path= \"transformation/tree2graph.atl\" > <inmodel name= \"IN\" model= \"Tree\" /> <outmodel name= \"OUT\" model= \"Graph\" metamodel= \"GraphMM\" /> </atl.launch> <atl.saveModel model= \"Graph\" path= \"${atl.temp.dstfile}\" /> <!-- Load it back into the EUnit suite --> <epsilon.emf.loadModel name= \"Graph\" modelfile= \"${atl.temp.dstfile}\" metamodeluri= \"Graph\" read= \"true\" store= \"false\" /> <!-- Delete temporary files --> <delete file= \"${atl.temp.srcfile}\" /> <delete file= \"${atl.temp.dstfile}\" /> </target> </project> Another advantage in making model management tasks EMC-aware is that they can easily \u201cexport\u201d their results as models, making them easier to test. For instance, the EVL Ant task allows for exporting its results as a model by setting the attribute exportAsModel to true . This way, EOL can query the results as any regular model. This is simpler than transforming the validated model to a problem metamodel. The example in the listing below checks that a single warning was produced due to the expected rule ( LabelsStartWithT ) and the expected model element. @test operation valid() { var tree := new Tree!Tree; tree.label := '1n'; runTarget('validate-tree'); var errors := EVL!EvlUnsatisfiedConstraint.allInstances; assertEquals(1, errors.size); var error := errors.first; assertEquals(tree, error.instance); assertEquals(false, error.constraint.isCritique); assertEquals('LabelsStartWithT', error.constraint.name); } CPU time only measures the time elapsed in the thread used by EUnit, and is more stable with varying system load in single-threaded programs. \u21a9 See JAVA.UTIL.REGEX.PATTERN for details about the accepted syntax for regular expressions. \u21a9 See footnote assertLineWithMatch for details about the syntax of the regular expressions. \u21a9","title":"Unit Testing (EUnit)"},{"location":"doc/eunit/#the-epsilon-unit-testing-framework-eunit","text":"EUnit is an unit testing framework specifically designed to test model management tasks, based on EOL and the Ant workflow tasks. It provides assertions for comparing models, files and directories. Tests can be reused with different sets of models and input data, and differences between the expected and actual models can be graphically visualized. This chapter describes how tests are organized and written and shows two examples of how a model-to-model transformation can be tested with EUnit. This chapter ends with a discussion of how EUnit can be extended to support other modelling and model management technologies.","title":"The Epsilon Unit Testing Framework (EUnit)"},{"location":"doc/eunit/#common-issues","text":"While each type of model management task does have specific complexity, below is a list of common concerns: There is usually a large number of models to be handled. Some may be created by hand, some may be generated using hand-written programs, and some may be generated automatically following certain coverage criteria. A single model or set of models may be used in several tasks. For instance, a model may be validated before performing an in-place transformation to assist the user, and later on it may be transformed to another model or merged with a different model. This requires having at least one test for each valid combination of models and sets of tasks. Test oracles are more complex than in traditional unit testing: instead of checking scalar values or simple lists, entire graphs of model objects or file trees may have to be compared. In some cases, complex properties in the generated artifacts may have to be checked. Models and model management tasks may use a wide range of technologies. Models may be based on Ecore, XML files or Java object graphs, among many others. At the same time, tasks may use technologies from different platforms, such as Epsilon, or AMMA. Many of these technologies offer high-level tools for running and debugging the different tasks using several models. However, users wishing to do automated unit testing need to learn low-level implementation details about their modelling and model management technologies. This increases the initial cost of testing these tasks and hampers the adoption of new technologies. Existing testing tools tend to focus on the testing technique itself, and lack integration with external systems. Some tools provide graphical user interfaces, but most do not generate reports which can be consumed by a continuous integration server, for instance.","title":"Common Issues"},{"location":"doc/eunit/#testing-with-junit","text":"The previous issues are easier to understand with a concrete example. This section shows how a simple transformation between two EMF models in ETL using JUnit 4 would be normally tested, and points out several issues due to JUnit's limitations as a general-purpose unit testing framework for Java programs. For the sake of brevity, only an outline of the JUnit test suite is included. All JUnit test suites are defined as Java classes. This test suite has three methods: The test setup method (marked with the @Before JUnit annotation) loads the required models by creating and configuring instances of EmfModel . After that, it prepares the transformation by creating and configuring an instance of EtlModule , adding the input and output models to its model repository. The test case itself (marked with @Test ) runs the ETL transformation and uses the generic comparison algorithm implemented by EMF Compare to perform the model comparison. The test teardown method (marked with @After ) disposes of the models. Several issues can be identified in each part of the test suite. First, test setup is tightly bound to the technologies used: it depends on the API of the EmfModel and EtlModule classes, which are both part of Epsilon. Later refactorings in these classes may break existing tests. The test case can only be used for a single combination of input and output models. Testing several combinations requires either repeating the same code and therefore making the suite less maintainable, or using parametric testing, which may be wasteful if not all tests need the same combinations of models. Model comparison requires the user to manually select a model comparison engine and integrate it with the test. For comparing EMF models, EMF Compare is easy to use and readily available. However, generic model comparison engines may not be available for some modelling technologies, or may be harder to integrate. Finally, instead of comparing the obtained and expected models, several properties could have been checked in the obtained model. However, querying models through Java code can be quite verbose.","title":"Testing with JUnit"},{"location":"doc/eunit/#selected-approach","text":"Several approaches could be followed to address these issues. Our first instinct would be to extend JUnit and reuse all the tooling available for it. A custom test runner would simplify setup and teardown, and modelling platforms would integrate their technologies into it. Since Java is very verbose when querying models, the custom runner should run tests in a higher-level language, such as EOL. However, JUnit is very tightly coupled to Java, and this would impose limits on the level of integration we could obtain. For instance, errors in the model management tasks or the EOL tests could not be reported from their original source, but rather from the Java code which invoked them. Another problem with this approach is that new integration code would need to be written for each of the existing platforms. Alternatively, we could add a new language exclusively dedicated to testing to the Epsilon family. Being based on EOL, model querying would be very concise, and with a test runner written from scratch, test execution would be very flexible. However, this would still require all platforms to write new code to integrate with it, and this code would be tightly coupled to Epsilon. As a middle ground, we could decorate EOL to guide its execution through a new test runner, while reusing the Apache Ant tasks already provided by several of the existing platforms, such as AMMA or Epsilon. Like Make, Ant is a tool focused on automating the execution of processes such as program builds. Unlike Make, Ant defines processes using XML buildfiles with sets of interrelated targets . Each target contains in turn a sequence of tasks . Many Ant tasks and Ant-based tools already exist, and it is easy to create a new Ant task. Among these three approaches, EUnit follows the last one. Ant tasks take care of model setup and management, and tests are written in EOL and executed by a new test runner, written from the ground up.","title":"Selected Approach"},{"location":"doc/eunit/#test-organization","text":"EUnit has a rich data model: test suites are organized as trees of tests, and each test is divided into many parts which can be extended by the user. This section is dedicated to describing how test suites and tests are organized. The next section indicates how they are written.","title":"Test Organization"},{"location":"doc/eunit/#test-suites","text":"EUnit test suites are organized as trees: inner nodes group related test cases and define data bindings. Leaf nodes define model bindings and run the test cases. Data bindings repeat all test cases with different values in one or more variables. They can implement parametric testing, as in JUnit 4. EUnit can nest several data bindings, running all test cases once for each combination. Model bindings are specific to EUnit: they allow developers to repeat a single test case with different subsets of models. Data and model bindings can be combined. One interesting approach is to set the names of the models to be used in the model binding from the data binding, as a quick way to try several test cases with the same subsets of models. The figure below shows an example of an EUnit test tree: nodes with data bindings are marked with data , and nodes with model bindings are marked with model . graph TD data1[data<br/>x=1] data2[data<br/>x=2] testa1[test A] testb1[test B] testa2[test A] testb2[test B] modelx1[model X] modely1[model Y] modelx2[model X] modely2[model Y] root --> data1 root --> data2 data1 --> testa1 data1 --> testb1 data2 --> testa2 data2 --> testb2 testa1 --> modelx1 testa1 --> modely1 testa2 --> modelx2 testa2 --> modely2 EUnit will perform a preorder traversal of this tree, running the following tests: A with x = 1 and model X. A with x = 1 and model Y. B with x = 1 and both models. A with x = 2 and model X. A with x = 2 and model Y. B with x = 2 and both models. Optionally, EUnit can filter tests by name, running only A or B . Similarly to JUnit, EUnit logs start and finish times for each node in the tree, so the most expensive test cases can be quickly detected. However, EUnit logs CPU time 1 in addition to the usual wallclock time. Parametric testing is not to be confused with theories : both repeat a test case with different values, but results are reported quite differently. While parametric testing produces separate test cases with independent results, theories produce aggregated tests which only pass if the original test case passes for every data point. The figures below illustrate these differences. EUnit does not support theories yet: however, they can be approximated with data bindings. graph TD data1[data 1] data2[data 2] testa1[test 1] testb1[test 2] testa2[test 1] testb2[test 2] root --> data1 root --> data2 data1 --> testa1 data1 --> testb1 data2 --> testa2 data2 --> testb2 Parametric Testing graph TD data1[test 1] data2[test 2] testa1[data 1] testb1[data 2] testa2[data 1] testb2[data 2] root --> data1 root --> data2 data1 --> testa1 data1 --> testb1 data2 --> testa2 data2 --> testb2 Theories","title":"Test Suites"},{"location":"doc/eunit/#test-cases","text":"The execution of a test case is divided into the following steps: Apply the data bindings of its ancestors. Run the model setup sections defined by the user. Apply the model bindings of this node. Run the regular setup sections defined by the user. Run the test case itself. Run the teardown sections defined by the user. Tear down the data bindings and models for this test. An important difference between JUnit and EUnit is that setup is split into two parts: model setup and regular setup. This split allows users to add code before and after model bindings are applied. Normally, the model setup sections will load all the models needed by the test suite, and the regular setup sections will further prepare the models selected by the model binding. Explicit teardown sections are usually not needed, as models are disposed automatically by EUnit. EUnit includes them for consistency with the xUnit frameworks. Due to its focus on model management, model setup in EUnit is very flexible. Developers can combine several ways to set up models, such as model references, individual Apache Ant tasks, Apache Ant targets or Human-Usable Text Notation (HUTN) fragments. A test case may produce one among several results. SUCCESS is obtained if all assertions passed and no exceptions were thrown. FAILURE is obtained if an assertion failed. ERROR is obtained if an unexpected exception was thrown while running the test. Finally, tests may be SKIPPED by the user.","title":"Test Cases"},{"location":"doc/eunit/#test-specification","text":"In the previous section, we described how test suites and test cases are organized. In this section, we will show how to write them. As discussed before, after evaluating several approaches, we decided to combine the expressive power of EOL and the extensibility of Apache Ant. For this reason, EUnit test suites are split into two files: an Ant buildfile and an EOL script with some special-purpose annotations. The next subsections describe the contents of these two files and revisit the previous example with EUnit.","title":"Test Specification"},{"location":"doc/eunit/#ant-buildfile","text":"EUnit uses standard Ant buildfiles: running EUnit is as simple as using its Ant task. Users may run EUnit more than once in a single Ant launch: the graphical user interface will automatically aggregate the results of all test suites.","title":"Ant Buildfile"},{"location":"doc/eunit/#eunit-invocations","text":"An example invocation of the EUnit Ant task using the most common features is shown in the listing below. Users will normally only use some of these features at a time, though. Optional attributes have been listed between brackets. Some nested elements can be repeated 0+ times ( * ) or 0-1 times ( ? ). Valid alternatives for an attribute are separated with | . <epsilon.eunit src= \"...\" [ failOnErrors= \"...\" ] [ package= \"..\" ] [ toDir= \"...\" ] [ report= \"yes|no\" ] [ saveModelDeltas= \"yes|no\" ] > ( <model ref= \"OldName\" [ as= \"NewName\" ] /> )* ( <uses ref= \"x\" [ as= \"y\" ] /> )* ( <exports ref= \"z\" [ as= \"w\" ] /> )* ( <parameter name= \"myparam\" value= \"myvalue\" /> )* ( <modelTasks> <!-- Zero or more Ant tasks --> </modelTasks> )? </epsilon.eunit> The EUnit Ant task is based on the Epsilon abstract executable module task, inheriting some useful features. The attribute src points to the path of the EOL file, and the optional attribute failOnErrors can be set to false to prevent EUnit from aborting the Ant launch if a test case fails. EUnit also inherits support for importing and exporting global variables through the <uses> and <exports> elements: the original name is set in ref , and the optional as attribute allows for using a different name. For receiving parameters as name-value piars, the <parameter> element can be used. Model references (using the <model> nested element) are also inherited from the Epsilon abstract executable module task. These allow model management tasks to refer by name to models previously loaded in the Ant buildfile. However, EUnit implicitly reloads the models after each test case. This ensures that test cases are isolated from each other. The optional <modelTasks> nested element contains a sequence of Ant tasks which will be run after reloading the model references and before running the model setup sections in the EOL file. This allows users to run workflows more advanced than simply reloading model references. The EUnit Ant task adds several new features to customize the test result reports and perform more advanced model setup. By default, EUnit generates reports in the XML format of the Ant <junit> task. This format is also used by many other tools, such as the TestNG unit testing framework, the Jenkins continuous integration server or the JUnit Eclipse plug-ins. To suppress these reports, report must be set to no. By default, the XML report is generated in the same directory as the Ant buildfile, but it can be changed with the toDir attribute. Test names in JUnit are formed by its Java package, class and method: EUnit uses the filename of the EOL script as the class and the name of the EOL operation as the method. By default, the package is set to the string \"default\": users are encouraged to customize it with the package attribute. Since v2.4.0, saveModelDeltas can be set to \"yes\" to have EUnit save any detected differences to \"delta\" files in the native representation of the chosen comparator, which will refer to \"frozen\" copies of the models in a eunit-tmp subfolder of the build.","title":"EUnit Invocations"},{"location":"doc/eunit/#helper-targets","text":"Ant buildfiles for EUnit may include helper targets . These targets can be invoked using from anywhere in the EOL script. Helper targets are quite versatile: called from an EOL model setup section, they allow for reusing model loading fragments between different EUnit test suites. They can also be used to invoke the model management tasks under test.","title":"Helper Targets"},{"location":"doc/eunit/#eol-script","text":"The Epsilon Object Language script is the second half of the EUnit test suite. EOL annotations are used to tag some of the operations as data binding definitions ( @data or @Data ), additional model setup sections ( @model / @Model ), test setup and teardown sections ( @setup / @Before and @teardown / @After ), and test cases ( @test / @Test ). Suite setup and teardown sections can also be defined with @suitesetup / @BeforeClass and @suiteteardown / @AfterClass annotations: these operations will be run before and after all tests, respectively.","title":"EOL script"},{"location":"doc/eunit/#data-bindings","text":"Data bindings repeat all test cases with different values in some variables. To define a data binding, users must define an operation which returns a sequence of elements and is marked with @data variable. All test cases will be repeated once for each element of the returned sequence, setting the specified variable to the corresponding element. Listing 15.2 shows two nested data bindings and a test case which will be run four times: with x=1 and y=5, x=1 and y=6, x=2 and y=5 and finally x=2 and y=6. The example shows how x and y could be used by the setup section to generate an input model for the test. This can be useful if the intent of the test is ensuring that a certain property holds in a class of models, rather than a single model. @data x operation firstLevel() { return 1.to(2); } @data y operation secondLevel() { return 5.to(6); } @setup operation generateModel() { /* generate model using x and y */ } @test operation mytest() { /* test with the generated model */ } Alternatively, if both x and y were to use the same sets of values, we could add two @data annotations to the same operation. For instance, the listing below shows how we could test with 4 cases: x=1 and y=1, x=1 and y=2, x=2 and y=1 and x=2 and y=2. @data x @data y operation levels() { return 1.to(2); } @setup operation generateModel() { /* generate model using x and y */ } @test operation mytest() { /* test with the generated model */ }","title":"Data bindings"},{"location":"doc/eunit/#model-bindings","text":"Model bindings repeat a test case with different subsets of models. They can be defined by annotating a test case with $with map or $onlyWith map one or more times, where map is an EOL expression that produces a MAP . For each key-value pair key = value , EUnit will rename the model named value to key . The difference between $with and $onlyWith is how they handle the models not mentioned in the MAP : $with will preserve them as is, and $onlyWith will make them unavailable during the test. $onlyWith is useful for tightly restricting the set of available models in a test and for avoiding ambiguous type references when handling multiple models using the same metamodel. The listing below shows two tests which will be each run twice. The first test uses $with , which preserves models not mentioned in the MAP: the first time, model \"A\" will be the default model and model \"B\" will be the \"Other\" model, and the second time, model \"B\" will be the default model and model \"A\" will be the \"Other\" model. The second test uses two $onlyWith annotations: on the first run, \"A\" will be available as \"Model\" and \"B\" will not unavailable, and on the second run, only \"B\" will be available as \"Model\" and \"A\" will be unavailable. $with Map {\"\" = \"A\", \"Other\" = \"B\"} $with Map {\"\" = \"B\", \"Other\" = \"A\"} @test operation mytest() { /* use the default and Other models, while keeping the rest as is */ } $onlyWith Map { \"Model\" = \"A\" } $onlyWith Map { \"Model\" = \"B\" } @test operation mytest2() { // first time: A as 'Model', B is unavailable // second time: B as 'Model', A is unavailable }","title":"Model bindings"},{"location":"doc/eunit/#additional-variables-and-built-in-operations","text":"EUnit provides several variables and operations which are useful for testing. These are listed in the table below. Signature Description runTarget(name : String) Runs the specified target of the Ant buildfile which invoked EUnit. exportVariable(name : String) Exports the specified variable, to be used by another executable module. useVariable(name : String) Imports the specified variable, which should have been previously exported by another executable module. loadHutn(name : String, hutn : String) Loads an EMF model with the specified name, by parsing the second argument as an HUTN fragment. antProject : org.apache.tools.ant.Project Global variable which refers to the Ant project being executed. This can be used to create and run Ant tasks from inside the EOL code.","title":"Additional variables and built-in operations"},{"location":"doc/eunit/#assertions","text":"EUnit implements some common assertions for equality and inequality, with special versions for comparing floating-point numbers. EUnit also supports a limited form of exception testing with , which checks that the expression inside it throws an exception. Custom assertions can be defined by the user with the operation, which fails a test with a custom message. The available assertions are shown in the table below. Signature Description assertEqualDirectories(expectedPath : String,obtainedPath : String) Fails the test if the contents of the directory in differ from those of the directory in . Directory comparisons are performed on recursive snapshots of both directories. assertEqualFiles(expectedPath : String,obtainedPath : String) Fails the test if the contents of the file in differ from those of the file in . File comparisons are performed on snapshots of both files. assertEqualModels([msg : String,]expectedModel : String,obtainedModel : String[, options : Map]) Fails the test with the optional message if the model named is not equal to the model named . Model comparisons are performed on snapshots of the resource sets of both models. During EMF comparisons, XMI identifiers are ignored. Additional comparator-specific options can be specified through . assertEquals([msg : String,]expected : Any,obtained : Any) Fails the test with the optional message if the values of and are not equal. assertEquals([msg : String,]expected : Real,obtained : Real,ulps : Integer) Fails the test with the optional message if the values of and differ in more than units of least precision. See this site for details. assertError(expr : Any) Fails the test if no exception is thrown during the evaluation of . assertFalse([msg : String,]cond : Boolean) Fails the test with the optional message if is . It is a negated version of assertTrue. assertLineWithMatch([msg : String,]path : String,regexp : String) Fails the test with the optional message if the file at does not have a line containing a substring matching the regular expression 2 . assertMatchingLine([msg : String,]path : String,regexp : String) Fails the test with the optional message if the file at does not have a line that matches the regular expression 3 from start to finish. assertNotEqualDirectories(expectedPath : String,obtainedPath : String) Negated version of assertEqualDirectories. assertNotEqualFiles(expectedPath : String,obtainedPath : String) Negated version of assertEqualFiles. assertNotEqualModels([msg : String,]expectedModel : String,obtainedModel : String) Negated version of assertNotEqualModels. assertNotEquals([msg : String,]expected : Any,obtained : Any) Negated version of assertEquals([msg : String,] expected : Any, obtained : Any). assertNotEquals([msg : String,]expected : Real,obtained : Real,ulps : Integer) Negated version of assertEquals([msg : String,] expected : Real, obtained : Real, ulps : Integer). assertTrue([msg : String,]cond : Boolean) Fails the test with the optional message if is . fail(msg : String) Fails a test with the message . The table below lists the available option keys which can be used with the model equality assertions, by comparator. Comparator and Key Usage EMF, \"whitespace\" When set to \"ignore\", differences in EString attribute values due to whitespace will be ignored. Disabled by default. EMF, \"ignoreAttributeValueChanges\" Can contain a collection of strings of the form \"package.class.attribute\". Differences in the values for these attributes will be ignored. However, if the attribute is set on one side and not on the other, the difference will be reported as normal. Empty by default. EMF, \"unorderedMoves\" When set to \"ignore\", differences in the order of the elements within an unordered EReference. Enabled by default. More importantly, EUnit implements specific assertions for comparing models, files and trees of files. Model comparison is not implemented by the assertions themselves: it is an optional service implemented by some EMC drivers. Currently, EMF models will automatically use EMF Compare as their comparison engine. The rest of the EMC drivers do not support comparison yet. The main advantage of having an abstraction layer implement model comparison as a service is that the test case definition is decoupled from the concrete model comparison engine used. Model, file and directory comparisons take a snapshot of their operands before comparing them, so EUnit can show the differences right at the moment when the comparison was performed. This is especially important when some of the models are generated on the fly by the EUnit test suite, or when a test case for code generation may overwrite the results of the previous one. The following figure shows a screenshot of the EUnit graphical user interface. On the left, an Eclipse view shows the results of several EUnit test suites. We can see that the load- models-with-hutn suite failed. The Compare button to the right of \"Failure Trace\" can be pressed to show the differences between the expected and obtained models, as shown on the right side. EUnit implements a pluggable architecture where difference viewers are automatically selected based on the types of the operands. There are difference viewers for EMF models, file trees and a fallback viewer which converts both operands to strings.","title":"Assertions"},{"location":"doc/eunit/#examples","text":"","title":"Examples"},{"location":"doc/eunit/#models-and-tasks-in-the-buildfile","text":"After describing the basic syntax, we will show how to use EUnit to test an ETL transformation. The Ant buildfile is shown in the listing below. It has two targets: run-tests (lines 2-19) invokes the EUnit suite, and tree2graph (lines 23-28) is a helper target which transforms model Tree into model Graph using ETL. The <modelTasks> nested element is used to load the input, expected output and output EMF models. Graph is loaded with read set to false : the model will be initially empty, and will be populated by the ETL transformation. <project> <target name= \"run-tests\" > <epsilon.eunit src= \"test-external.eunit\" > <modelTasks> <epsilon.emf.loadModel name= \"Tree\" modelfile= \"tree.model\" metamodelfile= \"tree.ecore\" read= \"true\" store= \"false\" /> <epsilon.emf.loadModel name= \"GraphExpected\" modelfile= \"graph.model\" metamodelfile= \"graph.ecore\" read= \"true\" store= \"false\" /> <epsilon.emf.loadModel name= \"Graph\" modelfile= \"transformed.model\" metamodelfile= \"graph.ecore\" read= \"false\" store= \"false\" /> </modelTasks> </epsilon.eunit> </target> <target name= \"tree2graph\" > <epsilon.etl src= \"${basedir}/resources/Tree2Graph.etl\" > <model ref= \"Tree\" /> <model ref= \"Graph\" /> </epsilon.etl> </target> </project> The EOL script is shown in the listing below: it invokes the helper task (line 3) and checks that the obtained model is equal to the expected model (line 4). Internally, EMC will perform the comparison using EMF Compare. @test operation transformationWorksAsExpected() { runTarget(\"tree2graph\"); assertEqualModels(\"GraphExpected\", \"Graph\"); }","title":"Models and Tasks in the Buildfile"},{"location":"doc/eunit/#models-and-tasks-in-the-eol-script","text":"In the previous section, the EOL file is kept very concise because the model setup and model management tasks under test were specified in the Ant buildfile. In this section, we will inline the models and the tasks into the EOL script instead. The Ant buildfile is shown in the listing below. It is now very simple: all it needs to do is run the EOL script. However, since we will parse HUTN in the EOL script, we must make sure the s of the metamodels are registered. <project> <target name= \"run-tests\" > <epsilon.emf.register file= \"tree.ecore\" /> <epsilon.emf.register file= \"graph.ecore\" /> <epsilon.eunit src= \"test-inlined.eunit\" /> </target> </project> The EOL script used is shown below. Instead of loading models through the Ant tasks, the loadHutn operation has been used to load the models. The test itself is almost the same, but instead of running a helper target, it invokes an operation which creates and runs the ETL Ant task through the antProject variable provided by EUnit, taking advantage of the support in EOL for invoking Java code through reflection. @model operation loadModels() { loadHutn(\"Tree\", '@Spec {Metamodel {nsUri: \"Tree\" }} Model { Tree \"t1\" { label : \"t1\" } Tree \"t2\" { label : \"t2\" parent : Tree \"t1\" } } '); loadHutn(\"GraphExpected\", '@Spec {Metamodel {nsUri: \"Graph\"}} Graph { nodes : Node \"t1\" { name : \"t1\" outgoing : Edge { source : Node \"t1\" target : Node \"t2\" } }, Node \"t2\" { name : \"t2\" } } '); loadHutn(\"Graph\", '@Spec {Metamodel {nsUri: \"Graph\"}}'); } @test operation transformationWorksAsExpected() { runETL(); assertEqualModels(\"GraphExpected\", \"Graph\"); } operation runETL() { var etlTask := antProject.createTask(\"epsilon.etl\"); etlTask.setSrc(new Native('java.io.File')( antProject.getBaseDir(), 'resources/etl/Tree2Graph.etl')); etlTask.createModel().setRef(\"Tree\"); etlTask.createModel().setRef(\"Graph\"); etlTask.execute(); }","title":"Models and Tasks in the EOL Script"},{"location":"doc/eunit/#extending-eunit","text":"EUnit is based on the Epsilon platform, but it is designed to accommodate other technologies. In this section we will explain several strategies to add support for these technologies to EUnit. EUnit uses the Epsilon Model Connectivity abstraction layer to handle different modelling technologies. Adding support for a different modelling technology only requires implementing another driver for EMC. Depending on the modelling technology, the driver can provide optional services such as model comparison, caching or reflection. EUnit uses Ant as a workflow language: all model management tasks must be exposed through Ant tasks. It is highly encouraged, however, that the Ant task is aware of the EMC model repository linked to the Ant project. Otherwise, users will have to shuffle the models out from and back into the repository between model management tasks. As an example, a helper target for an ATL transformation with the existing Ant tasks needs to: Save the input model in the EMC model repository to a file, by invoking the <epsilon.storeModel> task. Load the metamodels and the input model with <atl.loadModel> . Run the ATL transformation with <atl.launch> . Save the result of the ATL transformation with <atl.saveModel> . Load it into the EMC model repository with <epsilon.emf.loadModel> . The listing below shows the Ant buildfile which would be required for running these steps, showing that while EUnit can use the existing ATL tasks as-is, the required helper task is quite longer than the one shown above. Ideally, Ant tasks should be adapted or wrapped to use models directly from the EMC model repository. <project> <!-- ... omitted ... --> <target name= \"atl\" > <!-- Create temporary files for input and output models --> <tempfile property= \"atl.temp.srcfile\" /> <tempfile property= \"atl.temp.dstfile\" /> <!-- Save input model to a file --> <epsilon.storeModel model= \"Tree\" target= \"${atl.temp.srcfile}\" /> <!-- Load the metamodels and the source model --> <atl.loadModel name= \"TreeMM\" metamodel= \"MOF\" path= \"metamodels/tree.ecore\" /> <atl.loadModel name= \"GraphMM\" metamodel= \"MOF\" path= \"metamodels/graph.ecore\" /> <atl.loadModel name= \"Tree\" metamodel= \"TreeMM\" path= \"${atl.temp.srcfile}\" /> <!-- Run ATL and save the model --> <atl.launch path= \"transformation/tree2graph.atl\" > <inmodel name= \"IN\" model= \"Tree\" /> <outmodel name= \"OUT\" model= \"Graph\" metamodel= \"GraphMM\" /> </atl.launch> <atl.saveModel model= \"Graph\" path= \"${atl.temp.dstfile}\" /> <!-- Load it back into the EUnit suite --> <epsilon.emf.loadModel name= \"Graph\" modelfile= \"${atl.temp.dstfile}\" metamodeluri= \"Graph\" read= \"true\" store= \"false\" /> <!-- Delete temporary files --> <delete file= \"${atl.temp.srcfile}\" /> <delete file= \"${atl.temp.dstfile}\" /> </target> </project> Another advantage in making model management tasks EMC-aware is that they can easily \u201cexport\u201d their results as models, making them easier to test. For instance, the EVL Ant task allows for exporting its results as a model by setting the attribute exportAsModel to true . This way, EOL can query the results as any regular model. This is simpler than transforming the validated model to a problem metamodel. The example in the listing below checks that a single warning was produced due to the expected rule ( LabelsStartWithT ) and the expected model element. @test operation valid() { var tree := new Tree!Tree; tree.label := '1n'; runTarget('validate-tree'); var errors := EVL!EvlUnsatisfiedConstraint.allInstances; assertEquals(1, errors.size); var error := errors.first; assertEquals(tree, error.instance); assertEquals(false, error.constraint.isCritique); assertEquals('LabelsStartWithT', error.constraint.name); } CPU time only measures the time elapsed in the thread used by EUnit, and is more stable with varying system load in single-threaded programs. \u21a9 See JAVA.UTIL.REGEX.PATTERN for details about the accepted syntax for regular expressions. \u21a9 See footnote assertLineWithMatch for details about the syntax of the regular expressions. \u21a9","title":"Extending EUnit"},{"location":"doc/evl/","text":"The Epsilon Validation Language (EVL) \u00b6 EVL contributes model validation capabilities to Epsilon. More specifically, EVL can be used to specify and evaluate constraints and critiques on models of arbitrary metamodels and modelling technologies, and to produce human-readable error messages and executable quick fixes. Try EVL online You can run and fiddle with EVL constraints that validate a project scheduling model in the online Epsilon Playground . Abstract Syntax \u00b6 In EVL, validation specifications are organized in modules ( EvlModule ). As illustrated in the figure below, EvlModule (indirectly) extends EolModule which means that it can contain user-defined operations and import other EOL library modules and EVL modules. Apart from operations, an EVL module also contains a set of constraints grouped by the context they apply to, and, by extending ErlModule , a number of pre and post blocks. Info As with most languages in Epsilon, EVL uses EOL as its expression language. This page only documents the additional syntax and semantics that EVL provides on top of EOL. classDiagram class Constraint { -name: String -guard: ExecutableBlock<Boolean> -check: ExecutableBlock<Boolean> -message: ExecutableBlock<String> -isCritique: boolean } class ConstraintContext { -type: EolModelElementType -guard: ExecutableBlock<Boolean> } class NamedStatementBlockRule { -name: String -body: StatementBlock } class Fix { -guard: ExecutableBlock<Boolean> -title: ExecutableBlock<String> -body: ExecutableBlock<Void> } EolModule <|-- ErlModule EvlModule --|> ErlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EvlModule -- ConstraintContext: contexts * ConstraintContext -- Constraint: constraints * Constraint -- Fix: fixes * Context \u00b6 A context specifies the kind of instances on which the contained constraints will be evaluated. Each context can optionally define a guard which limits its applicability to a narrower subset of instances of its specified type. Thus, if the guard fails for a specific instance of the type, none of its contained constraints are evaluated. Constraint \u00b6 As with OCL, each EVL constraint defines a name and a body ( check ). However, it can optionally also define a guard which further limits its applicability to a subset of the instances of the type defined by the embracing context . Each constraint can optionally define a message as an ExecutableBlock that should return a String providing a description of the reason(s) for which the constraint has failed on a particular element. A constraint can also optionally define a number of fixes . Finally, as displayed in the figure above, constraint is an abstract class that is used as a super-class for the specific types Constraint and Critique . Guard \u00b6 Guards are used to limit the applicability of constraints. This can be achieved at two levels. At the Context level it limits the applicability of all constraints of the context and at the Constraint level it limits the applicability of a specific constraint. Fix \u00b6 A fix defines a title using an ExecutableBlock instead of a static String to allow users to specify context-aware titles (e.g. Rename class customer to Customer instead of a generic Convert first letter to upper-case ). Moreover, the do (body) part is a statement block where the fixing functionality can be defined using EOL. The developer is responsible for ensuring that the actions contained in the fix actually repair the identified inconsistency. Critique \u00b6 Critiques are constraints that are used to capture non-critical issues that do not invalidate the model, but should nevertheless be addressed by the user to enhance the quality of the model. Pre and Post \u00b6 An EVL module can define a number of named pre and a post blocks that contain EOL statements which are executed before and after evaluating the constraints respectively. These should not be confused with the pre-/post-condition annotations available for EOL user-defined operations. Concrete Syntax \u00b6 The following listing demonstrates the concrete sytnax of the context , constraint and fix abstract syntax constructs discussed above. (@lazy)? context <name> { (guard (:expression)|({statementBlock}))? (constraint)* } ((@lazy)? (constraint|critique) <name> { (guard (:expression)|({statementBlock}))? (check (:expression)|({statementBlock}))? (message (:expression)|({statementBlock}))? (fix)* } fix { (guard (:expression)|({statementBlock}))? (title (:expression)|({statementBlock})) do { statementBlock } } Pre and post blocks have a simple syntax that, as presented in the listing below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ } Execution Semantics \u00b6 Having discussed the abstract and concrete syntaxes of EVL, this section provides an informal discussion of the execution semantics of the language. The execution of an EVL module is separated into four phases: Phase 1 \u00b6 Before any constraint is evaluated, the pre blocks of the module are executed in the order in which they have been specified. Phase 2 \u00b6 For each non-lazy context with at least one non-lazy constraint, the instances of the meta-class it defines are collected. For each instance, the guard of the context is evaluated. If the guard is satisfied, then for each non-lazy constraint contained in the context the constraint's guard is also evaluated. If the guard of the constraint is satisfied, the body of the constraint is evaluated. In case the body evaluates to false , the message part of the rule is evaluated and the produced message is added along with the instance, the constraint and the available fixes to the ValidationTrace . The execution order of an EVL module follows a top-down depth-first scheme that respects the order in which the contexts and constraints appear in the module. However, the execution order can change in case one of the satisfies , satisfiesOne , satisfiesAll built-in operations, discussed in detail in the sequel, are called. Phase 3 \u00b6 In this phase, the validation trace is examined for unsatisfied constraints and the user is presented with the message each one has produced. The user can then select one or more of the available fixes to be executed. Execution of fixes is performed in a transactional manner using the respective facilities provided by the model connectivity framework. This is to prevent runtime errors raised during the execution of a fix from compromising the validated model by leaving it in an inconsistent state. Phase 4 \u00b6 When the user has performed all the necessary fixes or chooses to end Phase 3 explicitly, the post section of the module is executed. There, the user can perform tasks such as serializing the validation trace or producing a summary of the validation process results. Capturing Dependencies between Constraints \u00b6 It is often the case that constraints conceptually depend on each other. To allow users capture such dependencies, EVL provides the satisfies(constraint : String) : Boolean , satisfiesAll(constraints : Sequence(String)) : Boolean and satisfiesOne(constraints : Sequence(String)) : Boolean built-in operations. Using these operations, an constraint can specify in its guard other constraints which need to be satisfied for it to be meaningful to evaluate. When one of these operations is invoked, if the required constraints (either lazy or non-lazy) have been evaluated for the instances on which the operation is invoked, the engine will return their cached results; otherwise it will evaluate them and return their results. Example \u00b6 The following is an EVL program demonstrating some of the language features, which validates models confirming to the Movies metamodel shown below. Execution begins from the pre block, which simply computes the average number of actors per Movie and stores it into a global variable, which can be accessed at any point. The ValidActors constraint checks that for every instance of Movie which has more than the average number of actors, all of the actors have valid names. This is achieved through a dependency on the HashValidName invariant declared in the context of Person type. This constraint is marked as lazy, which means it is only executed when invoked by satisfies , so avoiding unnecessary or duplicate invocations. The HasValidName constraint makes use of a helper operation ( isPlain() ) on Strings. Once all Movie instances have been checked, the execution engine then proceeds to validate all Person instances, which consists of only one non-lazy constraint ValidMovieYears . This checks that all of the movies the actor has played in were released at least 3 years after the actor was born. Finally, the post block is executed, which in this case simply prints some basic information about the model. classDiagram class Movie { -title: String -rating: Double -year: Int } class Person { -name: String -birthYear: Int } Movie -- Person: movies * / persons * pre { var numMovies = Movie.all.size(); var numActors = Person.all.size(); var apm = numActors / numMovies; } context Movie { constraint ValidActors { guard : self.persons.size() > apm check : self.persons.forAll(p | p.satisfies(\"HasValidName\")) } } context Person { @lazy constraint HasValidName { check : self.name.isPlain() } constraint ValidMovieYears { check : self.movies.forAll(m | m.year + 1 > self.birthYear) } } operation String isPlain() : Boolean { return self.matches(\"[A-Za-z\\\\s]+\"); } post { (\"Actors per Movie=\"+apm).println(); (\"# Movies=\"+numMovies).println(); (\"# Actors=\"+numActors).println(); } Additional Resources \u00b6 Additional resources about EVL are available here .","title":"Model Validation (EVL)"},{"location":"doc/evl/#the-epsilon-validation-language-evl","text":"EVL contributes model validation capabilities to Epsilon. More specifically, EVL can be used to specify and evaluate constraints and critiques on models of arbitrary metamodels and modelling technologies, and to produce human-readable error messages and executable quick fixes. Try EVL online You can run and fiddle with EVL constraints that validate a project scheduling model in the online Epsilon Playground .","title":"The Epsilon Validation Language (EVL)"},{"location":"doc/evl/#abstract-syntax","text":"In EVL, validation specifications are organized in modules ( EvlModule ). As illustrated in the figure below, EvlModule (indirectly) extends EolModule which means that it can contain user-defined operations and import other EOL library modules and EVL modules. Apart from operations, an EVL module also contains a set of constraints grouped by the context they apply to, and, by extending ErlModule , a number of pre and post blocks. Info As with most languages in Epsilon, EVL uses EOL as its expression language. This page only documents the additional syntax and semantics that EVL provides on top of EOL. classDiagram class Constraint { -name: String -guard: ExecutableBlock<Boolean> -check: ExecutableBlock<Boolean> -message: ExecutableBlock<String> -isCritique: boolean } class ConstraintContext { -type: EolModelElementType -guard: ExecutableBlock<Boolean> } class NamedStatementBlockRule { -name: String -body: StatementBlock } class Fix { -guard: ExecutableBlock<Boolean> -title: ExecutableBlock<String> -body: ExecutableBlock<Void> } EolModule <|-- ErlModule EvlModule --|> ErlModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * EvlModule -- ConstraintContext: contexts * ConstraintContext -- Constraint: constraints * Constraint -- Fix: fixes *","title":"Abstract Syntax"},{"location":"doc/evl/#context","text":"A context specifies the kind of instances on which the contained constraints will be evaluated. Each context can optionally define a guard which limits its applicability to a narrower subset of instances of its specified type. Thus, if the guard fails for a specific instance of the type, none of its contained constraints are evaluated.","title":"Context"},{"location":"doc/evl/#constraint","text":"As with OCL, each EVL constraint defines a name and a body ( check ). However, it can optionally also define a guard which further limits its applicability to a subset of the instances of the type defined by the embracing context . Each constraint can optionally define a message as an ExecutableBlock that should return a String providing a description of the reason(s) for which the constraint has failed on a particular element. A constraint can also optionally define a number of fixes . Finally, as displayed in the figure above, constraint is an abstract class that is used as a super-class for the specific types Constraint and Critique .","title":"Constraint"},{"location":"doc/evl/#guard","text":"Guards are used to limit the applicability of constraints. This can be achieved at two levels. At the Context level it limits the applicability of all constraints of the context and at the Constraint level it limits the applicability of a specific constraint.","title":"Guard"},{"location":"doc/evl/#fix","text":"A fix defines a title using an ExecutableBlock instead of a static String to allow users to specify context-aware titles (e.g. Rename class customer to Customer instead of a generic Convert first letter to upper-case ). Moreover, the do (body) part is a statement block where the fixing functionality can be defined using EOL. The developer is responsible for ensuring that the actions contained in the fix actually repair the identified inconsistency.","title":"Fix"},{"location":"doc/evl/#critique","text":"Critiques are constraints that are used to capture non-critical issues that do not invalidate the model, but should nevertheless be addressed by the user to enhance the quality of the model.","title":"Critique"},{"location":"doc/evl/#pre-and-post","text":"An EVL module can define a number of named pre and a post blocks that contain EOL statements which are executed before and after evaluating the constraints respectively. These should not be confused with the pre-/post-condition annotations available for EOL user-defined operations.","title":"Pre and Post"},{"location":"doc/evl/#concrete-syntax","text":"The following listing demonstrates the concrete sytnax of the context , constraint and fix abstract syntax constructs discussed above. (@lazy)? context <name> { (guard (:expression)|({statementBlock}))? (constraint)* } ((@lazy)? (constraint|critique) <name> { (guard (:expression)|({statementBlock}))? (check (:expression)|({statementBlock}))? (message (:expression)|({statementBlock}))? (fix)* } fix { (guard (:expression)|({statementBlock}))? (title (:expression)|({statementBlock})) do { statementBlock } } Pre and post blocks have a simple syntax that, as presented in the listing below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ }","title":"Concrete Syntax"},{"location":"doc/evl/#execution-semantics","text":"Having discussed the abstract and concrete syntaxes of EVL, this section provides an informal discussion of the execution semantics of the language. The execution of an EVL module is separated into four phases:","title":"Execution Semantics"},{"location":"doc/evl/#phase-1","text":"Before any constraint is evaluated, the pre blocks of the module are executed in the order in which they have been specified.","title":"Phase 1"},{"location":"doc/evl/#phase-2","text":"For each non-lazy context with at least one non-lazy constraint, the instances of the meta-class it defines are collected. For each instance, the guard of the context is evaluated. If the guard is satisfied, then for each non-lazy constraint contained in the context the constraint's guard is also evaluated. If the guard of the constraint is satisfied, the body of the constraint is evaluated. In case the body evaluates to false , the message part of the rule is evaluated and the produced message is added along with the instance, the constraint and the available fixes to the ValidationTrace . The execution order of an EVL module follows a top-down depth-first scheme that respects the order in which the contexts and constraints appear in the module. However, the execution order can change in case one of the satisfies , satisfiesOne , satisfiesAll built-in operations, discussed in detail in the sequel, are called.","title":"Phase 2"},{"location":"doc/evl/#phase-3","text":"In this phase, the validation trace is examined for unsatisfied constraints and the user is presented with the message each one has produced. The user can then select one or more of the available fixes to be executed. Execution of fixes is performed in a transactional manner using the respective facilities provided by the model connectivity framework. This is to prevent runtime errors raised during the execution of a fix from compromising the validated model by leaving it in an inconsistent state.","title":"Phase 3"},{"location":"doc/evl/#phase-4","text":"When the user has performed all the necessary fixes or chooses to end Phase 3 explicitly, the post section of the module is executed. There, the user can perform tasks such as serializing the validation trace or producing a summary of the validation process results.","title":"Phase 4"},{"location":"doc/evl/#capturing-dependencies-between-constraints","text":"It is often the case that constraints conceptually depend on each other. To allow users capture such dependencies, EVL provides the satisfies(constraint : String) : Boolean , satisfiesAll(constraints : Sequence(String)) : Boolean and satisfiesOne(constraints : Sequence(String)) : Boolean built-in operations. Using these operations, an constraint can specify in its guard other constraints which need to be satisfied for it to be meaningful to evaluate. When one of these operations is invoked, if the required constraints (either lazy or non-lazy) have been evaluated for the instances on which the operation is invoked, the engine will return their cached results; otherwise it will evaluate them and return their results.","title":"Capturing Dependencies between Constraints"},{"location":"doc/evl/#example","text":"The following is an EVL program demonstrating some of the language features, which validates models confirming to the Movies metamodel shown below. Execution begins from the pre block, which simply computes the average number of actors per Movie and stores it into a global variable, which can be accessed at any point. The ValidActors constraint checks that for every instance of Movie which has more than the average number of actors, all of the actors have valid names. This is achieved through a dependency on the HashValidName invariant declared in the context of Person type. This constraint is marked as lazy, which means it is only executed when invoked by satisfies , so avoiding unnecessary or duplicate invocations. The HasValidName constraint makes use of a helper operation ( isPlain() ) on Strings. Once all Movie instances have been checked, the execution engine then proceeds to validate all Person instances, which consists of only one non-lazy constraint ValidMovieYears . This checks that all of the movies the actor has played in were released at least 3 years after the actor was born. Finally, the post block is executed, which in this case simply prints some basic information about the model. classDiagram class Movie { -title: String -rating: Double -year: Int } class Person { -name: String -birthYear: Int } Movie -- Person: movies * / persons * pre { var numMovies = Movie.all.size(); var numActors = Person.all.size(); var apm = numActors / numMovies; } context Movie { constraint ValidActors { guard : self.persons.size() > apm check : self.persons.forAll(p | p.satisfies(\"HasValidName\")) } } context Person { @lazy constraint HasValidName { check : self.name.isPlain() } constraint ValidMovieYears { check : self.movies.forAll(m | m.year + 1 > self.birthYear) } } operation String isPlain() : Boolean { return self.matches(\"[A-Za-z\\\\s]+\"); } post { (\"Actors per Movie=\"+apm).println(); (\"# Movies=\"+numMovies).println(); (\"# Actors=\"+numActors).println(); }","title":"Example"},{"location":"doc/evl/#additional-resources","text":"Additional resources about EVL are available here .","title":"Additional Resources"},{"location":"doc/ewl/","text":"The Epsilon Wizard Language (EWL) \u00b6 There are two types of model-to-model transformations: mapping and update transformations. Mapping transformations typically transform a source model into a set of target models expressed in (potentially) different modelling languages by creating zero or more model elements in the target models for each model element of the source model. By contrast, update transformations perform in-place modifications in the source model itself. They can be further classified into two subcategories: transformations in the small and in the large. Update transformations in the large apply to sets of model elements calculated using well-defined rules in a batch manner. An example of this category of transformations is a transformation that automatically adds accessor and mutator operations for all attributes in a UML model. On the other hand, update transformations in the small are applied in a user-driven manner on model elements that have been explicitly selected by the user. An example of this kind of transformations is a transformation that renames a user-specified UML class and all its incoming associations consistently. In Epsilon, mapping transformations can be specified using ETL , and update transformations in the large can be implemented either using the model modification features of EOL or using an ETL transformation in which the source and target models are the same model. By contrast, update transformations in the small cannot be effectively addressed by any of the languages presented so far. The following section discusses the importance of update transformations in the small and motivates the definition of a task-specific language (Epsilon Wizard Language (EWL)) that provides tailored and effective support for defining and executing update transformations on models of diverse metamodels. Motivation \u00b6 Constructing and refactoring models is undoubtedly a mentally intensive process. However, during modelling, recurring patterns of model update activities typically appear. As an example, when renaming a class in a UML class diagram, the user also needs to manually update the names of association ends that link to the renamed class. Thus, when renaming a class from Chapter to Section , all associations ends that point to the class and are named chapter or chapters should be also renamed to section and sections respectively. As another example, when a modeller needs to refactor a UML class into a singleton [@Larman], they need to go through a number of well-defined, but trivial, steps such as attaching a stereotype ( <<singleton>> ), defining a static instance attribute and adding a static getInstance() method that returns the unique instance of the singleton. It is generally accepted that performing repetitive tasks manually is both counter-productive and error-prone. On the other hand, failing to complete such tasks correctly and precisely compromises the consistency, and thus the quality, of the models. In Model Driven Engineering, this is particularly important since models are increasingly used to automatically produce (parts of) working systems. Automating the Construction and Refactoring Process \u00b6 Contemporary modelling tools provide built-in transformations ( wizards ) for automating common repetitive tasks. However, according to the architecture of the designed system and the specific problem domain, additional repetitive tasks typically appear, which cannot be addressed by the pre-conceived built-in wizards of a modelling tool. To address the automation problem in its general case, users must be able to easily define update transformations (wizards) that are tailored to their specific needs. To an extent, this can be achieved via the extensible architecture that state-of-the-art modelling tools often provide which enables users to add functionality to the tool via scripts or application code using the implementation language of the tool. Nevertheless, the majority of modelling tools provide an API through which they expose an edited model, which requires significant effort to learn and use. Also, since each API is proprietary, such scripts and extensions are not portable to other tools. Finally, API scripting languages and third-generation languages such as Java and C++ are not particularly suitable for model navigation and modification. Furthermore, existing languages for mapping transformations, such as QVT, ATL and ETL, cannot be used as-is for this purpose, because these languages have been designed to operate in a batch manner without human involvement in the process. By contrast, as discussed above, the task of constructing and refactoring models is inherently user-driven. Update Transformations in the Small \u00b6 Update transformations are actions that automatically create, update or delete model elements based on a selection of existing elements in the model and information obtained otherwise (e.g. through user input), in a user-driven fashion. In this section, such actions are referred to as wizards instead of rules to reduce confusion between them and rules of mapping transformation languages. In the following sections, the desirable characteristics of wizards are elaborated informally. Structure of Wizards \u00b6 In its simplest form, a wizard only needs to define the actions it will perform when it is applied to a selection of model elements. The structure of such a wizard that transforms a UML class into a singleton is shown using pseudo-code in the listing below. do : attach the singleton stereotype create the instance attribute create the getInstance method Since not all wizards apply to all types of elements in the model, each wizard needs to specify the types of elements to which it applies. For example, the wizard of the listing above, which automatically transforms a class into a singleton, applies only when the selected model element is a class. The simplest approach to ensuring that the wizard will only be applied on classes is to enclose its body in an if condition as shown in the listing below. do : if (selected element is a class) { attach the singleton stereotype create the instance attribute create the getInstance method } A more modular approach is to separate this condition from the body of the wizard. This is shown in the listing below where the condition of the wizard is specified as a separate guard stating that the wizard applies only to elements of type Class. The latter is preferable since it enables filtering out wizards that are not applicable to the current selection of elements by evaluating only their guard parts and rejecting those that return false . Thus, at any time, the user can be provided with only the wizards that are applicable to the current selection of elements. Filtering out irrelevant wizards reduces confusion and enhances usability, particularly as the list of specified wizards grows. guard : selected element is a class do : attach the singleton stereotype create the instance attribute create the getInstance method To enhance usability, a wizard also needs to define a short human-readable description of its functionality. To achieve this, another field named title has been added. There are two options for defining the title of a wizard: the first is to use a static string and the second to use a dynamic expression. The latter is preferable since it enables definition of context-aware titles. guard : selected element is a class title : Convert class <class-name> into a singleton do : attach the singleton stereotype create the instance attribute create the getInstance method Capabilities of Wizards \u00b6 The guard and title parts of a wizard need to be expressed using a language that provides model querying and navigation facilities. Moreover, the do part also requires model modification capabilities to implement the transformation. To achieve complex transformations, it is essential that the user can provide additional information. For instance, to implement a wizard that addresses the class renaming scenario, the information provided by the selected class does not suffice; the user must also provide the new name of the class. Therefore, EWL must also provide mechanisms for capturing user input. Abstract Syntax \u00b6 Since EWL is built atop Epsilon, its abstract and concrete syntax need only to define the concepts that are relevant to the task it addresses; they can reuse lower-level constructs from EOL. A graphical overview of the abstract syntax of the language is provided in the figure below. The basic concept of the EWL abstract syntax is a Wizard . A wizard defines a name , a guard part, a title part and a $do$ part. Wizards are organized in Modules . The name of a wizard acts as an identifier and must be unique in the context of a module. The guard and title parts of a wizard are of type ExpressionOrStatementBlock , inherited from EOL. An ExpressionOrStatementBlock is either a single EOL expression or a block of EOL statements that include one or more return statements. This construct allows users to express simple declarative calculations as single expressions and complex calculations as blocks of imperative statements. Finally, the do part of the wizard is a block of EOL statements that specify the effects of the wizard when applied to a compatible selection of model elements. Concrete Syntax \u00b6 The following listing presents the concrete syntax of EWL wizards. wizard <name> { (guard (:expression)|({statementBlock}))? (title (:expression)|({statementBlock}))? do { statementBlock } } Execution Semantics \u00b6 The process of executing EWL wizards is inherently user-driven and as such it depends on the environment in which they are used. In general, each time the selection of model elements changes (i.e. the user selects or deselects a model element in the modelling tool), the guards of all wizards are evaluated. If the guard of a wizard is satisfied, the title part is also evaluated and the wizard is added to a list of applicable wizards. Then, the user can select a wizard and execute its do part to perform the intended transformation. In EWL, variables defined and initialized in the guard part of the wizard can be accessed both by the title and the do parts. In this way, results of calculations performed in the guard part can be re-used, instead of re-calculated in the subsequent parts. The practicality of this approach is discussed in more detail in the examples that follow. Also, the execution of the do part of each wizard is performed in a transactional mode by exploiting the transaction capabilities of the underlying model connectivity framework, so that possible logical errors in the do part of a wizard do not leave the edited model in an inconsistent state. Examples \u00b6 This section presents three concrete examples of EWL wizards for refactoring UML 1.4 models. The aim of this section is not to provide complete implementations that address all the sub-cases of each scenario but to provide enhanced understanding of the concrete syntax, the features and the capabilities of EWL to the reader. Moreover, it should be stressed again that although the examples in this section are based on UML models, by building on Epsilon, EWL can be used to capture wizards for diverse modelling languages and technologies. Converting a Class into a Singleton \u00b6 The singleton pattern is applied when there is a class for which only one instance can exist at a time. In terms of UML, a singleton is a class stereotyped with the <<singleton>> stereotype, and it defines a static attribute named instance which holds the value of the unique instance. It also defines a static getInstance() operation that returns that unique instance. Wizard ClassToSingleton , presented below, simplifies the process of converting a class into a singleton by adding the proper stereotype, attribute and operation to it automatically. wizard ClassToSingleton { // The wizard applies when a class is selected guard : self.isTypeOf(Class) title : \"Convert \" + self.name + \" to a singleton\" do { // Create the getInstance() operation var gi : new Operation; gi.owner = self; gi.name = \"getInstance\"; gi.visibility = VisibilityKind#vk_public; gi.ownerScope = ScopeKind#sk_classifier; // Create the return parameter of the operation var ret : new Parameter; ret.type = self; ret.kind = ParameterDirectionKind#pdk_return; gi.parameter = Sequence{ret}; // Create the instance field var ins : new Attribute; ins.name = \"instance\"; ins.type = self; ins.visibility = VisibilityKind#vk_private; ins.ownerScope = ScopeKind#sk_classifier; ins.owner = self; // Attach the <<singleton>> stereotype self.attachStereotype(\"singleton\"); } } // Attaches a stereotype with the specified name // to the Model Element on which it is invoked operation ModelElement attachStereotype(name : String) { var stereotype : Stereotype; // Try to find an existing stereotype with this name stereotype = Stereotype.allInstances.selectOne(s|s.name = name); // If there is no existing stereotype // with that name, create one if (not stereotype.isDefined()){ stereotype = Stereotype.createInstance(); stereotype.name = name; stereotype.namespace = self.namespace; } // Attach the stereotype to the model element self.stereotype.add(stereotype); } The guard part of the wizard specifies that it is only applicable when the selection is a single UML class. The title part specifies a context-aware title that informs the user of the functionality of the wizard and the do part implements the functionality by adding the getInstance operation (lines 10-14), the instance attribute (lines 23-28) and the <<singleton>> stereotype (line 31). The stereotype is added via a call to the attachStereotype() operation. Attaching a stereotype is a very common action when refactoring UML models, particularly where UML profiles are involved, and therefore to avoid duplication, this reusable operation that checks for an existing stereotype, creates it if it does not already exists, and attaches it to the model element on which it is invoked has been specified. An extended version of this wizard could also check for existing association ends that link to the class and for which the upper-bound of their multiplicity is greater than one and either disallow the wizard from executing on such classes (in the guard part) or update the upper-bound of their multiplicities to one (in the do part). However, the aim of this section is not to implement complete wizards that address all sub-cases but to provide a better understanding of the concrete syntax and the features of EWL. This principle also applies to the examples presented in the sequel. Renaming a Class \u00b6 The most widely used convention for naming attributes and association ends of a given class is to use a lower-case version of the name of the class as the name of the attribute or the association end. For instance, the two ends of a one-to-many association that links classes Book and Chapter are most likely to be named book and chapters respectively. When renaming a class (e.g. from Chapter to Section ) the user must then manually traverse the model to find all attributes and association ends of this type and update their names (i.e. from chapter or bookChapter to section and bookSection respectively). This can be a daunting process especially in the context of large models. Wizard RenameClass presented in the listing below automates this process. wizard RenameClass { // The wizard applies when a Class is selected guard : self.isKindOf(Class) title : \"Rename class \" + self.name do { var newName : String; // Prompt the user for the new name of the class newName = UserInput.prompt(\"New name for class \" + self.name); if (newName.isDefined()) { var affectedElements : Sequence; // Collect the AssociationEnds and Attributes // that are affected by the rename affectedElements.addAll( AssociationEnd.allInstances.select(ae|ae.participant=self)); affectedElements.addAll( Attribute.allInstances.select(a|a.type = self)); var oldNameToLower : String; oldNameToLower = self.name.firstToLowerCase(); var newNameToLower : String; newNameToLower = newName.firstToLowerCase(); // Update the names of the affected AssociationEnds // and Attributes for (ae in affectedElements) { ae.replaceInName(oldNameToLower, newNameToLower); ae.replaceInName(self.name, newName); } self.name = newName; } } } // Renames the ModelElement on which it is invoked operation ModelElement replaceInName (oldString : String, newString : String) { if (oldString.isSubstringOf(self.name)) { // Calculate the new name var newName : String; newName = self.name.replace(oldString, newString); // Prompt the user for confirmation of the rename if (UserInput.confirm (\"Rename \" + self.name + \" to \" + newName + \"?\")) { // Perform the rename self.name = newName; } } } As with the ClassToSingleton wizard, the guard part of RenameClass specifies that the wizard is applicable only when the selection is a simple class and the title provides a context-aware description of the functionality of the wizard. The information provided by the selected class itself does not suffice in the case of renaming since the new name of the class is not specified anywhere in the existing model. In EWL, and in all languages that build on EOL, user input can be obtained using the built-in UserInput facility. Thus, in line 12 the user is prompted for the new name of the class using the UserInput.prompt() operation. Then, all the association ends and attributes that refer to the class are collected in the affectedElements sequence (lines 14-21). Using the replaceInName operation (lines 31 and 32), the name of each one is examined for a substring of the upper-case or the lower-case version of the old name of the class. In case the check returns true, the user is prompted to confirm (line 48) that the feature needs to be renamed. This further highlights the importance of user input for implementing update transformations with fine-grained user control. Moving Model Elements into a Different Package \u00b6 A common refactoring when modelling in UML is to move model elements, particularly Classes, between different packages. When moving a pair of classes from one package to another, the associations that connect them must also be moved to the target package. To automate this process, the listing below presents the MoveToPackage wizard. wizard MoveToPackage { // The wizard applies when a Collection of // elements, including at least one Package // is selected guard { var moveTo : Package; if (self.isKindOf(Collection)) { moveTo = self.select(e|e.isKindOf(Package)).last(); } return moveTo.isDefined(); } title : \"Move \" + (self.size()-1) + \" elements to \" + moveTo.name do { // Move the selected Model Elements to the // target package for (me in self.excluding(moveTo)) { me.namespace = moveTo; } // Move the Associations connecting any // selected Classes to the target package for (a in Association.allInstances) { if (a.connection.forAll(c|self.includes(c.participant))){ a.namespace = moveTo; } } } } The wizard applies when more than one element is selected and at least one of the elements is a Package . If more than one package is selected, the last one is considered as the target package to which the rest of the selected elements will be moved. This is specified in the guard part of the wizard. To reduce user confusion in identifying the package to which the elements will be moved, the name of the target package appears in the title of the wizard. This example shows the importance of the decision to express the title as a dynamically calculated expression (as opposed to a static string). It is worth noting that in the title part of the wizard (line 14), the moveTo variable declared in the guard (line 7) is referenced. Through experimenting with a number of wizards, it has been noticed that in complex wizards repeated calculations need to be performed in the guard , title and do parts of the wizard. To eliminate this duplication, the scope of variables defined in the guard part has been extended so that they are also accessible from the title and do part of the wizard.","title":"Wizard Language (EWL)"},{"location":"doc/ewl/#the-epsilon-wizard-language-ewl","text":"There are two types of model-to-model transformations: mapping and update transformations. Mapping transformations typically transform a source model into a set of target models expressed in (potentially) different modelling languages by creating zero or more model elements in the target models for each model element of the source model. By contrast, update transformations perform in-place modifications in the source model itself. They can be further classified into two subcategories: transformations in the small and in the large. Update transformations in the large apply to sets of model elements calculated using well-defined rules in a batch manner. An example of this category of transformations is a transformation that automatically adds accessor and mutator operations for all attributes in a UML model. On the other hand, update transformations in the small are applied in a user-driven manner on model elements that have been explicitly selected by the user. An example of this kind of transformations is a transformation that renames a user-specified UML class and all its incoming associations consistently. In Epsilon, mapping transformations can be specified using ETL , and update transformations in the large can be implemented either using the model modification features of EOL or using an ETL transformation in which the source and target models are the same model. By contrast, update transformations in the small cannot be effectively addressed by any of the languages presented so far. The following section discusses the importance of update transformations in the small and motivates the definition of a task-specific language (Epsilon Wizard Language (EWL)) that provides tailored and effective support for defining and executing update transformations on models of diverse metamodels.","title":"The Epsilon Wizard Language (EWL)"},{"location":"doc/ewl/#motivation","text":"Constructing and refactoring models is undoubtedly a mentally intensive process. However, during modelling, recurring patterns of model update activities typically appear. As an example, when renaming a class in a UML class diagram, the user also needs to manually update the names of association ends that link to the renamed class. Thus, when renaming a class from Chapter to Section , all associations ends that point to the class and are named chapter or chapters should be also renamed to section and sections respectively. As another example, when a modeller needs to refactor a UML class into a singleton [@Larman], they need to go through a number of well-defined, but trivial, steps such as attaching a stereotype ( <<singleton>> ), defining a static instance attribute and adding a static getInstance() method that returns the unique instance of the singleton. It is generally accepted that performing repetitive tasks manually is both counter-productive and error-prone. On the other hand, failing to complete such tasks correctly and precisely compromises the consistency, and thus the quality, of the models. In Model Driven Engineering, this is particularly important since models are increasingly used to automatically produce (parts of) working systems.","title":"Motivation"},{"location":"doc/ewl/#automating-the-construction-and-refactoring-process","text":"Contemporary modelling tools provide built-in transformations ( wizards ) for automating common repetitive tasks. However, according to the architecture of the designed system and the specific problem domain, additional repetitive tasks typically appear, which cannot be addressed by the pre-conceived built-in wizards of a modelling tool. To address the automation problem in its general case, users must be able to easily define update transformations (wizards) that are tailored to their specific needs. To an extent, this can be achieved via the extensible architecture that state-of-the-art modelling tools often provide which enables users to add functionality to the tool via scripts or application code using the implementation language of the tool. Nevertheless, the majority of modelling tools provide an API through which they expose an edited model, which requires significant effort to learn and use. Also, since each API is proprietary, such scripts and extensions are not portable to other tools. Finally, API scripting languages and third-generation languages such as Java and C++ are not particularly suitable for model navigation and modification. Furthermore, existing languages for mapping transformations, such as QVT, ATL and ETL, cannot be used as-is for this purpose, because these languages have been designed to operate in a batch manner without human involvement in the process. By contrast, as discussed above, the task of constructing and refactoring models is inherently user-driven.","title":"Automating the Construction and Refactoring Process"},{"location":"doc/ewl/#update-transformations-in-the-small","text":"Update transformations are actions that automatically create, update or delete model elements based on a selection of existing elements in the model and information obtained otherwise (e.g. through user input), in a user-driven fashion. In this section, such actions are referred to as wizards instead of rules to reduce confusion between them and rules of mapping transformation languages. In the following sections, the desirable characteristics of wizards are elaborated informally.","title":"Update Transformations in the Small"},{"location":"doc/ewl/#structure-of-wizards","text":"In its simplest form, a wizard only needs to define the actions it will perform when it is applied to a selection of model elements. The structure of such a wizard that transforms a UML class into a singleton is shown using pseudo-code in the listing below. do : attach the singleton stereotype create the instance attribute create the getInstance method Since not all wizards apply to all types of elements in the model, each wizard needs to specify the types of elements to which it applies. For example, the wizard of the listing above, which automatically transforms a class into a singleton, applies only when the selected model element is a class. The simplest approach to ensuring that the wizard will only be applied on classes is to enclose its body in an if condition as shown in the listing below. do : if (selected element is a class) { attach the singleton stereotype create the instance attribute create the getInstance method } A more modular approach is to separate this condition from the body of the wizard. This is shown in the listing below where the condition of the wizard is specified as a separate guard stating that the wizard applies only to elements of type Class. The latter is preferable since it enables filtering out wizards that are not applicable to the current selection of elements by evaluating only their guard parts and rejecting those that return false . Thus, at any time, the user can be provided with only the wizards that are applicable to the current selection of elements. Filtering out irrelevant wizards reduces confusion and enhances usability, particularly as the list of specified wizards grows. guard : selected element is a class do : attach the singleton stereotype create the instance attribute create the getInstance method To enhance usability, a wizard also needs to define a short human-readable description of its functionality. To achieve this, another field named title has been added. There are two options for defining the title of a wizard: the first is to use a static string and the second to use a dynamic expression. The latter is preferable since it enables definition of context-aware titles. guard : selected element is a class title : Convert class <class-name> into a singleton do : attach the singleton stereotype create the instance attribute create the getInstance method","title":"Structure of Wizards"},{"location":"doc/ewl/#capabilities-of-wizards","text":"The guard and title parts of a wizard need to be expressed using a language that provides model querying and navigation facilities. Moreover, the do part also requires model modification capabilities to implement the transformation. To achieve complex transformations, it is essential that the user can provide additional information. For instance, to implement a wizard that addresses the class renaming scenario, the information provided by the selected class does not suffice; the user must also provide the new name of the class. Therefore, EWL must also provide mechanisms for capturing user input.","title":"Capabilities of Wizards"},{"location":"doc/ewl/#abstract-syntax","text":"Since EWL is built atop Epsilon, its abstract and concrete syntax need only to define the concepts that are relevant to the task it addresses; they can reuse lower-level constructs from EOL. A graphical overview of the abstract syntax of the language is provided in the figure below. The basic concept of the EWL abstract syntax is a Wizard . A wizard defines a name , a guard part, a title part and a $do$ part. Wizards are organized in Modules . The name of a wizard acts as an identifier and must be unique in the context of a module. The guard and title parts of a wizard are of type ExpressionOrStatementBlock , inherited from EOL. An ExpressionOrStatementBlock is either a single EOL expression or a block of EOL statements that include one or more return statements. This construct allows users to express simple declarative calculations as single expressions and complex calculations as blocks of imperative statements. Finally, the do part of the wizard is a block of EOL statements that specify the effects of the wizard when applied to a compatible selection of model elements.","title":"Abstract Syntax"},{"location":"doc/ewl/#concrete-syntax","text":"The following listing presents the concrete syntax of EWL wizards. wizard <name> { (guard (:expression)|({statementBlock}))? (title (:expression)|({statementBlock}))? do { statementBlock } }","title":"Concrete Syntax"},{"location":"doc/ewl/#execution-semantics","text":"The process of executing EWL wizards is inherently user-driven and as such it depends on the environment in which they are used. In general, each time the selection of model elements changes (i.e. the user selects or deselects a model element in the modelling tool), the guards of all wizards are evaluated. If the guard of a wizard is satisfied, the title part is also evaluated and the wizard is added to a list of applicable wizards. Then, the user can select a wizard and execute its do part to perform the intended transformation. In EWL, variables defined and initialized in the guard part of the wizard can be accessed both by the title and the do parts. In this way, results of calculations performed in the guard part can be re-used, instead of re-calculated in the subsequent parts. The practicality of this approach is discussed in more detail in the examples that follow. Also, the execution of the do part of each wizard is performed in a transactional mode by exploiting the transaction capabilities of the underlying model connectivity framework, so that possible logical errors in the do part of a wizard do not leave the edited model in an inconsistent state.","title":"Execution Semantics"},{"location":"doc/ewl/#examples","text":"This section presents three concrete examples of EWL wizards for refactoring UML 1.4 models. The aim of this section is not to provide complete implementations that address all the sub-cases of each scenario but to provide enhanced understanding of the concrete syntax, the features and the capabilities of EWL to the reader. Moreover, it should be stressed again that although the examples in this section are based on UML models, by building on Epsilon, EWL can be used to capture wizards for diverse modelling languages and technologies.","title":"Examples"},{"location":"doc/ewl/#converting-a-class-into-a-singleton","text":"The singleton pattern is applied when there is a class for which only one instance can exist at a time. In terms of UML, a singleton is a class stereotyped with the <<singleton>> stereotype, and it defines a static attribute named instance which holds the value of the unique instance. It also defines a static getInstance() operation that returns that unique instance. Wizard ClassToSingleton , presented below, simplifies the process of converting a class into a singleton by adding the proper stereotype, attribute and operation to it automatically. wizard ClassToSingleton { // The wizard applies when a class is selected guard : self.isTypeOf(Class) title : \"Convert \" + self.name + \" to a singleton\" do { // Create the getInstance() operation var gi : new Operation; gi.owner = self; gi.name = \"getInstance\"; gi.visibility = VisibilityKind#vk_public; gi.ownerScope = ScopeKind#sk_classifier; // Create the return parameter of the operation var ret : new Parameter; ret.type = self; ret.kind = ParameterDirectionKind#pdk_return; gi.parameter = Sequence{ret}; // Create the instance field var ins : new Attribute; ins.name = \"instance\"; ins.type = self; ins.visibility = VisibilityKind#vk_private; ins.ownerScope = ScopeKind#sk_classifier; ins.owner = self; // Attach the <<singleton>> stereotype self.attachStereotype(\"singleton\"); } } // Attaches a stereotype with the specified name // to the Model Element on which it is invoked operation ModelElement attachStereotype(name : String) { var stereotype : Stereotype; // Try to find an existing stereotype with this name stereotype = Stereotype.allInstances.selectOne(s|s.name = name); // If there is no existing stereotype // with that name, create one if (not stereotype.isDefined()){ stereotype = Stereotype.createInstance(); stereotype.name = name; stereotype.namespace = self.namespace; } // Attach the stereotype to the model element self.stereotype.add(stereotype); } The guard part of the wizard specifies that it is only applicable when the selection is a single UML class. The title part specifies a context-aware title that informs the user of the functionality of the wizard and the do part implements the functionality by adding the getInstance operation (lines 10-14), the instance attribute (lines 23-28) and the <<singleton>> stereotype (line 31). The stereotype is added via a call to the attachStereotype() operation. Attaching a stereotype is a very common action when refactoring UML models, particularly where UML profiles are involved, and therefore to avoid duplication, this reusable operation that checks for an existing stereotype, creates it if it does not already exists, and attaches it to the model element on which it is invoked has been specified. An extended version of this wizard could also check for existing association ends that link to the class and for which the upper-bound of their multiplicity is greater than one and either disallow the wizard from executing on such classes (in the guard part) or update the upper-bound of their multiplicities to one (in the do part). However, the aim of this section is not to implement complete wizards that address all sub-cases but to provide a better understanding of the concrete syntax and the features of EWL. This principle also applies to the examples presented in the sequel.","title":"Converting a Class into a Singleton"},{"location":"doc/ewl/#renaming-a-class","text":"The most widely used convention for naming attributes and association ends of a given class is to use a lower-case version of the name of the class as the name of the attribute or the association end. For instance, the two ends of a one-to-many association that links classes Book and Chapter are most likely to be named book and chapters respectively. When renaming a class (e.g. from Chapter to Section ) the user must then manually traverse the model to find all attributes and association ends of this type and update their names (i.e. from chapter or bookChapter to section and bookSection respectively). This can be a daunting process especially in the context of large models. Wizard RenameClass presented in the listing below automates this process. wizard RenameClass { // The wizard applies when a Class is selected guard : self.isKindOf(Class) title : \"Rename class \" + self.name do { var newName : String; // Prompt the user for the new name of the class newName = UserInput.prompt(\"New name for class \" + self.name); if (newName.isDefined()) { var affectedElements : Sequence; // Collect the AssociationEnds and Attributes // that are affected by the rename affectedElements.addAll( AssociationEnd.allInstances.select(ae|ae.participant=self)); affectedElements.addAll( Attribute.allInstances.select(a|a.type = self)); var oldNameToLower : String; oldNameToLower = self.name.firstToLowerCase(); var newNameToLower : String; newNameToLower = newName.firstToLowerCase(); // Update the names of the affected AssociationEnds // and Attributes for (ae in affectedElements) { ae.replaceInName(oldNameToLower, newNameToLower); ae.replaceInName(self.name, newName); } self.name = newName; } } } // Renames the ModelElement on which it is invoked operation ModelElement replaceInName (oldString : String, newString : String) { if (oldString.isSubstringOf(self.name)) { // Calculate the new name var newName : String; newName = self.name.replace(oldString, newString); // Prompt the user for confirmation of the rename if (UserInput.confirm (\"Rename \" + self.name + \" to \" + newName + \"?\")) { // Perform the rename self.name = newName; } } } As with the ClassToSingleton wizard, the guard part of RenameClass specifies that the wizard is applicable only when the selection is a simple class and the title provides a context-aware description of the functionality of the wizard. The information provided by the selected class itself does not suffice in the case of renaming since the new name of the class is not specified anywhere in the existing model. In EWL, and in all languages that build on EOL, user input can be obtained using the built-in UserInput facility. Thus, in line 12 the user is prompted for the new name of the class using the UserInput.prompt() operation. Then, all the association ends and attributes that refer to the class are collected in the affectedElements sequence (lines 14-21). Using the replaceInName operation (lines 31 and 32), the name of each one is examined for a substring of the upper-case or the lower-case version of the old name of the class. In case the check returns true, the user is prompted to confirm (line 48) that the feature needs to be renamed. This further highlights the importance of user input for implementing update transformations with fine-grained user control.","title":"Renaming a Class"},{"location":"doc/ewl/#moving-model-elements-into-a-different-package","text":"A common refactoring when modelling in UML is to move model elements, particularly Classes, between different packages. When moving a pair of classes from one package to another, the associations that connect them must also be moved to the target package. To automate this process, the listing below presents the MoveToPackage wizard. wizard MoveToPackage { // The wizard applies when a Collection of // elements, including at least one Package // is selected guard { var moveTo : Package; if (self.isKindOf(Collection)) { moveTo = self.select(e|e.isKindOf(Package)).last(); } return moveTo.isDefined(); } title : \"Move \" + (self.size()-1) + \" elements to \" + moveTo.name do { // Move the selected Model Elements to the // target package for (me in self.excluding(moveTo)) { me.namespace = moveTo; } // Move the Associations connecting any // selected Classes to the target package for (a in Association.allInstances) { if (a.connection.forAll(c|self.includes(c.participant))){ a.namespace = moveTo; } } } } The wizard applies when more than one element is selected and at least one of the elements is a Package . If more than one package is selected, the last one is considered as the target package to which the rest of the selected elements will be moved. This is specified in the guard part of the wizard. To reduce user confusion in identifying the package to which the elements will be moved, the name of the target package appears in the title of the wizard. This example shows the importance of the decision to express the title as a dynamically calculated expression (as opposed to a static string). It is worth noting that in the title part of the wizard (line 14), the moveTo variable declared in the guard (line 7) is referenced. Through experimenting with a number of wizards, it has been noticed that in complex wizards repeated calculations need to be performed in the guard , title and do parts of the wizard. To eliminate this duplication, the scope of variables defined in the guard part has been extended so that they are also accessible from the title and do part of the wizard.","title":"Moving Model Elements into a Different Package"},{"location":"doc/flock/","text":"Epsilon Flock for Model Migration \u00b6 The aim of Epsilon Flock is to contribute model migration capabilities to Epsilon. Model migration is the process of updating models in response to metamodel changes. This section discusses the motivation for implementing Flock, introduces its syntax and execution semantics, and demonstrates the use of Flock with an example. Flock can be used to update models to a new version of their metamodel, or even to move from one modelling technology to another (e.g., from XML to EMF). To illustrate the challenges of model migration, we use the example of metamodel evolution below. In the top figure, a Component comprises other Component s, Connector s and Port s. A Connector joins two Port s. Connector s are unidirectional, and hence define to and from references to Port . The original metamodel allows a Connector to start and end at the same Port , and the metamodel was evolved to prevent this, as shown in the bottom figure. Port was made abstract, and split into two subtypes, InputPort and OutputPort . The references between Connector and (the subtypes of) Port were renamed for consistency with the names of the subtypes. classDiagram class Component { +subcomponents: Component[*] +connectors: Connector[*] +ports: Port[*] } class Port { +name: String +outgoing: Connector +incoming: Connector } class Connector { +name: String +from: Port +to: Port } Component *-- Connector: connectors * Component *-- Component Component *-- Port: ports * Connector -- Port: from Port -- Connector: to classDiagram class Component { +subcomponents: Component[*] +connectors: Connector[*] +ports: Port[*] } class Port { +name: String +outgoing: Connector +incoming: Connector } class Connector { +name: String +in: InPort +out: OutPort } class InputPort { +connector: Connector } class OutputPort { +connector: Connector } Component *-- Connector: connectors * Component *-- Component Component *-- Port: ports * InputPort --|> Port: in OutputPort --|> Port: out Connector -- InputPort Connector -- OutputPort Some models that conform to the original metamodel do not conform to the evolved metamodel. Specifically, models might not conform to the evolved metamodel because: They contain instances of Port , which is an abstract class in the evolved metamodel. They contain instances of Connector that specify values for the features to and from , which are not defined for the Connector type in the evolved metamodel. They contain instances of Connector that do not specify a value for the in and out features, which are mandatory for the Connector type in the evolved metamodel. Model migration can be achieved with a general-purpose model-to-model transformation using a language such as ETL. However, this typically involves writing a large amount of repetitive and redundant code. Flock reduces the amount of repetitive and redundant code needed to specify model migration by automatically copying from the original to the migrated model all of the model elements that conform to the evolved metamodel as described below. classDiagram class GuardedConstruct { -guard: ExecutableBlock<Boolean> } class Deletion { -originalType: String -strict: Boolean -cascade: Boolean } class Retyping { -originalType: String -strict: Boolean -evolvedType: String } class PackageRetyping { -originalType: String -evolvedType: String } class PackageDeletion { -originalType: String } class MigrateRule { -originalType: String -strict: Boolean -ignoredFeatures: String[*] -body: ExecutableBlock<Void> } FlockModule -- TypeMappingConstruct: typeMappings * Deletion --|> TypeMappingConstruct TypeMappingConstruct <|-- Retyping TypeMappingConstruct <|-- PackageDeletion TypeMappingConstruct <|-- PackageRetyping MigrationRule --|> GuardedConstruct GuardedConstruct <|-- TypeMappingConstruct FlockModule -- MigrateRule: rules * EolModule <|-- ErlModule ErlModule <|-- FlockModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post * Abstract Syntax \u00b6 As illustrated in the figure above, Flock migration strategies are organised into individual modules ( FlockModule ). Flock modules inherit from EOL language constructs for specifying user-defined operations and for importing other (EOL and Flock) modules. Like the other rule-based of Epsilon, Flock modules may comprise any number of pre (post) blocks, which are executed before (after) all other constructs. Flock modules comprise any number of type mappings ( TypeMapping ) and rules ( Rule ). Type mappings operate on metamodel types ( Retyping and Deletion ) or on metamodel packages ( PackageRetyping and PackageDeletion ). Type mappings are applied to a type in the original metamodel ( originalType ) or to a package in the original metamodel ( originalPackage ) . Additionally, Retyping s apply to an evolved metamodel type ( evolvedType ) or package ( evolvedPackage ). Each rule has an original metamodel type ( originalType ), a body comprising a block of EOL statements, and zero or more ignoredFeatures . Type mappings and rules can optionally specify a guard , which is either an EOL statement or a block of EOL statements. Type mappings that operate on metamodel types and rules can be marked as strict . Concrete Syntax \u00b6 The listing below demonstrates the concrete syntax of the Flock language constructs. All of the constructs begin with keyword(s) ( retype , retype package delete , delete package or migrate ), followed by the original metamodel type or package. Additionally, type mappings that operate on metamodel types and rules can be annotated with the strict modifier. The delete construct can be annotated with a cascade modifier. All constructs can have guards, which are specified using the when keyword. Migrate rules can specify a list of features that conservative copy will ignore ( ignoring ), and a body containing a sequence of at least one EOL statement. Note that a migrate rule must have a list of ignored features, or a body, or both. (@strict)? retype <originalType> to <evolvedType> (when (:<eolExpression>)|({<eolStatement>+}))? retype package <originalPackage> to <evolvedPackage> (when (:<eolExpression>)|({<eolStatement>+}))? (@strict)? (@cascade)? delete <originalType> (when (:<eolExpression>)|({<eolStatement>+}))? delete package <originalPackage> (when (:<eolExpression>)|({<eolStatement>+}))? (@strict)? migrate <originalType> (ignoring <featureList>)? (when (:<eolExpression>)|({<eolStatement>+}))? { <eolStatement>+ } Pre and post blocks have a simple syntax that, as presented below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ } Execution Semantics \u00b6 The execution semantics of a Flock module are now described. Note that the Epsilon Model Connectivity (EMC) layer, which Flock uses to access and manipulate models supports a range of modelling technologies, and identifies types by name. Consequently, the term type is used to mean \"the name of an element of a metamodel\" in the following discussion. For example, Component , Connector and InputPort are three of the types defined in the evolved metamodel. Execution of a Flock module occurs in six phases: Any pre blocks are executed. Type mapping constructs (retypings and deletions) are processed to identify the way in which original and evolved metamodel types are to be related. Migrate rules are inspected to build sets of ignored properties. The information determined in steps 2 and 3 is used as input a copying algorithm, which creates an (equivalent) element in the migrated model for each element of the original model, and copies values from original to equivalent model elements. Migrate rules are executed on each pair of original and (equivalent) migrated model elements. Any post blocks are executed. In phases 2-5, language constructs are executed only when they are applicable . The applicability of the Flock language constructs (retyping, deletion or migrate rule) is determined from their type and guard. For a language construct c to be applicable to an original model element o , o must instantiate either the original type of c or one of the subtypes of the original type of c ; and o must satisfy the guard of c . For language constructs that have been annotated as strict, type-checking is more restrictive: o must instantiate the original type of c (and not one its subtypes). In other words, the applicability of strict constructs is determined with EOL's isTypeOf operation and the applicability of non-strict constructs is determined with EOL's isKindOf operation. For language constructs that have been annotated with cascade, type-checking is less restrictive: o must be contained in another model element (either directly or indirectly) to which the construct is applicable. Similarly, for language constructs that operate on packages (i.e. package retyping and package deletions), type-checking is less restrictive: o must be contained in a package with the same name as the original package of c . Phases 2-4 of execution implement a copying algorithm which has been termed conservative copy and is discussed thoroughly elsewhere . Essentially, conservative copy will do the following for each element of the original model, o : Do nothing when o instantiates a type that cannot be instantiated in the evolved metamodel (e.g., because the type of o is now abstract or no longer exists). Example: instances of Port in the original metamodel are not copied because Port has become abstract. Fully copy o to produce m in the migrated model when o instantiate a type that has not been at all affected by metamodel evolution. Example: instances of Component in the original metamodel are fully copied because neither Component nor any of its features have been changed. Partially copy o to produce m in the migrated model when o instantiates a type with one or more features that have been affected by metamodel evolution. Example: instances of Connector in the original metamodel are partially copied because the from and to features have been renamed. Note that in a partial copy only the features that have not been affected by metamodel evolution are copied (e.g., the name s of Connector s). In phase 5, migrate rules are applied. These rules specify the problem-specific migration logic and might, for example, create migrated model elements for original model elements that were skipped or partially copied by the copying algorithm described above. The Flock engine makes available two variables ( original and migrated ) for use in the body of any migration rule. These variables are used to refer to the particular elements of the original and migrated models to which the rule is currently being applied. In addition, Flock defines an equivalent() operation that can be called on any original model element and returns the equivalent migrated model element (or null ). The equivalent() operation is used to access elements of the migrated model that cannot be accessed via the migrated variable due to metamodel evolution. Flock rules often contain statements of the form: original.x.equivalent() where x is a feature that has been removed from the evolved metamodel. Finally, we should consider the order in which Flock schedules language constructs: a construct that appears earlier (higher) in the source file has priority. This is important because only one type mapping (retypings and deletions) is applied per original model element, and because this implies that migrate rules are applied from top-to-bottom. This ordering is consistent with the other languages of the Epsilon platform. Example \u00b6 Flock is now demonstrated using the example of model migration introduced above. Recall that the metamodel evolution involves splitting the Port type to form the InputPort and OutputPort types. Below is a high-level design for migrating models from the original to the evolved metamodel. For every instance, p, of Port in the original model: If there exists in the original model a Connector , c, that specifies p as the value for its from feature: Create a new instance, i , of InputPort in the migrated model. Set c as the connector of i . Add c to the ports reference of the Component that contains c. If there exists in the original model a Connector , c, that specifies p as the value for its to feature: Create a new instance of OutputPort in the migrated model. Set c as the connector of i. Add c to the ports reference of the Component that contains c. And nothing else changes. The Flock migration strategy that implements this design is shown below. Three type mappings constructs (on lines 1-4) are used to control the way in which instances of Port are migrated. For example, line 3 specifies that instances of Port that are referenced via the from feature of a Connector are retyped, becoming InputPort s. Instances of Connector are migrated using the rule on lines 6-9, which specifies the way in which the from and to features have evolved to form the in and out features. delete Port when: not (original.isInput() xor original.isOutput()) retype Port to InputPort when: original.isInput() retype Port to OutputPort when: original.isOutput() migrate Connector { migrated.`in` = original.from.equivalent(); migrated.out = original.`to`.equivalent(); } operation Original!Port isInput() : Boolean { return Original!Connector.all.exists(c|c.from == self); } operation Original!Port isOutput() : Boolean { return Original!Connector.all.exists(c|c.`to` == self); } Note that metamodel elements that have not been affected by the metamodel evolution, such as Component s, are migrated automatically. Explicit copying code would be needed to achieve this with a general purpose model-to-model transformation language. Limitations and Scope \u00b6 Although Flock has been shown to much more concise than general purpose model-to-model transformation languages for specifying model migration, Flock does not provide some of the features commonly available in general-purpose model-to-model transformation language. This section discusses the limitations of Flock and its intended scope with respect to other tools for model migration. Limitations \u00b6 Firstly, Flock does not support rule inheritance, and re-use of migration logic is instead achieved by exploiting the inheritance hierarchy of the original metamodel. The form of re-use provided by Flock is less general than rule-inheritance, but has proved sufficient for existing use-cases. Secondly, Flock does not provide language constructs for controlling the order in which rules are scheduled (other than the ordering of the rules in the program file). ATL, for example, includes constructs that allow users to specify that rules are scheduled explicitly (lazy rules) or in a memoised manner (unique rules). We anticipate that scheduling constructs might be necessary for larger migration strategies, but have not yet encountered situations in which they have been required. Thirdly, Flock is tailored for applying migration to a single original and a single migrated model. Although further models can be accessed by a Flock migration strategy, they cannot be used as the source or target of the conservative copy algorithm. By contrast, some general-purpose model transformation languages can access and manipulate any number of models. Fourthly, Flock can only operate on models loaded with EMC drivers that implement the IReflectiveModel interface (such as the EMF driver ), as its conservative copy algorithm needs additional information to what Epsilon's IModel interface provides. Finally, Flock has been tailored to the model migration problem. In other words, we believe that Flock is well-suited to specifying model transformations between two metamodels that are very similar. For metamodel evolution in which the original metamodel undergoes significant and large-scale revision, a general-purpose transformation might be more suitable than Flock for specifying model migration. Scope \u00b6 Flock is typically used as a manual specification approach in which model migration strategies are written by hand. As such, we believe that Flock provides a flexible and concise way to specify migration, and is a foundation for further tools that seek to automate the metamodel evolution and model migration processes. There are approaches to model migration that encompass both the metamodel evolution and model migration processes, seeking to automatically derive model migration strategies (e.g., Edapt . These approaches provide more automation but at the cost of flexibility: for example, you might be restricted to using a tool-specific editor to perform model migration, or to using only EMF. A more thorough discussion of the design decisions and execution semantics of Flock can be found in a SoSyM journal article . Flock has been compared with other model migration tools and languages in a MoDELS paper . Additional Resources \u00b6 Executing a Flock migration transformation from Java : Shows how to run Flock to migrate an EMF-based model from a headless Java application.","title":"Model Migration (Flock)"},{"location":"doc/flock/#epsilon-flock-for-model-migration","text":"The aim of Epsilon Flock is to contribute model migration capabilities to Epsilon. Model migration is the process of updating models in response to metamodel changes. This section discusses the motivation for implementing Flock, introduces its syntax and execution semantics, and demonstrates the use of Flock with an example. Flock can be used to update models to a new version of their metamodel, or even to move from one modelling technology to another (e.g., from XML to EMF). To illustrate the challenges of model migration, we use the example of metamodel evolution below. In the top figure, a Component comprises other Component s, Connector s and Port s. A Connector joins two Port s. Connector s are unidirectional, and hence define to and from references to Port . The original metamodel allows a Connector to start and end at the same Port , and the metamodel was evolved to prevent this, as shown in the bottom figure. Port was made abstract, and split into two subtypes, InputPort and OutputPort . The references between Connector and (the subtypes of) Port were renamed for consistency with the names of the subtypes. classDiagram class Component { +subcomponents: Component[*] +connectors: Connector[*] +ports: Port[*] } class Port { +name: String +outgoing: Connector +incoming: Connector } class Connector { +name: String +from: Port +to: Port } Component *-- Connector: connectors * Component *-- Component Component *-- Port: ports * Connector -- Port: from Port -- Connector: to classDiagram class Component { +subcomponents: Component[*] +connectors: Connector[*] +ports: Port[*] } class Port { +name: String +outgoing: Connector +incoming: Connector } class Connector { +name: String +in: InPort +out: OutPort } class InputPort { +connector: Connector } class OutputPort { +connector: Connector } Component *-- Connector: connectors * Component *-- Component Component *-- Port: ports * InputPort --|> Port: in OutputPort --|> Port: out Connector -- InputPort Connector -- OutputPort Some models that conform to the original metamodel do not conform to the evolved metamodel. Specifically, models might not conform to the evolved metamodel because: They contain instances of Port , which is an abstract class in the evolved metamodel. They contain instances of Connector that specify values for the features to and from , which are not defined for the Connector type in the evolved metamodel. They contain instances of Connector that do not specify a value for the in and out features, which are mandatory for the Connector type in the evolved metamodel. Model migration can be achieved with a general-purpose model-to-model transformation using a language such as ETL. However, this typically involves writing a large amount of repetitive and redundant code. Flock reduces the amount of repetitive and redundant code needed to specify model migration by automatically copying from the original to the migrated model all of the model elements that conform to the evolved metamodel as described below. classDiagram class GuardedConstruct { -guard: ExecutableBlock<Boolean> } class Deletion { -originalType: String -strict: Boolean -cascade: Boolean } class Retyping { -originalType: String -strict: Boolean -evolvedType: String } class PackageRetyping { -originalType: String -evolvedType: String } class PackageDeletion { -originalType: String } class MigrateRule { -originalType: String -strict: Boolean -ignoredFeatures: String[*] -body: ExecutableBlock<Void> } FlockModule -- TypeMappingConstruct: typeMappings * Deletion --|> TypeMappingConstruct TypeMappingConstruct <|-- Retyping TypeMappingConstruct <|-- PackageDeletion TypeMappingConstruct <|-- PackageRetyping MigrationRule --|> GuardedConstruct GuardedConstruct <|-- TypeMappingConstruct FlockModule -- MigrateRule: rules * EolModule <|-- ErlModule ErlModule <|-- FlockModule Pre --|> NamedStatementBlockRule Post --|> NamedStatementBlockRule ErlModule -- Pre: pre * ErlModule -- Post: post *","title":"Epsilon Flock for Model Migration"},{"location":"doc/flock/#abstract-syntax","text":"As illustrated in the figure above, Flock migration strategies are organised into individual modules ( FlockModule ). Flock modules inherit from EOL language constructs for specifying user-defined operations and for importing other (EOL and Flock) modules. Like the other rule-based of Epsilon, Flock modules may comprise any number of pre (post) blocks, which are executed before (after) all other constructs. Flock modules comprise any number of type mappings ( TypeMapping ) and rules ( Rule ). Type mappings operate on metamodel types ( Retyping and Deletion ) or on metamodel packages ( PackageRetyping and PackageDeletion ). Type mappings are applied to a type in the original metamodel ( originalType ) or to a package in the original metamodel ( originalPackage ) . Additionally, Retyping s apply to an evolved metamodel type ( evolvedType ) or package ( evolvedPackage ). Each rule has an original metamodel type ( originalType ), a body comprising a block of EOL statements, and zero or more ignoredFeatures . Type mappings and rules can optionally specify a guard , which is either an EOL statement or a block of EOL statements. Type mappings that operate on metamodel types and rules can be marked as strict .","title":"Abstract Syntax"},{"location":"doc/flock/#concrete-syntax","text":"The listing below demonstrates the concrete syntax of the Flock language constructs. All of the constructs begin with keyword(s) ( retype , retype package delete , delete package or migrate ), followed by the original metamodel type or package. Additionally, type mappings that operate on metamodel types and rules can be annotated with the strict modifier. The delete construct can be annotated with a cascade modifier. All constructs can have guards, which are specified using the when keyword. Migrate rules can specify a list of features that conservative copy will ignore ( ignoring ), and a body containing a sequence of at least one EOL statement. Note that a migrate rule must have a list of ignored features, or a body, or both. (@strict)? retype <originalType> to <evolvedType> (when (:<eolExpression>)|({<eolStatement>+}))? retype package <originalPackage> to <evolvedPackage> (when (:<eolExpression>)|({<eolStatement>+}))? (@strict)? (@cascade)? delete <originalType> (when (:<eolExpression>)|({<eolStatement>+}))? delete package <originalPackage> (when (:<eolExpression>)|({<eolStatement>+}))? (@strict)? migrate <originalType> (ignoring <featureList>)? (when (:<eolExpression>)|({<eolStatement>+}))? { <eolStatement>+ } Pre and post blocks have a simple syntax that, as presented below, consists of the identifier ( pre or post ), an optional name and the set of statements to be executed enclosed in curly braces. (pre|post) <name> { statement+ }","title":"Concrete Syntax"},{"location":"doc/flock/#execution-semantics","text":"The execution semantics of a Flock module are now described. Note that the Epsilon Model Connectivity (EMC) layer, which Flock uses to access and manipulate models supports a range of modelling technologies, and identifies types by name. Consequently, the term type is used to mean \"the name of an element of a metamodel\" in the following discussion. For example, Component , Connector and InputPort are three of the types defined in the evolved metamodel. Execution of a Flock module occurs in six phases: Any pre blocks are executed. Type mapping constructs (retypings and deletions) are processed to identify the way in which original and evolved metamodel types are to be related. Migrate rules are inspected to build sets of ignored properties. The information determined in steps 2 and 3 is used as input a copying algorithm, which creates an (equivalent) element in the migrated model for each element of the original model, and copies values from original to equivalent model elements. Migrate rules are executed on each pair of original and (equivalent) migrated model elements. Any post blocks are executed. In phases 2-5, language constructs are executed only when they are applicable . The applicability of the Flock language constructs (retyping, deletion or migrate rule) is determined from their type and guard. For a language construct c to be applicable to an original model element o , o must instantiate either the original type of c or one of the subtypes of the original type of c ; and o must satisfy the guard of c . For language constructs that have been annotated as strict, type-checking is more restrictive: o must instantiate the original type of c (and not one its subtypes). In other words, the applicability of strict constructs is determined with EOL's isTypeOf operation and the applicability of non-strict constructs is determined with EOL's isKindOf operation. For language constructs that have been annotated with cascade, type-checking is less restrictive: o must be contained in another model element (either directly or indirectly) to which the construct is applicable. Similarly, for language constructs that operate on packages (i.e. package retyping and package deletions), type-checking is less restrictive: o must be contained in a package with the same name as the original package of c . Phases 2-4 of execution implement a copying algorithm which has been termed conservative copy and is discussed thoroughly elsewhere . Essentially, conservative copy will do the following for each element of the original model, o : Do nothing when o instantiates a type that cannot be instantiated in the evolved metamodel (e.g., because the type of o is now abstract or no longer exists). Example: instances of Port in the original metamodel are not copied because Port has become abstract. Fully copy o to produce m in the migrated model when o instantiate a type that has not been at all affected by metamodel evolution. Example: instances of Component in the original metamodel are fully copied because neither Component nor any of its features have been changed. Partially copy o to produce m in the migrated model when o instantiates a type with one or more features that have been affected by metamodel evolution. Example: instances of Connector in the original metamodel are partially copied because the from and to features have been renamed. Note that in a partial copy only the features that have not been affected by metamodel evolution are copied (e.g., the name s of Connector s). In phase 5, migrate rules are applied. These rules specify the problem-specific migration logic and might, for example, create migrated model elements for original model elements that were skipped or partially copied by the copying algorithm described above. The Flock engine makes available two variables ( original and migrated ) for use in the body of any migration rule. These variables are used to refer to the particular elements of the original and migrated models to which the rule is currently being applied. In addition, Flock defines an equivalent() operation that can be called on any original model element and returns the equivalent migrated model element (or null ). The equivalent() operation is used to access elements of the migrated model that cannot be accessed via the migrated variable due to metamodel evolution. Flock rules often contain statements of the form: original.x.equivalent() where x is a feature that has been removed from the evolved metamodel. Finally, we should consider the order in which Flock schedules language constructs: a construct that appears earlier (higher) in the source file has priority. This is important because only one type mapping (retypings and deletions) is applied per original model element, and because this implies that migrate rules are applied from top-to-bottom. This ordering is consistent with the other languages of the Epsilon platform.","title":"Execution Semantics"},{"location":"doc/flock/#example","text":"Flock is now demonstrated using the example of model migration introduced above. Recall that the metamodel evolution involves splitting the Port type to form the InputPort and OutputPort types. Below is a high-level design for migrating models from the original to the evolved metamodel. For every instance, p, of Port in the original model: If there exists in the original model a Connector , c, that specifies p as the value for its from feature: Create a new instance, i , of InputPort in the migrated model. Set c as the connector of i . Add c to the ports reference of the Component that contains c. If there exists in the original model a Connector , c, that specifies p as the value for its to feature: Create a new instance of OutputPort in the migrated model. Set c as the connector of i. Add c to the ports reference of the Component that contains c. And nothing else changes. The Flock migration strategy that implements this design is shown below. Three type mappings constructs (on lines 1-4) are used to control the way in which instances of Port are migrated. For example, line 3 specifies that instances of Port that are referenced via the from feature of a Connector are retyped, becoming InputPort s. Instances of Connector are migrated using the rule on lines 6-9, which specifies the way in which the from and to features have evolved to form the in and out features. delete Port when: not (original.isInput() xor original.isOutput()) retype Port to InputPort when: original.isInput() retype Port to OutputPort when: original.isOutput() migrate Connector { migrated.`in` = original.from.equivalent(); migrated.out = original.`to`.equivalent(); } operation Original!Port isInput() : Boolean { return Original!Connector.all.exists(c|c.from == self); } operation Original!Port isOutput() : Boolean { return Original!Connector.all.exists(c|c.`to` == self); } Note that metamodel elements that have not been affected by the metamodel evolution, such as Component s, are migrated automatically. Explicit copying code would be needed to achieve this with a general purpose model-to-model transformation language.","title":"Example"},{"location":"doc/flock/#limitations-and-scope","text":"Although Flock has been shown to much more concise than general purpose model-to-model transformation languages for specifying model migration, Flock does not provide some of the features commonly available in general-purpose model-to-model transformation language. This section discusses the limitations of Flock and its intended scope with respect to other tools for model migration.","title":"Limitations and Scope"},{"location":"doc/flock/#limitations","text":"Firstly, Flock does not support rule inheritance, and re-use of migration logic is instead achieved by exploiting the inheritance hierarchy of the original metamodel. The form of re-use provided by Flock is less general than rule-inheritance, but has proved sufficient for existing use-cases. Secondly, Flock does not provide language constructs for controlling the order in which rules are scheduled (other than the ordering of the rules in the program file). ATL, for example, includes constructs that allow users to specify that rules are scheduled explicitly (lazy rules) or in a memoised manner (unique rules). We anticipate that scheduling constructs might be necessary for larger migration strategies, but have not yet encountered situations in which they have been required. Thirdly, Flock is tailored for applying migration to a single original and a single migrated model. Although further models can be accessed by a Flock migration strategy, they cannot be used as the source or target of the conservative copy algorithm. By contrast, some general-purpose model transformation languages can access and manipulate any number of models. Fourthly, Flock can only operate on models loaded with EMC drivers that implement the IReflectiveModel interface (such as the EMF driver ), as its conservative copy algorithm needs additional information to what Epsilon's IModel interface provides. Finally, Flock has been tailored to the model migration problem. In other words, we believe that Flock is well-suited to specifying model transformations between two metamodels that are very similar. For metamodel evolution in which the original metamodel undergoes significant and large-scale revision, a general-purpose transformation might be more suitable than Flock for specifying model migration.","title":"Limitations"},{"location":"doc/flock/#scope","text":"Flock is typically used as a manual specification approach in which model migration strategies are written by hand. As such, we believe that Flock provides a flexible and concise way to specify migration, and is a foundation for further tools that seek to automate the metamodel evolution and model migration processes. There are approaches to model migration that encompass both the metamodel evolution and model migration processes, seeking to automatically derive model migration strategies (e.g., Edapt . These approaches provide more automation but at the cost of flexibility: for example, you might be restricted to using a tool-specific editor to perform model migration, or to using only EMF. A more thorough discussion of the design decisions and execution semantics of Flock can be found in a SoSyM journal article . Flock has been compared with other model migration tools and languages in a MoDELS paper .","title":"Scope"},{"location":"doc/flock/#additional-resources","text":"Executing a Flock migration transformation from Java : Shows how to run Flock to migrate an EMF-based model from a headless Java application.","title":"Additional Resources"},{"location":"doc/hutn/","text":"Human Usable Textual Notation \u00b6 HUTN is an OMG standard for storing models in a human understandable format. In a sense it is a human-oriented alternative to XMI; it has a C-like style which uses curly braces instead of the verbose XML start and end-element tags. Epsilon provides an implementation of HUTN which has been realized using ETL for model-to-model transformation, EGL for generating model-to-text transformations, and EVL for checking the consistency of HUTN models. Features \u00b6 Write models using a text editor Generic-syntax: no need to specify parser Error markers highlighting inconsistencies Resilient to metamodel changes Built-in HUTN->XMI and XMI->HUTN transformations Automated builder (HUTN->XMI) Examples \u00b6 Article: Using the Human-Usable Textual Notation (HUTN) in Epsilon Article: Using HUTN for T2M transformation - Article: New in HUTN 0.7.1 Article: Managing Inconsistent Models with HUTN Reference \u00b6 The OMG provides a complete specification of the HUTN syntax.","title":"HUTN"},{"location":"doc/hutn/#human-usable-textual-notation","text":"HUTN is an OMG standard for storing models in a human understandable format. In a sense it is a human-oriented alternative to XMI; it has a C-like style which uses curly braces instead of the verbose XML start and end-element tags. Epsilon provides an implementation of HUTN which has been realized using ETL for model-to-model transformation, EGL for generating model-to-text transformations, and EVL for checking the consistency of HUTN models.","title":"Human Usable Textual Notation"},{"location":"doc/hutn/#features","text":"Write models using a text editor Generic-syntax: no need to specify parser Error markers highlighting inconsistencies Resilient to metamodel changes Built-in HUTN->XMI and XMI->HUTN transformations Automated builder (HUTN->XMI)","title":"Features"},{"location":"doc/hutn/#examples","text":"Article: Using the Human-Usable Textual Notation (HUTN) in Epsilon Article: Using HUTN for T2M transformation - Article: New in HUTN 0.7.1 Article: Managing Inconsistent Models with HUTN","title":"Examples"},{"location":"doc/hutn/#reference","text":"The OMG provides a complete specification of the HUTN syntax.","title":"Reference"},{"location":"doc/workflow/","text":"Orchestration Workflow \u00b6 In practice, model management activities are seldom carried out in isolation; instead, they are often combined together to form complex workflows. Therefore, in addition to task-specific languages for individual activities (model-to-text transformatino, model validation etc), Epsilon provides a set of Apache ANT tasks for assembling multi-step automated build processes. Running Epsilon's ANT tasks Epsilon's ANT tasks can run both within Eclipse and headless , and from Maven and Gradle builds too. When running an ANT workflow that involves Epsilon tasks in Eclipse, please make sure you select the Run in the same JRE as the workspace option under the JRE tab of your launch configuration. Motivation \u00b6 As a motivating example, a workflow that consists of both model management tasks (1-4, 6) and mainstream software development tasks (5, 7) is displayed below. Load a UML model Validate it Transform it into a Database Schema model Generate Java code from the UML model Compile the Java code Generate SQL statements from the Database model Run the SQL statements in a Database Management System (DBMS) In the above workflow, if the validation step (2) fails, the entire process should be aborted and the identified errors should be reported to the user. This example demonstrates that to be of practical use, a task orchestration framework needs to be able to coordinate both model management and mainstream development tasks and provide mechanisms for establishing dependencies between different tasks. This page discusses such a framework for orchestrating modular model management tasks implemented using languages of the Epsilon platform. As the problem of task coordination is common in software development, many technical solutions have been already proposed and are widely used by software practitioners. In this context, designing a new general-purpose workflow management solution was deemed inappropriate. Therefore, the task orchestration solution discussed here has been designed as an extension to the robust and widely used ANT framework. A brief overview of ANT as well as a discussion on the choice to design the orchestration workflow of Epsilon atop it is provided below. The ANT Tool \u00b6 ANT, named so because it is a little thing that can be used to build big things , is a robust and widely-used framework for composing automated workflows from small reusable activities. The most important advantages of ANT, compared to traditional build tools such as gnumake , is that it is platform independent and easily extensible. Platform independence is achieved by building atop Java, and extensibility is realized through a lightweight binding mechanism that enables developers to contribute custom tasks using well defined interfaces and extension points. This section provides a brief discussion of the structure and concrete syntax of ANT workflows, as well as the extensibility mechanisms that ANT provides to enable users contribute custom tasks. Structure \u00b6 In ANT, each workflow is captured as a project . A simplified illustration of the structure of an ANT project is displayed in the figure below. Each ANT project consists of a number of targets . The one specified as the default is executed automatically when the project is executed. Each target contains a number of tasks and depends on other targets that must be executed before it. An ANT task is responsible for a distinct activity and can either succeed or fail. Exemplar activities implemented by ANT tasks include file system management, compiler invocation, version management and remote artefact deployment. classDiagram class Project { -targets: Target[*] -default: Target -properties: Property[*] } class Task { -typeName: String -name: String -attributes: Attribute[*] } class Attribute { -name: String -value: String } class Target { -name: String -tasks: Task[*] -depends: Target[*] } class HashMap { +put(key: String, object: Object) +get(key: String): Object } Project -- Property: properties * Project -- Target: targets * Target -- Project: default Property --|> Task Task -- Attribute: attributes * Task -- Target: tasks * Target -- Target: depends * Project -- HashMap: references * Concrete Syntax \u00b6 In terms of concrete syntax, ANT provides an XML-based syntax. In the listing below, an exemplar ANT project that compiles a set of Java files is illustrated. The project contains one target ( main ) which is also set to be the default target. The main target contains one javac task that specifies attributes such as srcdir , destdir and classpath , which define that the Java compiler will compile a set of Java files contained into the src directory into classes that should be placed in the build directory using dependencies.jar as an external library. <project default= \"main\" > <target name= \"main\" /> <javac srcdir= \"${src}\" destdir= \"${build}\" classpath= \"dependencies.jar\" debug= \"on\" source= \"1.4\" /> </target> </project> Extending ANT \u00b6 Binding between the XML tags that describe the tasks and the actual implementations of the tasks is achieved through a light-weight mechanism at two levels. First, the tag (in the example above, javac ) is resolved to a Java class that extends the org.apache.ant.Task abstract class (in the case of javac , the class is org.apache.tools.ant.taskdefs.Javac ) via a configuration file. Then, the attributes of the tasks (e.g. srcdir ) are set using the reflective features that Java provides. Finally, the execute() method of the task is invoked to perform the actual job. ANT also supports more advanced features including nested XML elements and filesets , however providing a complete discussion is beyond the scope of this page. Integration Challenges \u00b6 A simple approach to extending ANT with support for model management tasks would be to implement one standalone task for each language in Epsilon. However, such an approach demonstrates a number of integration and performance shortcomings which are discussed below. Since models are typically serialized in the file system, before a task is executed, the models it needs to access/modify must be parsed and loaded in memory. In the absence of a more elaborate framework, each model management task would have to take responsibility for loading and storing the models it operates on. Also, in most workflows, more than one task operates on the same models sequentially, and needlessly loading/storing the same models many times in the context of the same workflow is an expensive operation both time and memory-wise, particularly as the size of models increases. Another weakness of this primitive approach is limited inter-task communication. In the absence of a communication framework that allows model management tasks to exchange information with each other, it is often the case that many tasks end up performing the same (potentially expensive) queries on models. By contrast, an inter-task communication framework would enable time and resource intensive calculations to be performed once and their results to be communicated to all interested subsequent tasks. Having discussed ANT, Epsilon and the challenges their integration poses, the following sections presents the design of a solution that enables developers to invoke model management tasks in the context of ANT workflows. The solution consists of a core framework that addresses the challenges discussed above, a set of specific tasks, each of which implements a distinct model management activity, and a set of tasks that enable developers to initiate and manage transactions on models using the respective facilities provided by Epsilon's model connectivity layer . Framework Design and Core Tasks \u00b6 The role of the core framework, illustrated below, is to provide model loading and storing facilities as well as runtime communication facilities to the individual model management tasks that build atop it. This section provides a detailed discussion of the components it consists of. classDiagram class Task { -name: String -type: String } class VariableNestedElement { -ref: String -as: String -optional: String -ant: boolean } class EpsilonTask { -profile: Boolean +getProjectRepository(): ModelRepository +getProjectContext(): IEolContext } class ExecutableModuleTask { -src: String -code: String -models: ModelNestedElement[*] -exports: ExportNestedElement[*] -uses: UsesNestedElement[*] } class ModelNestedElement { -ref: String -as: String -optional: String } Task <|-- EpsilonTask EpsilonTask <|-- ExecutableModuleTask ExecutableModuleTask *-- ModelNestedElement: models * ExecutableModuleTask *-- UsesNestedElement: uses * ExecutableModuleTask *-- ExportsNestedElement: exports * ExportsNestedElement --|> VariableNestedElement UsesNestedElement --|> VariableNestedElement classDiagram class LoadModelTask { -name: String -type: String -aliases: String -parameters: ParameterNestedElement[*] } class ParameterNestedElement { -name: String -value: String -file: String } class StoreModelTask { -model: String -target: String } class DisposeModelTask { -model: String } class StartTransactionTask { -name: String -models: String } class CommitTransactionTask { -name: String } class RollbackTransactionTask { -name: String } EpsilonTask <|-- CommitTransactionTask EpsilonTask <|-- StartTransactionTask RollbackTransactionTask --|> EpsilonTask EpsilonTask <|-- LoadModelTask StoreModelTask --|> EpsilonTask DisposeModelTask --|> EpsilonTask DisposeModelsTask --|> EpsilonTask LoadModelTask *-- ParameterNestedElement: parameters * The EpsilonTask task \u00b6 An ANT task can access the project in which it is contained by invoking the Task.getProject() method. To facilitate sharing of arbitrary information between tasks, ANT projects provide two convenience methods, namely addReference(String key, Object ref) and getReference(String key) : Object . The former is used to add key-value pairs, which are then accessible using the latter from other tasks of the project. To avoid loading models multiple times and to enable on-the-fly management of models from different Epsilon modules without needing to store and re-load the models after each task, a reference to a project-wide model repository has been added to the current ANT project using the addReference method discussed above. In this way, all the subclasses of the abstract EpsilonTask can invoke the getProjectRepository() method to access the project model repository. Also, to support a variable sharing mechanism that enables inter-task communication, the same technique has been employed; a shared context, accessible by all Epsilon tasks via the getProjectContext() method, has been added. Through this mechanism, model management tasks can export variables to the project context (e.g. traces or lists containing results of expensive queries) which other tasks can then reuse. EpsilonTask also specifies a profile attribute that defines if the execution of the task must be profiled using the profiling features provided by Epsilon. Profiling is a particularly important aspect of workflow execution, especially where model management languages are involved. The main reason is that model management languages tend to provide convenient features which can however be computationally expensive (such as the allInstances() EOL built-in feature that returns all the instances of a specific metaclass in the model) and when used more often than really needed, can significantly degrade the overall performance. The workflow leverages the model-transaction services provided by the model connectivity framework of Epsilon by providing three tasks for managing transactions in the context of workflows. Model Loading Tasks \u00b6 The LoadModelTask (epsilon.loadModel) loads a model from an arbitrary location (e.g. file-system, database) and adds it to the project repository so that subsequent Epsilon tasks can query or modify it. Since Epsilon supports many modelling technologies (e.g. EMF, MDR, XML), the LoadModelTask defines only three generic attributes. The name attribute specifies the name of the model in the project repository. The type attribute specifies the modelling technology with which the model is captured and is used to resolve the technology-specific model loading functionality. Finally, the aliases attribute defines a comma-separated list of alternative names by which the model can be accessed in the model repository. The rest of the information needed to load a model is implementation-specific and is therefore provided through parameter nested elements, each one defining a pair of name - value attributes. As an example, a task for loading an EMF model that has a file-based ECore metamodel is displayed below. <epsilon.loadModel name= \"Tree1\" type= \"EMF\" > <parameter name= \"modelFile\" value= \"TreeInstance.ecore\" /> <parameter name= \"metamodelFile\" path= \"Tree.ecore\" /> <parameter name= \"isMetamodelFileBased\" value= \"true\" /> <parameter name= \"readOnLoad\" value= \"true\" /> </epsilon.loadModel> LoadEmfModelTask is a specialised version of LoadModelTask only for EMF models. While the type attribute is no longer available, the task still supports the name and aliases attributes. In addition, some of the values which had to be provided through parameter nested elements can now be set using regular attributes, such as modelFile , modelUri , metamodelFile (which implicitly indicates that the metamodel is file-based), metamodelUri , reuseUnmodifiedMetamodelFile (which can be set to \"false\" to avoid reusing file-based metamodels that have not been modified since the last time they were loaded), read (equivalent to readOnLoad ) and store (equivalent to storeOnDisposal ). The listing below shows the equivalent fragment required to produce the same result as in the listing above. <epsilon.emf.loadModel name= \"Tree1\" modelFile= \"TreeInstance.ecore\" metamodelFile= \"Tree.ecore\" /> Model Storing Task \u00b6 The StoreModelTask (epsilon.storeModel) is used to store a model residing in the project repository. The StoreModelTask defines three attributes: model (required): name of the model to be stored. targetUri (optional): URI where the model will be stored (e.g. \"file:/path/to/destination\"). target (optional): file path where the model will be stored (e.g. \"file.xmi\"). targetUri takes precedence over target . If neither is defined, then the model is stored in the location from which it was originally loaded. Model Disposal Tasks \u00b6 When a model is no longer required by tasks of the workflow, it can be disposed using the epsilon.disposeModel task. The task provides the model attribute that defines the name of the model to be disposed. Also, the attribute-less epsilon.disposeModels task is provided that disposes all the models in the project model repository. This task is typically invoked when the model management part of the workflow has finished. The StartTransaction Task \u00b6 The epsilon.startTransaction task defines a name attribute that identifies the transaction. It also optionally defines a comma-separated list of model names ( models ) that the transaction will manage. If the models attribute is not specified, the transaction involves all the models contained in the common project model repository. The CommitTransaction and RollbackTransaction Tasks \u00b6 The epsilon.commitTransaction and epsilon.rollbackTransaction tasks define a name attribute through which the transaction to be committed/rolled-back is located in the project's active transactions. If several active transactions with the same name exist the more recent one is selected. The example below demonstrates an exemplar usage of the epsilon.startTransaction and epsilon.rollbackTransaction tasks. In this example, two empty models Tree1 and Tree2 are loaded in lines 1,2. Then, the EOL task of line 4 queries the models and prints the number of instances of the Tree metaclass in each one of them (which is 0 for both). Then, in line 13, a transaction named T1 is started on model Tree1. The EOL task of line 15, creates a new instance of Tree in both Tree1 and Tree2 and prints the number of instances of Tree in the two models (which is 1 for both models). Then, in line 26, the T1 transaction is rolled-back and any changes done in its context to model Tree1 (but not Tree2) are undone. Therefore, the EOL task of line 28, which prints the number of instances of Tree in both models, prints 0 for Tree1 but 1 for Tree2. <epsilon.loadModel name= \"Tree1\" type= \"EMF\" > ... </epsilon.loadModel> <epsilon.loadModel name= \"Tree2\" type= \"EMF\" > ... </epsilon.loadModel> <epsilon.eol> <![CDATA[ Tree1!Tree.allInstances.size().println(); // prints 0 Tree2!Tree.allInstances.size().println(); // prints 0 ]]> <model ref= \"Tree1\" /> <model ref= \"Tree2\" /> </epsilon.eol> <epsilon.startTransaction name= \"T1\" models= \"Tree1\" /> <epsilon.eol> <![CDATA[ var t1 : new Tree1!Tree; Tree1!Tree.allInstances.size().println(); // prints 1 var t2 : new Tree2!Tree; Tree2!Tree.allInstances.size().println(); // prints 1 ]]> <model ref= \"Tree1\" /> <model ref= \"Tree2\" /> </epsilon.eol> <epsilon.rollbackTransaction name= \"T1\" /> <epsilon.eol> <![CDATA[ Tree1!Tree.allInstances.size().println(); // prints 0 Tree2!Tree.allInstances.size().println(); // prints 1 ]]> <model ref= \"Tree1\" /> <model ref= \"Tree2\" /> </epsilon.eol> classDiagram class ExecutableModuleTask { -src: String } class EmlTask { -useMatchTrace: String -exportTransformationTrace: String -exportMergeTrace: String } class EtlTask { -exportTransformationTrace: String } class EglTask { -target: String } class EclTask { -exportMatchTrace: String -useMatchTrace: String } class EvlTask { -failOnErrors: Boolean -failOnWarnings: Boolean -exportConstraintTrace: String } ExecutableModuleTask <|-- EclTask ExecutableModuleTask <|-- EvlTask ExecutableModuleTask <|-- EglTask EmlTask --|> ExecutableModuleTask EtlTask --|> ExecutableModuleTask EolTask --|> ExecutableModuleTask The Abstract Executable Module Task \u00b6 This task is the base of all the model management tasks presented in the following section. Its aim is to encapsulate the commonalities of Epsilon tasks in order to reduce duplication among them. As already discussed, in Epsilon, specifications of model management tasks are organized in executable modules. While modules can be stored anywhere, in the case of the workflow it is assumed that they are either stored as separate files in the file-system or they are provided inline within the worfklow. Thus, this abstract task defines an src attribute that specifies the path of the source file in which the Epsilon module is stored, but also supports inline specification of the source of the module. The two alternatives are demonstrated in the listings below. <project default= \"main\" > <target name= \"main\" > <epsilon.eol src= \"HelloWorld.eol\" /> </target> </project> <project default= \"main\" > <target name= \"main\" > <epsilon.eol> <![CDATA[ \"Hello world\".println(); ]]> </epsilon.eol> </target> </project> Optionally, users can enable debugging for the module to be run by setting the debug attribute to true . An example is shown below. If the module reaches a breakpoint, users will be able to run the code step by step and inspect the stack trace and its variables. <project default= \"main\" > <target name= \"main\" > <epsilon.eol src= \"HelloWorld.eol\" debug= \"true\" /> </target> </project> The task also defines the following nested elements: 0..n model nested elements \u00b6 Through the model nested elements, each task can define which of the models, loaded in the project repository it needs to access. Each model element defines three attributes. The ref attribute specifies the name of the model that the task needs to access, the as attribute defines the name by which the model will be accessible in the context of the task, and the aliases defines a comma-delimited sequence of aliases for the model in the context of the task. 0..n parameter nested elements \u00b6 The parameter nested elements enable users to communicate String parameters to tasks. Each parameter element defines a name and a value attribute. Before executing the module, each parameter element is transformed into a String variable with the respective name and value which is then made accessible to the module. 0..n exports nested elements \u00b6 To facilitate low-level integration between different Epsilon tasks, each task can export a number of variables to the project context, so that subsequent tasks can access them later. Each export nested element defines the three attributes. The ref attribute specifies the name of the variable to be exported, the as string attribute defines the name by which the variable is stored in the project context and the optional boolean attribute specifies whether the variable is mandatory. If optional is set to false and the module does not specify such a variable, an ANT BuildException is raised. If the ant attribute is set to true, the variable is exported as an ANT variable, as shown below. <project default= \"main\" > <target name= \"main\" > <epsilon.eol> var x = 1; <exports ref= \"x\" ant= \"true\" /> </epsilon.eol> <echo> ${x} </echo> <!-- Prints 1 --> </target> </project> 0..n uses nested elements \u00b6 The uses nested elements enable tasks to import variables exported by previous Epsilon tasks. Each use element supports three attributes. The ref attribute specifies the name of the variable to be used. If there is no variable with this name in the project context, the ANT project properties are queried. This enables Epsilon modules to access ANT parameters (e.g. provided using command-line arguments). The as attribute specifies the name by which the variable is accessible in the context of the task. Finally, the optional boolean parameter specifies if the variable must exist in the project context. To better illustrate the runtime communication mechanism, a minimal example is provided below. In the first listing, Exporter.eol defines a String variable named x and assigns a value to it. The workflow below specifies that after executing Exporter.eol , it must export a variable named x with the new name y to the project context. Finally, it defines that before executing User.eol , it must query the project context for a variable named y and in case this is available, add the variable to the module's context and then execute it. Thus, the result of executing the workflow is Some String printed in the output console. // Exporter.eol var x : String = \"Some string\"; // User.eol z.println(); <epsilon.eol src= \"Exporter.eol\" > <exports ref= \"x\" as= \"y\" /> </epsilon.eol> <epsilon.eol src= \"User.eol\" > <uses ref= \"y\" as= \"z\" /> </epsilon.eol> Model Management Tasks \u00b6 Having discussed the core framework, this section presents the model management tasks that have been implemented atop it, using languages of the Epsilon platform. Generic Model Management Task \u00b6 The epsilon.eol task executes an EOL module, defined using the src attribute on the models that are specified using the model nested elements. Model Validation Task \u00b6 The epsilon.evl task executes an EVL module, defined using the src attribute on the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes: failOnErrors : Errors are the results of unsatisfied constraints. Setting the value of this attribute to true (default is false ) causes a BuildException to be raised if one or more errors are identified during the validation process. failOnWarnings : Similarly to errors, warnings are the results of unsatisfied critiques. Setting the value of this attribute to true (default is also false ) causes a BuildException to be raised if one or more warnings are identified during the validation process. exportConstraintTrace : This attribute enables developers to export the internal constraint trace constructed during model validation to the project context so that it can be later accessed by other tasks - which could for example attempt to automatically repair the identified inconsistencies. exportAsModel : Setting the value of this attribute causes the task to export the results of the validation as a new in-memory Java model with the specified name in the project repository. The exported model is essentially a wrapper for all the unsatisfied constraints identified by EVL. Model-to-Model Transformation Task \u00b6 The epsilon.etl task executes an ETL module, defined using the src attribute to transform between the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the exportTransformationTrace attribute that enables the developer to export the internal transformation trace to the project context. In this way this trace can be reused by subsequent tasks; for example another task can serialize it in the form of a separate traceability model. Model Comparison Task \u00b6 The epsilon.ecl task executes an ECL module, defined using the src attribute to establish matches between elements of the models that are specified using the model nested elements. In addition to the attributes defined by ExecutableModuleTask , this task also provides the exportMatchTrace attribute that enables users to export the match-trace calculated during the comparison as a named variable to the project context so that subsequent tasks can reuse it. For example, as discussed in the sequel, an EML model merging task can use it as a means of identifying correspondences on which to perform merging. In another example, the match-trace can be stored by a subsequent EOL task in the form of an stand-alone weaving model. Model Merging Task \u00b6 The epsilon.eml task executes an EML module, defined using the src attribute on the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes: useMatchTrace : To merge a set of models, an EML module needs an established match-trace between elements of the models. The useMatchTrace attribute enables the EML task to use a match-trace exported by a preceding ECL task (using its exportMatchTrace attribute). exportMergeTrace, exportTransformationTrace : Similarly to ETL, through these attributes an EML task can export the internal traces calculated during merging for subsequent tasks to use. Model-to-Text Transformation Task \u00b6 To support model to text transformations, EglTask (epsilon.egl) task is provided that executes an Epsilon Generation Language (EGL) module. In addition to the attributes defined by ExecutableModuleTask , EglTask also defines the following attributes: target : Defines a file in which all of the generated text will be stored. templateFactoryType : Defines the Java class that will be instantiated to provide a TemplateFactory for the EGL program. The specified class must be on the classpath and must subtype EglTemplateFactory . EglTask may nest any number of formatter elements. The formatter nested element has the following attributes: implementation (required) : Defines the Java class that will be instantiated to provide a Formatter for the EGL program. The specified class must be on the classpath and must subtype Formatter . Model Migration Task \u00b6 To support model migration, FlockTask (epsilon.flock) is provided for executing an Epsilon Flock module. In addition to the attributes defined by ExecutableModuleTask , FlockTask also defines the following mandatory attributes: originalModel : Specifies which of the currently loaded models should be used as the source of the model migration. migratedModel : Specifies which of the currently loaded models should be used as the target of the model migration. <model> nested elements still required Please note that originalModel and migratedModel refer to models specified using <model> nested elements under epsilon.flock . Pattern Matching Task \u00b6 The epsilon.epl task executes an EPL module, defined using the src attribute to perform pattern matching on the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes. repeatWhileMatches : A boolean specifying whether the pattern matching process should continue to execute for as long as matches are found. maxLoops : An integer specifying the maximum number of pattern matching iterations. exportAs : The name under which the computed pattern match model should be made available to other Epsilon tasks of the workflow. Model Generation Task \u00b6 The epsilon.emg tasks extends the epsilon.epl task and executes an EMG model generator. In addition to EPL's attributes, the task also provides the following attribute. seed (optional): A long specifying the seed to drive the random number generator that underpins the random aspects of model generation. If a seed is not specified, a random seed will be used and the generator will (likely) produce a different model every time it is executed. Fixing the seed produces repeatable results across executions. Dataset Extraction Task \u00b6 The epsilon.pinset task executes a Pinset module specified using the src attribute to generate CSV datasets from models. It also provides the following attribute. outputFolder (optional): A path specifying the folder where the CSV files will be generated. If not provided, the CSVs will be created in the same folder where the .pinset source file resides. Java Class Static Method Execution Task \u00b6 The epsilon.java.executeStaticMethod task executes a parameter-less static method, defined using the method attribute, of a Java class, defined using the javaClass attribute. This task can be useful for setting up the infrastructure of Xtext-based languages. For Task \u00b6 The epsilon.for task iterates over the files in a fileset and executes its nested tasks. An example that uses epsilon.for to run an EOL program on XML files contained in a folder called loop is show below. <project default= \"main\" > <target name= \"main\" > <!-- Load t1.xml once as Ta --> <epsilon.xml.loadModel name= \"Ta\" file= \"t1.xml\" /> <!-- For every XML file in the loop directory --> <epsilon.for> <fileset dir= \"loop\" includes= \"*.xml\" /> <!-- Load the file as Tb --> <epsilon.xml.loadModel name= \"Tb\" file= \"loop/${it}\" /> <!-- Run an EOL program on Ta and Tb --> <epsilon.eol> Ta!t_tree.all.a_name.println(); Tb!t_tree.all.a_name.println(); <model ref= \"Ta\" /> <model ref= \"Tb\" /> </epsilon.eol> <!-- Dispose of Tb --> <epsilon.disposeModel model= \"Tb\" /> </epsilon.for> </target> </project> The complete source code for this example is in Epsilon's Git repo . Additional Resources \u00b6 Additional resources about the Epsilon ANT tasks are available here .","title":"Workflow (Ant tasks)"},{"location":"doc/workflow/#orchestration-workflow","text":"In practice, model management activities are seldom carried out in isolation; instead, they are often combined together to form complex workflows. Therefore, in addition to task-specific languages for individual activities (model-to-text transformatino, model validation etc), Epsilon provides a set of Apache ANT tasks for assembling multi-step automated build processes. Running Epsilon's ANT tasks Epsilon's ANT tasks can run both within Eclipse and headless , and from Maven and Gradle builds too. When running an ANT workflow that involves Epsilon tasks in Eclipse, please make sure you select the Run in the same JRE as the workspace option under the JRE tab of your launch configuration.","title":"Orchestration Workflow"},{"location":"doc/workflow/#motivation","text":"As a motivating example, a workflow that consists of both model management tasks (1-4, 6) and mainstream software development tasks (5, 7) is displayed below. Load a UML model Validate it Transform it into a Database Schema model Generate Java code from the UML model Compile the Java code Generate SQL statements from the Database model Run the SQL statements in a Database Management System (DBMS) In the above workflow, if the validation step (2) fails, the entire process should be aborted and the identified errors should be reported to the user. This example demonstrates that to be of practical use, a task orchestration framework needs to be able to coordinate both model management and mainstream development tasks and provide mechanisms for establishing dependencies between different tasks. This page discusses such a framework for orchestrating modular model management tasks implemented using languages of the Epsilon platform. As the problem of task coordination is common in software development, many technical solutions have been already proposed and are widely used by software practitioners. In this context, designing a new general-purpose workflow management solution was deemed inappropriate. Therefore, the task orchestration solution discussed here has been designed as an extension to the robust and widely used ANT framework. A brief overview of ANT as well as a discussion on the choice to design the orchestration workflow of Epsilon atop it is provided below.","title":"Motivation"},{"location":"doc/workflow/#the-ant-tool","text":"ANT, named so because it is a little thing that can be used to build big things , is a robust and widely-used framework for composing automated workflows from small reusable activities. The most important advantages of ANT, compared to traditional build tools such as gnumake , is that it is platform independent and easily extensible. Platform independence is achieved by building atop Java, and extensibility is realized through a lightweight binding mechanism that enables developers to contribute custom tasks using well defined interfaces and extension points. This section provides a brief discussion of the structure and concrete syntax of ANT workflows, as well as the extensibility mechanisms that ANT provides to enable users contribute custom tasks.","title":"The ANT Tool"},{"location":"doc/workflow/#structure","text":"In ANT, each workflow is captured as a project . A simplified illustration of the structure of an ANT project is displayed in the figure below. Each ANT project consists of a number of targets . The one specified as the default is executed automatically when the project is executed. Each target contains a number of tasks and depends on other targets that must be executed before it. An ANT task is responsible for a distinct activity and can either succeed or fail. Exemplar activities implemented by ANT tasks include file system management, compiler invocation, version management and remote artefact deployment. classDiagram class Project { -targets: Target[*] -default: Target -properties: Property[*] } class Task { -typeName: String -name: String -attributes: Attribute[*] } class Attribute { -name: String -value: String } class Target { -name: String -tasks: Task[*] -depends: Target[*] } class HashMap { +put(key: String, object: Object) +get(key: String): Object } Project -- Property: properties * Project -- Target: targets * Target -- Project: default Property --|> Task Task -- Attribute: attributes * Task -- Target: tasks * Target -- Target: depends * Project -- HashMap: references *","title":"Structure"},{"location":"doc/workflow/#concrete-syntax","text":"In terms of concrete syntax, ANT provides an XML-based syntax. In the listing below, an exemplar ANT project that compiles a set of Java files is illustrated. The project contains one target ( main ) which is also set to be the default target. The main target contains one javac task that specifies attributes such as srcdir , destdir and classpath , which define that the Java compiler will compile a set of Java files contained into the src directory into classes that should be placed in the build directory using dependencies.jar as an external library. <project default= \"main\" > <target name= \"main\" /> <javac srcdir= \"${src}\" destdir= \"${build}\" classpath= \"dependencies.jar\" debug= \"on\" source= \"1.4\" /> </target> </project>","title":"Concrete Syntax"},{"location":"doc/workflow/#extending-ant","text":"Binding between the XML tags that describe the tasks and the actual implementations of the tasks is achieved through a light-weight mechanism at two levels. First, the tag (in the example above, javac ) is resolved to a Java class that extends the org.apache.ant.Task abstract class (in the case of javac , the class is org.apache.tools.ant.taskdefs.Javac ) via a configuration file. Then, the attributes of the tasks (e.g. srcdir ) are set using the reflective features that Java provides. Finally, the execute() method of the task is invoked to perform the actual job. ANT also supports more advanced features including nested XML elements and filesets , however providing a complete discussion is beyond the scope of this page.","title":"Extending ANT"},{"location":"doc/workflow/#integration-challenges","text":"A simple approach to extending ANT with support for model management tasks would be to implement one standalone task for each language in Epsilon. However, such an approach demonstrates a number of integration and performance shortcomings which are discussed below. Since models are typically serialized in the file system, before a task is executed, the models it needs to access/modify must be parsed and loaded in memory. In the absence of a more elaborate framework, each model management task would have to take responsibility for loading and storing the models it operates on. Also, in most workflows, more than one task operates on the same models sequentially, and needlessly loading/storing the same models many times in the context of the same workflow is an expensive operation both time and memory-wise, particularly as the size of models increases. Another weakness of this primitive approach is limited inter-task communication. In the absence of a communication framework that allows model management tasks to exchange information with each other, it is often the case that many tasks end up performing the same (potentially expensive) queries on models. By contrast, an inter-task communication framework would enable time and resource intensive calculations to be performed once and their results to be communicated to all interested subsequent tasks. Having discussed ANT, Epsilon and the challenges their integration poses, the following sections presents the design of a solution that enables developers to invoke model management tasks in the context of ANT workflows. The solution consists of a core framework that addresses the challenges discussed above, a set of specific tasks, each of which implements a distinct model management activity, and a set of tasks that enable developers to initiate and manage transactions on models using the respective facilities provided by Epsilon's model connectivity layer .","title":"Integration Challenges"},{"location":"doc/workflow/#framework-design-and-core-tasks","text":"The role of the core framework, illustrated below, is to provide model loading and storing facilities as well as runtime communication facilities to the individual model management tasks that build atop it. This section provides a detailed discussion of the components it consists of. classDiagram class Task { -name: String -type: String } class VariableNestedElement { -ref: String -as: String -optional: String -ant: boolean } class EpsilonTask { -profile: Boolean +getProjectRepository(): ModelRepository +getProjectContext(): IEolContext } class ExecutableModuleTask { -src: String -code: String -models: ModelNestedElement[*] -exports: ExportNestedElement[*] -uses: UsesNestedElement[*] } class ModelNestedElement { -ref: String -as: String -optional: String } Task <|-- EpsilonTask EpsilonTask <|-- ExecutableModuleTask ExecutableModuleTask *-- ModelNestedElement: models * ExecutableModuleTask *-- UsesNestedElement: uses * ExecutableModuleTask *-- ExportsNestedElement: exports * ExportsNestedElement --|> VariableNestedElement UsesNestedElement --|> VariableNestedElement classDiagram class LoadModelTask { -name: String -type: String -aliases: String -parameters: ParameterNestedElement[*] } class ParameterNestedElement { -name: String -value: String -file: String } class StoreModelTask { -model: String -target: String } class DisposeModelTask { -model: String } class StartTransactionTask { -name: String -models: String } class CommitTransactionTask { -name: String } class RollbackTransactionTask { -name: String } EpsilonTask <|-- CommitTransactionTask EpsilonTask <|-- StartTransactionTask RollbackTransactionTask --|> EpsilonTask EpsilonTask <|-- LoadModelTask StoreModelTask --|> EpsilonTask DisposeModelTask --|> EpsilonTask DisposeModelsTask --|> EpsilonTask LoadModelTask *-- ParameterNestedElement: parameters *","title":"Framework Design and Core Tasks"},{"location":"doc/workflow/#the-epsilontask-task","text":"An ANT task can access the project in which it is contained by invoking the Task.getProject() method. To facilitate sharing of arbitrary information between tasks, ANT projects provide two convenience methods, namely addReference(String key, Object ref) and getReference(String key) : Object . The former is used to add key-value pairs, which are then accessible using the latter from other tasks of the project. To avoid loading models multiple times and to enable on-the-fly management of models from different Epsilon modules without needing to store and re-load the models after each task, a reference to a project-wide model repository has been added to the current ANT project using the addReference method discussed above. In this way, all the subclasses of the abstract EpsilonTask can invoke the getProjectRepository() method to access the project model repository. Also, to support a variable sharing mechanism that enables inter-task communication, the same technique has been employed; a shared context, accessible by all Epsilon tasks via the getProjectContext() method, has been added. Through this mechanism, model management tasks can export variables to the project context (e.g. traces or lists containing results of expensive queries) which other tasks can then reuse. EpsilonTask also specifies a profile attribute that defines if the execution of the task must be profiled using the profiling features provided by Epsilon. Profiling is a particularly important aspect of workflow execution, especially where model management languages are involved. The main reason is that model management languages tend to provide convenient features which can however be computationally expensive (such as the allInstances() EOL built-in feature that returns all the instances of a specific metaclass in the model) and when used more often than really needed, can significantly degrade the overall performance. The workflow leverages the model-transaction services provided by the model connectivity framework of Epsilon by providing three tasks for managing transactions in the context of workflows.","title":"The EpsilonTask task"},{"location":"doc/workflow/#model-loading-tasks","text":"The LoadModelTask (epsilon.loadModel) loads a model from an arbitrary location (e.g. file-system, database) and adds it to the project repository so that subsequent Epsilon tasks can query or modify it. Since Epsilon supports many modelling technologies (e.g. EMF, MDR, XML), the LoadModelTask defines only three generic attributes. The name attribute specifies the name of the model in the project repository. The type attribute specifies the modelling technology with which the model is captured and is used to resolve the technology-specific model loading functionality. Finally, the aliases attribute defines a comma-separated list of alternative names by which the model can be accessed in the model repository. The rest of the information needed to load a model is implementation-specific and is therefore provided through parameter nested elements, each one defining a pair of name - value attributes. As an example, a task for loading an EMF model that has a file-based ECore metamodel is displayed below. <epsilon.loadModel name= \"Tree1\" type= \"EMF\" > <parameter name= \"modelFile\" value= \"TreeInstance.ecore\" /> <parameter name= \"metamodelFile\" path= \"Tree.ecore\" /> <parameter name= \"isMetamodelFileBased\" value= \"true\" /> <parameter name= \"readOnLoad\" value= \"true\" /> </epsilon.loadModel> LoadEmfModelTask is a specialised version of LoadModelTask only for EMF models. While the type attribute is no longer available, the task still supports the name and aliases attributes. In addition, some of the values which had to be provided through parameter nested elements can now be set using regular attributes, such as modelFile , modelUri , metamodelFile (which implicitly indicates that the metamodel is file-based), metamodelUri , reuseUnmodifiedMetamodelFile (which can be set to \"false\" to avoid reusing file-based metamodels that have not been modified since the last time they were loaded), read (equivalent to readOnLoad ) and store (equivalent to storeOnDisposal ). The listing below shows the equivalent fragment required to produce the same result as in the listing above. <epsilon.emf.loadModel name= \"Tree1\" modelFile= \"TreeInstance.ecore\" metamodelFile= \"Tree.ecore\" />","title":"Model Loading Tasks"},{"location":"doc/workflow/#model-storing-task","text":"The StoreModelTask (epsilon.storeModel) is used to store a model residing in the project repository. The StoreModelTask defines three attributes: model (required): name of the model to be stored. targetUri (optional): URI where the model will be stored (e.g. \"file:/path/to/destination\"). target (optional): file path where the model will be stored (e.g. \"file.xmi\"). targetUri takes precedence over target . If neither is defined, then the model is stored in the location from which it was originally loaded.","title":"Model Storing Task"},{"location":"doc/workflow/#model-disposal-tasks","text":"When a model is no longer required by tasks of the workflow, it can be disposed using the epsilon.disposeModel task. The task provides the model attribute that defines the name of the model to be disposed. Also, the attribute-less epsilon.disposeModels task is provided that disposes all the models in the project model repository. This task is typically invoked when the model management part of the workflow has finished.","title":"Model Disposal Tasks"},{"location":"doc/workflow/#the-starttransaction-task","text":"The epsilon.startTransaction task defines a name attribute that identifies the transaction. It also optionally defines a comma-separated list of model names ( models ) that the transaction will manage. If the models attribute is not specified, the transaction involves all the models contained in the common project model repository.","title":"The StartTransaction Task"},{"location":"doc/workflow/#the-committransaction-and-rollbacktransaction-tasks","text":"The epsilon.commitTransaction and epsilon.rollbackTransaction tasks define a name attribute through which the transaction to be committed/rolled-back is located in the project's active transactions. If several active transactions with the same name exist the more recent one is selected. The example below demonstrates an exemplar usage of the epsilon.startTransaction and epsilon.rollbackTransaction tasks. In this example, two empty models Tree1 and Tree2 are loaded in lines 1,2. Then, the EOL task of line 4 queries the models and prints the number of instances of the Tree metaclass in each one of them (which is 0 for both). Then, in line 13, a transaction named T1 is started on model Tree1. The EOL task of line 15, creates a new instance of Tree in both Tree1 and Tree2 and prints the number of instances of Tree in the two models (which is 1 for both models). Then, in line 26, the T1 transaction is rolled-back and any changes done in its context to model Tree1 (but not Tree2) are undone. Therefore, the EOL task of line 28, which prints the number of instances of Tree in both models, prints 0 for Tree1 but 1 for Tree2. <epsilon.loadModel name= \"Tree1\" type= \"EMF\" > ... </epsilon.loadModel> <epsilon.loadModel name= \"Tree2\" type= \"EMF\" > ... </epsilon.loadModel> <epsilon.eol> <![CDATA[ Tree1!Tree.allInstances.size().println(); // prints 0 Tree2!Tree.allInstances.size().println(); // prints 0 ]]> <model ref= \"Tree1\" /> <model ref= \"Tree2\" /> </epsilon.eol> <epsilon.startTransaction name= \"T1\" models= \"Tree1\" /> <epsilon.eol> <![CDATA[ var t1 : new Tree1!Tree; Tree1!Tree.allInstances.size().println(); // prints 1 var t2 : new Tree2!Tree; Tree2!Tree.allInstances.size().println(); // prints 1 ]]> <model ref= \"Tree1\" /> <model ref= \"Tree2\" /> </epsilon.eol> <epsilon.rollbackTransaction name= \"T1\" /> <epsilon.eol> <![CDATA[ Tree1!Tree.allInstances.size().println(); // prints 0 Tree2!Tree.allInstances.size().println(); // prints 1 ]]> <model ref= \"Tree1\" /> <model ref= \"Tree2\" /> </epsilon.eol> classDiagram class ExecutableModuleTask { -src: String } class EmlTask { -useMatchTrace: String -exportTransformationTrace: String -exportMergeTrace: String } class EtlTask { -exportTransformationTrace: String } class EglTask { -target: String } class EclTask { -exportMatchTrace: String -useMatchTrace: String } class EvlTask { -failOnErrors: Boolean -failOnWarnings: Boolean -exportConstraintTrace: String } ExecutableModuleTask <|-- EclTask ExecutableModuleTask <|-- EvlTask ExecutableModuleTask <|-- EglTask EmlTask --|> ExecutableModuleTask EtlTask --|> ExecutableModuleTask EolTask --|> ExecutableModuleTask","title":"The CommitTransaction and RollbackTransaction Tasks"},{"location":"doc/workflow/#the-abstract-executable-module-task","text":"This task is the base of all the model management tasks presented in the following section. Its aim is to encapsulate the commonalities of Epsilon tasks in order to reduce duplication among them. As already discussed, in Epsilon, specifications of model management tasks are organized in executable modules. While modules can be stored anywhere, in the case of the workflow it is assumed that they are either stored as separate files in the file-system or they are provided inline within the worfklow. Thus, this abstract task defines an src attribute that specifies the path of the source file in which the Epsilon module is stored, but also supports inline specification of the source of the module. The two alternatives are demonstrated in the listings below. <project default= \"main\" > <target name= \"main\" > <epsilon.eol src= \"HelloWorld.eol\" /> </target> </project> <project default= \"main\" > <target name= \"main\" > <epsilon.eol> <![CDATA[ \"Hello world\".println(); ]]> </epsilon.eol> </target> </project> Optionally, users can enable debugging for the module to be run by setting the debug attribute to true . An example is shown below. If the module reaches a breakpoint, users will be able to run the code step by step and inspect the stack trace and its variables. <project default= \"main\" > <target name= \"main\" > <epsilon.eol src= \"HelloWorld.eol\" debug= \"true\" /> </target> </project> The task also defines the following nested elements:","title":"The Abstract Executable Module Task"},{"location":"doc/workflow/#0n-model-nested-elements","text":"Through the model nested elements, each task can define which of the models, loaded in the project repository it needs to access. Each model element defines three attributes. The ref attribute specifies the name of the model that the task needs to access, the as attribute defines the name by which the model will be accessible in the context of the task, and the aliases defines a comma-delimited sequence of aliases for the model in the context of the task.","title":"0..n model nested elements"},{"location":"doc/workflow/#0n-parameter-nested-elements","text":"The parameter nested elements enable users to communicate String parameters to tasks. Each parameter element defines a name and a value attribute. Before executing the module, each parameter element is transformed into a String variable with the respective name and value which is then made accessible to the module.","title":"0..n parameter nested elements"},{"location":"doc/workflow/#0n-exports-nested-elements","text":"To facilitate low-level integration between different Epsilon tasks, each task can export a number of variables to the project context, so that subsequent tasks can access them later. Each export nested element defines the three attributes. The ref attribute specifies the name of the variable to be exported, the as string attribute defines the name by which the variable is stored in the project context and the optional boolean attribute specifies whether the variable is mandatory. If optional is set to false and the module does not specify such a variable, an ANT BuildException is raised. If the ant attribute is set to true, the variable is exported as an ANT variable, as shown below. <project default= \"main\" > <target name= \"main\" > <epsilon.eol> var x = 1; <exports ref= \"x\" ant= \"true\" /> </epsilon.eol> <echo> ${x} </echo> <!-- Prints 1 --> </target> </project>","title":"0..n exports nested elements"},{"location":"doc/workflow/#0n-uses-nested-elements","text":"The uses nested elements enable tasks to import variables exported by previous Epsilon tasks. Each use element supports three attributes. The ref attribute specifies the name of the variable to be used. If there is no variable with this name in the project context, the ANT project properties are queried. This enables Epsilon modules to access ANT parameters (e.g. provided using command-line arguments). The as attribute specifies the name by which the variable is accessible in the context of the task. Finally, the optional boolean parameter specifies if the variable must exist in the project context. To better illustrate the runtime communication mechanism, a minimal example is provided below. In the first listing, Exporter.eol defines a String variable named x and assigns a value to it. The workflow below specifies that after executing Exporter.eol , it must export a variable named x with the new name y to the project context. Finally, it defines that before executing User.eol , it must query the project context for a variable named y and in case this is available, add the variable to the module's context and then execute it. Thus, the result of executing the workflow is Some String printed in the output console. // Exporter.eol var x : String = \"Some string\"; // User.eol z.println(); <epsilon.eol src= \"Exporter.eol\" > <exports ref= \"x\" as= \"y\" /> </epsilon.eol> <epsilon.eol src= \"User.eol\" > <uses ref= \"y\" as= \"z\" /> </epsilon.eol>","title":"0..n uses nested elements"},{"location":"doc/workflow/#model-management-tasks","text":"Having discussed the core framework, this section presents the model management tasks that have been implemented atop it, using languages of the Epsilon platform.","title":"Model Management Tasks"},{"location":"doc/workflow/#generic-model-management-task","text":"The epsilon.eol task executes an EOL module, defined using the src attribute on the models that are specified using the model nested elements.","title":"Generic Model Management Task"},{"location":"doc/workflow/#model-validation-task","text":"The epsilon.evl task executes an EVL module, defined using the src attribute on the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes: failOnErrors : Errors are the results of unsatisfied constraints. Setting the value of this attribute to true (default is false ) causes a BuildException to be raised if one or more errors are identified during the validation process. failOnWarnings : Similarly to errors, warnings are the results of unsatisfied critiques. Setting the value of this attribute to true (default is also false ) causes a BuildException to be raised if one or more warnings are identified during the validation process. exportConstraintTrace : This attribute enables developers to export the internal constraint trace constructed during model validation to the project context so that it can be later accessed by other tasks - which could for example attempt to automatically repair the identified inconsistencies. exportAsModel : Setting the value of this attribute causes the task to export the results of the validation as a new in-memory Java model with the specified name in the project repository. The exported model is essentially a wrapper for all the unsatisfied constraints identified by EVL.","title":"Model Validation Task"},{"location":"doc/workflow/#model-to-model-transformation-task","text":"The epsilon.etl task executes an ETL module, defined using the src attribute to transform between the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the exportTransformationTrace attribute that enables the developer to export the internal transformation trace to the project context. In this way this trace can be reused by subsequent tasks; for example another task can serialize it in the form of a separate traceability model.","title":"Model-to-Model Transformation Task"},{"location":"doc/workflow/#model-comparison-task","text":"The epsilon.ecl task executes an ECL module, defined using the src attribute to establish matches between elements of the models that are specified using the model nested elements. In addition to the attributes defined by ExecutableModuleTask , this task also provides the exportMatchTrace attribute that enables users to export the match-trace calculated during the comparison as a named variable to the project context so that subsequent tasks can reuse it. For example, as discussed in the sequel, an EML model merging task can use it as a means of identifying correspondences on which to perform merging. In another example, the match-trace can be stored by a subsequent EOL task in the form of an stand-alone weaving model.","title":"Model Comparison Task"},{"location":"doc/workflow/#model-merging-task","text":"The epsilon.eml task executes an EML module, defined using the src attribute on the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes: useMatchTrace : To merge a set of models, an EML module needs an established match-trace between elements of the models. The useMatchTrace attribute enables the EML task to use a match-trace exported by a preceding ECL task (using its exportMatchTrace attribute). exportMergeTrace, exportTransformationTrace : Similarly to ETL, through these attributes an EML task can export the internal traces calculated during merging for subsequent tasks to use.","title":"Model Merging Task"},{"location":"doc/workflow/#model-to-text-transformation-task","text":"To support model to text transformations, EglTask (epsilon.egl) task is provided that executes an Epsilon Generation Language (EGL) module. In addition to the attributes defined by ExecutableModuleTask , EglTask also defines the following attributes: target : Defines a file in which all of the generated text will be stored. templateFactoryType : Defines the Java class that will be instantiated to provide a TemplateFactory for the EGL program. The specified class must be on the classpath and must subtype EglTemplateFactory . EglTask may nest any number of formatter elements. The formatter nested element has the following attributes: implementation (required) : Defines the Java class that will be instantiated to provide a Formatter for the EGL program. The specified class must be on the classpath and must subtype Formatter .","title":"Model-to-Text Transformation Task"},{"location":"doc/workflow/#model-migration-task","text":"To support model migration, FlockTask (epsilon.flock) is provided for executing an Epsilon Flock module. In addition to the attributes defined by ExecutableModuleTask , FlockTask also defines the following mandatory attributes: originalModel : Specifies which of the currently loaded models should be used as the source of the model migration. migratedModel : Specifies which of the currently loaded models should be used as the target of the model migration. <model> nested elements still required Please note that originalModel and migratedModel refer to models specified using <model> nested elements under epsilon.flock .","title":"Model Migration Task"},{"location":"doc/workflow/#pattern-matching-task","text":"The epsilon.epl task executes an EPL module, defined using the src attribute to perform pattern matching on the models that are specified using the model nested elements. In addition to the attributes defined by the ExecutableModuleTask, this task also provides the following attributes. repeatWhileMatches : A boolean specifying whether the pattern matching process should continue to execute for as long as matches are found. maxLoops : An integer specifying the maximum number of pattern matching iterations. exportAs : The name under which the computed pattern match model should be made available to other Epsilon tasks of the workflow.","title":"Pattern Matching Task"},{"location":"doc/workflow/#model-generation-task","text":"The epsilon.emg tasks extends the epsilon.epl task and executes an EMG model generator. In addition to EPL's attributes, the task also provides the following attribute. seed (optional): A long specifying the seed to drive the random number generator that underpins the random aspects of model generation. If a seed is not specified, a random seed will be used and the generator will (likely) produce a different model every time it is executed. Fixing the seed produces repeatable results across executions.","title":"Model Generation Task"},{"location":"doc/workflow/#dataset-extraction-task","text":"The epsilon.pinset task executes a Pinset module specified using the src attribute to generate CSV datasets from models. It also provides the following attribute. outputFolder (optional): A path specifying the folder where the CSV files will be generated. If not provided, the CSVs will be created in the same folder where the .pinset source file resides.","title":"Dataset Extraction Task"},{"location":"doc/workflow/#java-class-static-method-execution-task","text":"The epsilon.java.executeStaticMethod task executes a parameter-less static method, defined using the method attribute, of a Java class, defined using the javaClass attribute. This task can be useful for setting up the infrastructure of Xtext-based languages.","title":"Java Class Static Method Execution Task"},{"location":"doc/workflow/#for-task","text":"The epsilon.for task iterates over the files in a fileset and executes its nested tasks. An example that uses epsilon.for to run an EOL program on XML files contained in a folder called loop is show below. <project default= \"main\" > <target name= \"main\" > <!-- Load t1.xml once as Ta --> <epsilon.xml.loadModel name= \"Ta\" file= \"t1.xml\" /> <!-- For every XML file in the loop directory --> <epsilon.for> <fileset dir= \"loop\" includes= \"*.xml\" /> <!-- Load the file as Tb --> <epsilon.xml.loadModel name= \"Tb\" file= \"loop/${it}\" /> <!-- Run an EOL program on Ta and Tb --> <epsilon.eol> Ta!t_tree.all.a_name.println(); Tb!t_tree.all.a_name.println(); <model ref= \"Ta\" /> <model ref= \"Tb\" /> </epsilon.eol> <!-- Dispose of Tb --> <epsilon.disposeModel model= \"Tb\" /> </epsilon.for> </target> </project> The complete source code for this example is in Epsilon's Git repo .","title":"For Task"},{"location":"doc/workflow/#additional-resources","text":"Additional resources about the Epsilon ANT tasks are available here .","title":"Additional Resources"},{"location":"doc/articles/","text":"Articles \u00b6 This page links to more than 60 articles on various aspects of Epsilon. Should you find that an article is outdated, please let us know . Epsilon Object Language \u00b6 EOL syntax updates : This article summarizes changes in the EOL concrete syntax over time. Extended Properties : This article demonstrates the extended properties mechanism in EOL (and by inheritance, in all languages in Epsilon). Call Java from Epsilon : This article demonstrates how to create Java objects, access their properties and call their methods from Epsilon languages. Running Epsilon from Java : This article demonstrates how to parse and execute Epsilon programs and load models from headless Java applications. Call Java functional interfaces from Epsilon : This article demonstrates how to call native methods which take functions as their parameter, using lambdas and streams directly from Epsilon using EOL syntax. Profiling Epsilon Programs : This article demonstrates how to profile Epsilon programs using the platform's built-in profiling tools. EOL Interpreter View : This article demonstrates an Eclipse view for running EOL scripts against selected model elements in EMF-based editors. Epsilon Validation Language \u00b6 EVL-GMF Integration : This article demonstrates evaluating EVL constraints from within a GMF-based editor. EVL-EMF Validation Integration : This article demonstrates contributing EVL constraints to EMF's validation framework. Parallel Execution : This article explains how to use the parallel module implementations for EOL and rule-based languages like EVL. Epsilon Generation Language \u00b6 Code Generation Tutorial with EGL : This article demonstrates using EGL templates to generate HTML files from an XML document. Using template operations in EGL : This article demonstrates template operations for writing re-usable code in EGL (the model-to-text language of Epsilon). EGL as a server-side language : This article demonstrates using EGL (the model-to-text language of Epsilon) in Tomcat to produce HTML pages from EMF models on the fly. Co-ordinating EGL templates with EGX : This article demonstrates how to parameterize EGL templates and execute them multiple times to produce multiple files. Re-using EGL templates : This article demonstrates how to invoke other EGL templates and direct their output to calling EGL template. EGL Patch Templates : This article demonstrates how to patch existing files with EGL. Epsilon Transformation Language \u00b6 XML to EMF Transformation : This article shows how to transform an XML document into an EMF model using the Epsilon Transformation Language and Epsilon's XML driver Epsilon and EMF models \u00b6 Emfatic language reference : Emfatic is a language designed to represent EMF Ecore models in a textual form. This article details the syntax of Emfatic and the mapping between Emfatic declarations and the corresponding Ecore constructs. Reflective EMF tutorial : This tutorial demonstrates how to create an EMF Ecore metamodel and a sample model that conforms to it reflectively (i.e. without generating any code). Epsilon and EMF : Frequently-asked questions related to querying and modifying EMF-based models with Epsilon. The EMF EPackage Registry View : This article demonstrates the EPackage Registry view which allows developers to inspect the contents of the registered EMF EPackages. Exeed annotation reference : This article lists the annotations you can use on your metamodels to customize the look of the Exeed model editor. Inspecting EMF models with Exeed : This article demonstrates how you can use Exeed to inspect the structure of your EMF models. Working with custom EMF resources : This article demonstrates how you can work with custom EMF resources in Epsilon. Parsing XML documents as EMF models with Flexmi : This article demonstrates how you can use Flexmi to parse XML documents in a fuzzy manner as instances of Ecore metamodels. Modularity Mechanisms in Flexmi : This article demonstrates how you can break down Flexmi models over multiple files and use templates to capture complex reusable structures in your models. Connecting to CDO repositories : This article shows how to connect to an Eclipse Connected Data Objects model repository from Epsilon. Epsilon and UML models \u00b6 Managing Profiled UML Models in Epsilon : This article shows how to create and query profiled Eclipse UML models using Epsilon's core language. Epsilon and Simulink models \u00b6 Scripting Simulink models using Epsilon : In this article we demonstrate how you can query and modify Simulink models in Epsilon. Managing Matlab Simulink/Stateflow models from Epsilon : This tutorial shows you how to manipulate Simulink and Stateflow blocks from within Epsilon. Epsilon and other types of models \u00b6 Scripting XML documents using Epsilon : In this article we demonstrate how you can create, query and modify plain standalone XML documents (i.e. no XSD/DTD needed) in Epsilon programs using the PlainXML driver. Scripting XML documents that conform to an XSD schema using Epsilon : In this article we demonstrate how you can create, query and modify XML documents backed by an XSD schema in Epsilon. Scripting YAML documents using Epsilon : This article demonstrates how you can query YAML documents with Epsilon programs using the YAML driver. Scripting CSV files using Epsilon : This article demonstrates how you can query CSV files with Epsilon programs using the CSV driver. Scripting Excel spreadsheets using Epsilon : In this article we demonstrate how you can create, query and modify Excel spreadsheets in Epsilon programs. Scripting HTML documents using Epsilon : In this article we demonstrate how you can create, query and modify HTML documents in Epsilon programs using the HTML driver. Scripting BibTeX files using Epsilon : In this article we demonstrate how you can query a list of references stored in BibTeX files with Epsilon programs using the BibTeX driver. Treating Java code as a model in Epsilon : In this article we demonstrate how Epsilon languages can query Java code as if it were a model, using a driver that builds on the Eclipse Java Development Tools. Eugenia \u00b6 Fundamentals \u00b6 Eugenia GMF Tutorial : This article provides a guide to using Eugenia for developing GMF editors, as well as its complete list of features and supported annotations. Customizing an editor generated with Eugenia : This article demonstrates Eugenia's polishing transformations, which can be used to customize GMF editors in a systematic and reproducible way. Applying source code patches to an editor generated with Eugenia : This article demonstrates Eugenia's patch generation and application functionality, which can be used to customize the Java source code generated by GMF in a systematic and reproducible way. Eugenia: Automated Invocation with Ant : This article demonstrates how to run Eugenia from Ant, and some of the additional features offered through the Ant task. Recipes \u00b6 Eugenia: Nodes with images instead of shapes : This article shows how to create nodes in your GMF editor that are represented with images (png, jpg etc.) instead of the standard GMF shapes (rectangle, ellipse etc.) Eugenia: Nodes with images defined at run-time : This article addresses the case where the end-user needs to set an image for each node at runtime. Eugenia: Nodes with a centred layout : This article shows how to create nodes in your GMF editor whose contents are centred both vertically and horizontally. Eugenia: Phantom nodes in GMF editors : This article demonstrates how to define GMF phantom nodes in Eugenia. Picto \u00b6 Visualising Models with Picto : Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. The article introduces Picto and shows the tool in action. Drill-Down Sequence Diagrams with Picto : This article demonstrates using Picto and its PlantUML integration to generate drill-down sequence diagrams from models conforming to a minimal EMF-based sequence diagram language. Visualising Models with Picto and Sirius : This article demonstrates using Picto to produce dynamic web-based views (pie and bar charts) from Sirius-based models. Visualising Xtext models with Picto : This article shows how Picto can be used to produce graphical views from Xtext-based models. Table visualisations with Picto and Pinset : This article shows how to create table views in Picto that render static CSV files or those generated with a Pinset transformation. Embedding Picto views in static Markdown or HTML documents : This article shows how to embed Picto views to create Markdown or HTML-based model reports. Workflow (ANT Tasks) \u00b6 Running Epsilon's ANT Tasks from Command Line : This article shows how to run Epsilon's ANT tasks from command line or in the context of a CI build. Development Environments \u00b6 VS Code : This article provides an overview of how you can edit and run Epsilon programs in the VS Code IDE. Sublime : This repository provides a package that adds Epsilon syntax highlighting capabilities to the Sublime editor. Human-Usable Textual Notation \u00b6 Using the Human-Usable Textual Notation (HUTN) in Epsilon : This article demonstrates how to specify models using a textual notation. Customising Epsilon HUTN documents with configuration : This article demonstrates how to customise Epsilon HUTN documents with a configuration model. Compliance of Epsilon HUTN to the OMG HUTN Standard : This article summarises the similarities and differences between the Epsilon HUTN implementation and the OMG HUTN standard. Teaching Material \u00b6 MDE Exercises : This article provides a number of exercises which enable you to test your knowledge on MDE, EMF and Epsilon. Epsilon Playground : The Epsilon Playground is a web application for fiddling with metamodelling, modelling and automated model management using Emfatic, Flexmi and Epsilon's languages. Technical Support \u00b6 Troubleshooting : A list of common issues that (particularly new) users of Epsilon tend to run into. Constructing a helpful minimal example : From time to time, you may run into a problem when using Epsilon or find a bug. This article describes how to construct a minimal example that we can use to reproduce the problem on our machine. Extending Epsilon \u00b6 Developing a new Epsilon Language : This article demonstrates how to develop a new language on top of Epsilon. Developing a new EMC Driver : This article demonstrates how to develop a new driver for Epsilon's Model Connectivity layer (EMC). Monitoring and Instrumenting Epsilon Programs : This article demonstrates how Epsilon interpreters provide support for hooking into the execution of model management programs. Installation \u00b6 Working with Epsilon 1.x : This article contains instructions for installing legacy versions of Epsilon prior to 2.0. Setting up Eclipse for Epsilon development : This article explains how to easily set up and configure an Eclipse IDE for contributing to Epsilon. Epsilon Developers \u00b6 Running Epsilon from source : This article demonstrates how to run Epsilon from source in your machine. Call for User Stories : This is a kind request to all Epsilon Users. Manage the Epsilon website locally : This article demonstrates how to manage the Epsilon website in your machine. Epsilon development principles : These are the guiding principles used by the developers of Epsilon. Resolved bugs : This article discusses the different types of resolved bugs in Epsilon. Managing the target platform : This article outlines how to manage the target platform that Epsilon is built against. Adding new plugins : This article outlines the process of adding new plugins to the main Epsilon repository. Preparing the macOS distribution : This article outlines the process of signing the Eclipse macOS distribution. Publishing to the EpsilonLabs Updatesite : This article outlines the process for publishing a plugin (EMC driver/language/tool) from the EpsilonLabs Github organisation to the EpsilonLabs updatesite. Releasing a new version of Epsilon : This article lists all the tasks required for releasing a version of Epsilon. Releasing a new version to Maven Central : This article outlines how to release a new version of the Epsilon standalone artifacts to Maven Central.","title":"Articles"},{"location":"doc/articles/#articles","text":"This page links to more than 60 articles on various aspects of Epsilon. Should you find that an article is outdated, please let us know .","title":"Articles"},{"location":"doc/articles/#epsilon-object-language","text":"EOL syntax updates : This article summarizes changes in the EOL concrete syntax over time. Extended Properties : This article demonstrates the extended properties mechanism in EOL (and by inheritance, in all languages in Epsilon). Call Java from Epsilon : This article demonstrates how to create Java objects, access their properties and call their methods from Epsilon languages. Running Epsilon from Java : This article demonstrates how to parse and execute Epsilon programs and load models from headless Java applications. Call Java functional interfaces from Epsilon : This article demonstrates how to call native methods which take functions as their parameter, using lambdas and streams directly from Epsilon using EOL syntax. Profiling Epsilon Programs : This article demonstrates how to profile Epsilon programs using the platform's built-in profiling tools. EOL Interpreter View : This article demonstrates an Eclipse view for running EOL scripts against selected model elements in EMF-based editors.","title":"Epsilon Object Language"},{"location":"doc/articles/#epsilon-validation-language","text":"EVL-GMF Integration : This article demonstrates evaluating EVL constraints from within a GMF-based editor. EVL-EMF Validation Integration : This article demonstrates contributing EVL constraints to EMF's validation framework. Parallel Execution : This article explains how to use the parallel module implementations for EOL and rule-based languages like EVL.","title":"Epsilon Validation Language"},{"location":"doc/articles/#epsilon-generation-language","text":"Code Generation Tutorial with EGL : This article demonstrates using EGL templates to generate HTML files from an XML document. Using template operations in EGL : This article demonstrates template operations for writing re-usable code in EGL (the model-to-text language of Epsilon). EGL as a server-side language : This article demonstrates using EGL (the model-to-text language of Epsilon) in Tomcat to produce HTML pages from EMF models on the fly. Co-ordinating EGL templates with EGX : This article demonstrates how to parameterize EGL templates and execute them multiple times to produce multiple files. Re-using EGL templates : This article demonstrates how to invoke other EGL templates and direct their output to calling EGL template. EGL Patch Templates : This article demonstrates how to patch existing files with EGL.","title":"Epsilon Generation Language"},{"location":"doc/articles/#epsilon-transformation-language","text":"XML to EMF Transformation : This article shows how to transform an XML document into an EMF model using the Epsilon Transformation Language and Epsilon's XML driver","title":"Epsilon Transformation Language"},{"location":"doc/articles/#epsilon-and-emf-models","text":"Emfatic language reference : Emfatic is a language designed to represent EMF Ecore models in a textual form. This article details the syntax of Emfatic and the mapping between Emfatic declarations and the corresponding Ecore constructs. Reflective EMF tutorial : This tutorial demonstrates how to create an EMF Ecore metamodel and a sample model that conforms to it reflectively (i.e. without generating any code). Epsilon and EMF : Frequently-asked questions related to querying and modifying EMF-based models with Epsilon. The EMF EPackage Registry View : This article demonstrates the EPackage Registry view which allows developers to inspect the contents of the registered EMF EPackages. Exeed annotation reference : This article lists the annotations you can use on your metamodels to customize the look of the Exeed model editor. Inspecting EMF models with Exeed : This article demonstrates how you can use Exeed to inspect the structure of your EMF models. Working with custom EMF resources : This article demonstrates how you can work with custom EMF resources in Epsilon. Parsing XML documents as EMF models with Flexmi : This article demonstrates how you can use Flexmi to parse XML documents in a fuzzy manner as instances of Ecore metamodels. Modularity Mechanisms in Flexmi : This article demonstrates how you can break down Flexmi models over multiple files and use templates to capture complex reusable structures in your models. Connecting to CDO repositories : This article shows how to connect to an Eclipse Connected Data Objects model repository from Epsilon.","title":"Epsilon and EMF models"},{"location":"doc/articles/#epsilon-and-uml-models","text":"Managing Profiled UML Models in Epsilon : This article shows how to create and query profiled Eclipse UML models using Epsilon's core language.","title":"Epsilon and UML models"},{"location":"doc/articles/#epsilon-and-simulink-models","text":"Scripting Simulink models using Epsilon : In this article we demonstrate how you can query and modify Simulink models in Epsilon. Managing Matlab Simulink/Stateflow models from Epsilon : This tutorial shows you how to manipulate Simulink and Stateflow blocks from within Epsilon.","title":"Epsilon and Simulink models"},{"location":"doc/articles/#epsilon-and-other-types-of-models","text":"Scripting XML documents using Epsilon : In this article we demonstrate how you can create, query and modify plain standalone XML documents (i.e. no XSD/DTD needed) in Epsilon programs using the PlainXML driver. Scripting XML documents that conform to an XSD schema using Epsilon : In this article we demonstrate how you can create, query and modify XML documents backed by an XSD schema in Epsilon. Scripting YAML documents using Epsilon : This article demonstrates how you can query YAML documents with Epsilon programs using the YAML driver. Scripting CSV files using Epsilon : This article demonstrates how you can query CSV files with Epsilon programs using the CSV driver. Scripting Excel spreadsheets using Epsilon : In this article we demonstrate how you can create, query and modify Excel spreadsheets in Epsilon programs. Scripting HTML documents using Epsilon : In this article we demonstrate how you can create, query and modify HTML documents in Epsilon programs using the HTML driver. Scripting BibTeX files using Epsilon : In this article we demonstrate how you can query a list of references stored in BibTeX files with Epsilon programs using the BibTeX driver. Treating Java code as a model in Epsilon : In this article we demonstrate how Epsilon languages can query Java code as if it were a model, using a driver that builds on the Eclipse Java Development Tools.","title":"Epsilon and other types of models"},{"location":"doc/articles/#eugenia","text":"","title":"Eugenia"},{"location":"doc/articles/#fundamentals","text":"Eugenia GMF Tutorial : This article provides a guide to using Eugenia for developing GMF editors, as well as its complete list of features and supported annotations. Customizing an editor generated with Eugenia : This article demonstrates Eugenia's polishing transformations, which can be used to customize GMF editors in a systematic and reproducible way. Applying source code patches to an editor generated with Eugenia : This article demonstrates Eugenia's patch generation and application functionality, which can be used to customize the Java source code generated by GMF in a systematic and reproducible way. Eugenia: Automated Invocation with Ant : This article demonstrates how to run Eugenia from Ant, and some of the additional features offered through the Ant task.","title":"Fundamentals"},{"location":"doc/articles/#recipes","text":"Eugenia: Nodes with images instead of shapes : This article shows how to create nodes in your GMF editor that are represented with images (png, jpg etc.) instead of the standard GMF shapes (rectangle, ellipse etc.) Eugenia: Nodes with images defined at run-time : This article addresses the case where the end-user needs to set an image for each node at runtime. Eugenia: Nodes with a centred layout : This article shows how to create nodes in your GMF editor whose contents are centred both vertically and horizontally. Eugenia: Phantom nodes in GMF editors : This article demonstrates how to define GMF phantom nodes in Eugenia.","title":"Recipes"},{"location":"doc/articles/#picto","text":"Visualising Models with Picto : Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. The article introduces Picto and shows the tool in action. Drill-Down Sequence Diagrams with Picto : This article demonstrates using Picto and its PlantUML integration to generate drill-down sequence diagrams from models conforming to a minimal EMF-based sequence diagram language. Visualising Models with Picto and Sirius : This article demonstrates using Picto to produce dynamic web-based views (pie and bar charts) from Sirius-based models. Visualising Xtext models with Picto : This article shows how Picto can be used to produce graphical views from Xtext-based models. Table visualisations with Picto and Pinset : This article shows how to create table views in Picto that render static CSV files or those generated with a Pinset transformation. Embedding Picto views in static Markdown or HTML documents : This article shows how to embed Picto views to create Markdown or HTML-based model reports.","title":"Picto"},{"location":"doc/articles/#workflow-ant-tasks","text":"Running Epsilon's ANT Tasks from Command Line : This article shows how to run Epsilon's ANT tasks from command line or in the context of a CI build.","title":"Workflow (ANT Tasks)"},{"location":"doc/articles/#development-environments","text":"VS Code : This article provides an overview of how you can edit and run Epsilon programs in the VS Code IDE. Sublime : This repository provides a package that adds Epsilon syntax highlighting capabilities to the Sublime editor.","title":"Development Environments"},{"location":"doc/articles/#human-usable-textual-notation","text":"Using the Human-Usable Textual Notation (HUTN) in Epsilon : This article demonstrates how to specify models using a textual notation. Customising Epsilon HUTN documents with configuration : This article demonstrates how to customise Epsilon HUTN documents with a configuration model. Compliance of Epsilon HUTN to the OMG HUTN Standard : This article summarises the similarities and differences between the Epsilon HUTN implementation and the OMG HUTN standard.","title":"Human-Usable Textual Notation"},{"location":"doc/articles/#teaching-material","text":"MDE Exercises : This article provides a number of exercises which enable you to test your knowledge on MDE, EMF and Epsilon. Epsilon Playground : The Epsilon Playground is a web application for fiddling with metamodelling, modelling and automated model management using Emfatic, Flexmi and Epsilon's languages.","title":"Teaching Material"},{"location":"doc/articles/#technical-support","text":"Troubleshooting : A list of common issues that (particularly new) users of Epsilon tend to run into. Constructing a helpful minimal example : From time to time, you may run into a problem when using Epsilon or find a bug. This article describes how to construct a minimal example that we can use to reproduce the problem on our machine.","title":"Technical Support"},{"location":"doc/articles/#extending-epsilon","text":"Developing a new Epsilon Language : This article demonstrates how to develop a new language on top of Epsilon. Developing a new EMC Driver : This article demonstrates how to develop a new driver for Epsilon's Model Connectivity layer (EMC). Monitoring and Instrumenting Epsilon Programs : This article demonstrates how Epsilon interpreters provide support for hooking into the execution of model management programs.","title":"Extending Epsilon"},{"location":"doc/articles/#installation","text":"Working with Epsilon 1.x : This article contains instructions for installing legacy versions of Epsilon prior to 2.0. Setting up Eclipse for Epsilon development : This article explains how to easily set up and configure an Eclipse IDE for contributing to Epsilon.","title":"Installation"},{"location":"doc/articles/#epsilon-developers","text":"Running Epsilon from source : This article demonstrates how to run Epsilon from source in your machine. Call for User Stories : This is a kind request to all Epsilon Users. Manage the Epsilon website locally : This article demonstrates how to manage the Epsilon website in your machine. Epsilon development principles : These are the guiding principles used by the developers of Epsilon. Resolved bugs : This article discusses the different types of resolved bugs in Epsilon. Managing the target platform : This article outlines how to manage the target platform that Epsilon is built against. Adding new plugins : This article outlines the process of adding new plugins to the main Epsilon repository. Preparing the macOS distribution : This article outlines the process of signing the Eclipse macOS distribution. Publishing to the EpsilonLabs Updatesite : This article outlines the process for publishing a plugin (EMC driver/language/tool) from the EpsilonLabs Github organisation to the EpsilonLabs updatesite. Releasing a new version of Epsilon : This article lists all the tasks required for releasing a version of Epsilon. Releasing a new version to Maven Central : This article outlines how to release a new version of the Epsilon standalone artifacts to Maven Central.","title":"Epsilon Developers"},{"location":"doc/articles/cdo-emc/","text":"Connecting to CDO repositories \u00b6 Since version 2.5.0, Epsilon includes an EMC driver to connect to an Eclipse CDO model repository. Although CDO is EMF-based, and its model resources work relatively the same as standard EMF resources, accessing some of its additional features (e.g. branching and prefetching) requires using a specific model driver. Prerequisites \u00b6 When installing Epsilon, ensure that the \"Epsilon CDO Model Support\" feature in the \"Epsilon CDO Integration\" group is selected. If you are using the Epsilon launch configurations from Eclipse, you will also need the \"Epsilon CDO Model Support Developer Tools Feature\" in order to add CDO models. How to use from Eclipse \u00b6 From an Epsilon launch confgiuration, go to the \"Models\" tab and click on \"Add...\". Tick the \"Show all model types\" box, to make \"CDO Model\" appear. Select \"CDO Model\" and click on OK. You will find the following options: Identification: this group works the same as any other model. Repository access: this group indicates how to locate the model. URL: this is the same URL as that shown in the \"CDO Repositories\" view, removing the name of the repository (e.g. jvm://local for a JVM-only local repository). Repository: this is the name of the repository (same string that you entered from \"Repository name\" in CDO during creation). For instance, repo . Branch: this can be left empty if using the main branch, or you can enter the full path to the branch in question. Note that branch1 created off from the main branch should be entered as MAIN/branch1 , rather than as just branch1 . (If you make a mistake, the driver will list the paths to all available branches.) Path: this is the absolute path (starting with / ) to the relevant model resource in your CDO repository (e.g. /model ). Create if missing: if ticked, the driver will automatically create the model resource if it does not exist yet in your repository. Prefetching: this section controls CDO's options for automatically prefetching elements from the model, to reduce the number of roundtrips done over the network. Initial collection prefetch size: when first fetching a collection, how many elements to fetch in advance. 0 means \"do not fetch any objects until the lists are accessed\". Collection resolving chunk size: how many elements to fetch in one chunk when needed. Revision prefetch size: when accessing revisions, how many revisions to fetch per chunk. Use CDO model-based feature analyzer: if enabled, CDO will track which features are being traversed and prefetch those in later accesses of objects of the same EClass. Load/Store Options: Due to the fact that CDO works like a database rather than like a file-based model (where you can immediately connect to it and access its entire contents), the \"Read on load\" option is not used by the driver. The \"Store on disposal\" option is honored, however. If ticked, the driver will commit a new revision when the model is disposed. If left unticked, the driver will discard the transaction without committing anything to the repository. For an example with step-by-step instructions, please consult this project on Github . How to use from Java \u00b6 You will need to create a new instance of the CDOModel class, and use setter methods to configure it appropriately. The setter methods match the options listed above. For concrete examples, please consult the JUnit tests for the driver .","title":"Connecting to CDO repositories"},{"location":"doc/articles/cdo-emc/#connecting-to-cdo-repositories","text":"Since version 2.5.0, Epsilon includes an EMC driver to connect to an Eclipse CDO model repository. Although CDO is EMF-based, and its model resources work relatively the same as standard EMF resources, accessing some of its additional features (e.g. branching and prefetching) requires using a specific model driver.","title":"Connecting to CDO repositories"},{"location":"doc/articles/cdo-emc/#prerequisites","text":"When installing Epsilon, ensure that the \"Epsilon CDO Model Support\" feature in the \"Epsilon CDO Integration\" group is selected. If you are using the Epsilon launch configurations from Eclipse, you will also need the \"Epsilon CDO Model Support Developer Tools Feature\" in order to add CDO models.","title":"Prerequisites"},{"location":"doc/articles/cdo-emc/#how-to-use-from-eclipse","text":"From an Epsilon launch confgiuration, go to the \"Models\" tab and click on \"Add...\". Tick the \"Show all model types\" box, to make \"CDO Model\" appear. Select \"CDO Model\" and click on OK. You will find the following options: Identification: this group works the same as any other model. Repository access: this group indicates how to locate the model. URL: this is the same URL as that shown in the \"CDO Repositories\" view, removing the name of the repository (e.g. jvm://local for a JVM-only local repository). Repository: this is the name of the repository (same string that you entered from \"Repository name\" in CDO during creation). For instance, repo . Branch: this can be left empty if using the main branch, or you can enter the full path to the branch in question. Note that branch1 created off from the main branch should be entered as MAIN/branch1 , rather than as just branch1 . (If you make a mistake, the driver will list the paths to all available branches.) Path: this is the absolute path (starting with / ) to the relevant model resource in your CDO repository (e.g. /model ). Create if missing: if ticked, the driver will automatically create the model resource if it does not exist yet in your repository. Prefetching: this section controls CDO's options for automatically prefetching elements from the model, to reduce the number of roundtrips done over the network. Initial collection prefetch size: when first fetching a collection, how many elements to fetch in advance. 0 means \"do not fetch any objects until the lists are accessed\". Collection resolving chunk size: how many elements to fetch in one chunk when needed. Revision prefetch size: when accessing revisions, how many revisions to fetch per chunk. Use CDO model-based feature analyzer: if enabled, CDO will track which features are being traversed and prefetch those in later accesses of objects of the same EClass. Load/Store Options: Due to the fact that CDO works like a database rather than like a file-based model (where you can immediately connect to it and access its entire contents), the \"Read on load\" option is not used by the driver. The \"Store on disposal\" option is honored, however. If ticked, the driver will commit a new revision when the model is disposed. If left unticked, the driver will discard the transaction without committing anything to the repository. For an example with step-by-step instructions, please consult this project on Github .","title":"How to use from Eclipse"},{"location":"doc/articles/cdo-emc/#how-to-use-from-java","text":"You will need to create a new instance of the CDOModel class, and use setter methods to configure it appropriately. The setter methods match the options listed above. For concrete examples, please consult the JUnit tests for the driver .","title":"How to use from Java"},{"location":"doc/articles/debugger/","text":"Epsilon Debugger \u00b6 Epsilon includes an interactive Eclipse-based debugger, which is demonstrated in the screencast below.","title":"Epsilon Debugger"},{"location":"doc/articles/debugger/#epsilon-debugger","text":"Epsilon includes an interactive Eclipse-based debugger, which is demonstrated in the screencast below.","title":"Epsilon Debugger"},{"location":"doc/articles/egl-patch/","text":"EGL Patch Templates \u00b6 A patch file (also called a patch for short) is a text file that consists of a list of differences and is produced, usually, by running the related the diff program with the original and updated file as arguments. The differences follow the diff format . A patch processor can read a patch file and use the contents as a set of instructions. By following those instructions, a target file can be modified to match the changes in the patch file. Although patches are usually created using a diff tool, it is also possible to write them manually and then use the patch processor to modify a file. This is the approach we provide via EGL patch rules. EGL Diff Format \u00b6 In EGL we support a custom diff format. A line starting with + represents the addition of a line, i.e. this line will be added to the file. A line starting with - represents the deletion of a line, i.e, this line will be removed from the file. A line containing only ... indicates a block of lines to keep, i.e. all lines until the next diff/match will be kept. A line containing only --- indicates a block of lines to remove, i.e. all lines until the next diff/match will be removed. A line with no diff information is used as a match and will be kept. EGL Diff Processor \u00b6 The EGl diff processor uses un-diffed lines to match sections of the file and then uses any diff entries till the next un-diffed lines to modify (add/remove/keep) the file. Deletions will also be used to match locations. All additions before a deletion/un-diff will be inserted before the deleted/un-diffed line. All additions after a deletion/un-diff will be inserted after the deleted/un-diffed line. Example Templates \u00b6 In this example we want to insert getters in a Java class file. getters.egl [%for (a in c.eAllAttributes.excludingAll(c.eAttributes)) {%] + + /** + * @generated + */ + @Override + public [%=a.eType.instanceTypeName%] get[%=a.name.ftuc()%]() { + if ([%=a.name%] == null) { + return prototype.get[%=a.name.ftuc()%](); + } + else return [%=a.name%]; + } [%}%] -} //[%=c.name%]Impl +} //[%=c.name%]Impl (Patched) There are no un-diffed lines in the template. There is one deletion: -} //[%=c.name%]Impl , thus the processor would match the closing bracket of the Java class commented with the Java class name. The for loop would generate a getter for each attribute and insert it before the closing bracket location. The closing bracket and comment are removed A new closing bracket with the modified comment is added. In this other example, we want to modify the toString method of a Java class. toString.egl public String toString() { --- + return \"[%=c.name%]\"; } The public String toString() { line would be used to match the toString method. The --- indicates that all the lines in the method, until the closing bracket (which is the next matched line) should be removed. The new method implementation is added, which will return the class name. Using patch EGL templates \u00b6 To use EGL templates with diff lines they must be invoked from an EGX rule annotated with @patch . The example EGL templates above would be invoked like this: @patch rule EClass2Getters transform c : EClass { guard : c.eAnnotations.exists(a|a.source = \"instance\") template : \"getters.egl\" target : \"src/\" + c.eContainer().name + \"/impl/\" + c.name + \"Impl.java\" } @patch rule EClass2ToString transform c : EClass { template : \"toString.egl\" target : \"src/\" + c.eContainer().name + \"/impl/\" + c.name + \"Impl.java\" }","title":"EGL Patch Templates"},{"location":"doc/articles/egl-patch/#egl-patch-templates","text":"A patch file (also called a patch for short) is a text file that consists of a list of differences and is produced, usually, by running the related the diff program with the original and updated file as arguments. The differences follow the diff format . A patch processor can read a patch file and use the contents as a set of instructions. By following those instructions, a target file can be modified to match the changes in the patch file. Although patches are usually created using a diff tool, it is also possible to write them manually and then use the patch processor to modify a file. This is the approach we provide via EGL patch rules.","title":"EGL Patch Templates"},{"location":"doc/articles/egl-patch/#egl-diff-format","text":"In EGL we support a custom diff format. A line starting with + represents the addition of a line, i.e. this line will be added to the file. A line starting with - represents the deletion of a line, i.e, this line will be removed from the file. A line containing only ... indicates a block of lines to keep, i.e. all lines until the next diff/match will be kept. A line containing only --- indicates a block of lines to remove, i.e. all lines until the next diff/match will be removed. A line with no diff information is used as a match and will be kept.","title":"EGL Diff Format"},{"location":"doc/articles/egl-patch/#egl-diff-processor","text":"The EGl diff processor uses un-diffed lines to match sections of the file and then uses any diff entries till the next un-diffed lines to modify (add/remove/keep) the file. Deletions will also be used to match locations. All additions before a deletion/un-diff will be inserted before the deleted/un-diffed line. All additions after a deletion/un-diff will be inserted after the deleted/un-diffed line.","title":"EGL Diff Processor"},{"location":"doc/articles/egl-patch/#example-templates","text":"In this example we want to insert getters in a Java class file. getters.egl [%for (a in c.eAllAttributes.excludingAll(c.eAttributes)) {%] + + /** + * @generated + */ + @Override + public [%=a.eType.instanceTypeName%] get[%=a.name.ftuc()%]() { + if ([%=a.name%] == null) { + return prototype.get[%=a.name.ftuc()%](); + } + else return [%=a.name%]; + } [%}%] -} //[%=c.name%]Impl +} //[%=c.name%]Impl (Patched) There are no un-diffed lines in the template. There is one deletion: -} //[%=c.name%]Impl , thus the processor would match the closing bracket of the Java class commented with the Java class name. The for loop would generate a getter for each attribute and insert it before the closing bracket location. The closing bracket and comment are removed A new closing bracket with the modified comment is added. In this other example, we want to modify the toString method of a Java class. toString.egl public String toString() { --- + return \"[%=c.name%]\"; } The public String toString() { line would be used to match the toString method. The --- indicates that all the lines in the method, until the closing bracket (which is the next matched line) should be removed. The new method implementation is added, which will return the class name.","title":"Example Templates"},{"location":"doc/articles/egl-patch/#using-patch-egl-templates","text":"To use EGL templates with diff lines they must be invoked from an EGX rule annotated with @patch . The example EGL templates above would be invoked like this: @patch rule EClass2Getters transform c : EClass { guard : c.eAnnotations.exists(a|a.source = \"instance\") template : \"getters.egl\" target : \"src/\" + c.eContainer().name + \"/impl/\" + c.name + \"Impl.java\" } @patch rule EClass2ToString transform c : EClass { template : \"toString.egl\" target : \"src/\" + c.eContainer().name + \"/impl/\" + c.name + \"Impl.java\" }","title":"Using patch EGL templates"},{"location":"doc/articles/evl-emf-integration/","text":"EVL-EMF Validation Integration \u00b6 The Eclipse Modeling Framework (EMF) provides an extensible model validation service via the EValidator API. The API allows contributing additional validators for Ecore metamodels via the EValidator.Registry class. In this way, you can provide additional validation constraints for metamodels that will be invoked when models conforming to these metamodels are validated by EMF (e.g. through the Model \u2192 Right-click \u2192 Validate menu in EMF's built-in reflective). The EvlValidator Class \u00b6 Epsilon provides an implementation of EMF's EValidator interface ( EvlValidator ) that can execute EVL constraints against EMF models. Registering EVL Constraints \u00b6 There are two ways to register your EVL constraints for an Ecore metamodel ( EPackage ): programmatically or via an extension point. Programmatically \u00b6 For this you need to create a new instance of an EvlValidator and then add it to the EValidatorRegistry . Note that if there are existing validators registered for the metamodel, you should not remove/overwrite them; instead you should combine them in a CompositeEValidator . The following snippet outlines the general idea (you need to make your own provisions if you need to validate multiple EPackages with the same validator (e.g. use the EvlValidator#addAdditionalPackage method)). // Assuming you have generated the metamodel code EPackage ePackage = YourPackage . eINSTANCE ; // Pass a model name if your script uses it // Pass a valid bundle ID as it used for reporting (if not in a plugin use your project name or similar) EvlValidator evlValidator = new EvlValidator ( evlScriptURI , modelName , ePackage . nsUri (), bundleId ); EValidator existingValidator = EValidator . Registry . INSTANCE . getEValidator ( ePackage ); if ( existingValidator instanceof CompositeEValidator ) { (( CompositeEValidator ) existingValidator ). getDelegates (). add ( evlValidator ); } else { if ( existingValidator == null ) { existingValidator = EObjectValidator . INSTANCE ; } CompositeEValidator newValidator = new CompositeEValidator (); newValidator . getDelegates (). add ( existingValidator ); newValidator . getDelegates (). add ( evlValidator ); EValidator . Registry . INSTANCE . put ( ePackage , newValidator ); } Via the Extension Point \u00b6 Epsilon provides the org.eclipse.epsilon.evl.emf.validation extension point for registering EVL constraints against EPackages in Eclipse. The extension point will handle the EvlValidator instantiation and registration for you. <plugin> ... <extension point= \"org.eclipse.epsilon.evl.emf.validation\" > <constraintsBinding compose= \"true\" constraints= \"src/test.evl\" namespaceURI= \"http://your.package.uri\" validator= \"my.project.evl.EvlExtendedValidator\" > <additionalNamespaceURI namespaceURI= \"http://some.other.pacakge.uri\" > </additionalNamespaceURI> </constraintsBinding> </extension> </plugin> We recommend setting the compose attribute to true , else you will overwrite existing validators. You can also specify additional metamodels to be accessed by this validator using the additionalNamespaceURI entries. Note that you can also provide your own validator implementation. If omitted, the default EvlValidator will be used (should be sufficient for most cases). Runtime Adjustments \u00b6 Note The following adjustments are only possible if you control invocation of the validation, i.e. you are calling it programatically and not via the EMF/Eclipse right-click menu. There are three important runtime aspects to be taken into consideration when using the EVL-EMF integration. Error Dialogs \u00b6 Within Eclipse, Epsilon reports errors via Eclipse's JFace MessageDialog API. This is appropriate when checking constraints via the Model \u2192 Right-click \u2192 Validate menu in EMF's built-in tree-based editor, but can be cumbersome when the validation is integrated into other parts of your UI. To disable error reporting via message dialogs you can use use the EvlValidator#setShowErrorDialog function. You can either call this on you instance or override the isShowErrorDialog() if you extend the EvlValidator class. Logging \u00b6 Epsilon logs errors in the console. As with the dialogs, this can be enabled/disabled. For this, you can use use the EvlValidator#setLogErrors method. Similarly, the isLogErrors() can be overridden. Tip The dialogs are part of the logging, so disabling logging will disable the dialogs too. Validation progress and cancellation \u00b6 Within Eclipse it is important to allow uses to cancel a running validation. To do so, we need to pass an IProgressMonitor to the EvlValidator. For this, you need to provide your own Diagnostician . public class MyDiagnostician extends Diagnostician { public Diagnostic validate ( EObject eObject , IProgressMonitor monitor ) { BasicDiagnostic diagnostics = createDefaultDiagnostic ( eObject ); validate ( eObject , diagnostics , createDefaultContext ( monitor ), monitor ); return diagnostics ; } // Overload the Diagnostician implementation to inject the monitor into the context public Map < Object , Object > createDefaultContext ( IProgressMonitor monitor ) { final Map < Object , Object > defaultContext = super . createDefaultContext (); defaultContext . put ( EvlValidator . VALIDATION_MONITOR , monitor ); return defaultContext ; } } And then in your code (e.g. command handler): @Override public void run ( IProgressMonitor monitor ) throws CoreException { myDgnstc = new MyDiagnostician (); Diagnostic dgnstc = rnblDgnstc . validate ( model . getContents (). get ( 0 ), monitor ); ... The extended diagnostician can also be used to configure any EvlValidators provided via extension points, e.g. to disable logging or dialogs. In this case we assume that all EvlValidators are within CompositeEValidators (adjust if not using them). This implementation uses a brute force approach; ideally you should search for a specific EPackage instead. public class MyDiagnostician extends Diagnostician { public MyDiagnostician () { super (); for ( Object validator : eValidatorRegistry . values ()) { if ( validator instanceof CompositeEValidator ) { CompositeEValidator cmpsVal = ( CompositeEValidator ) validator ; findEvlValidators ( cmpsVal ); } } } public Diagnostic validate ( EObject eObject , IProgressMonitor monitor ) { BasicDiagnostic diagnostics = createDefaultDiagnostic ( eObject ); validate ( eObject , diagnostics , createDefaultContext ( monitor ), monitor ); return diagnostics ; } // Overload the Diagnostician implementation to inject the monitor into the context public Map < Object , Object > createDefaultContext ( IProgressMonitor monitor ) { final Map < Object , Object > defaultContext = super . createDefaultContext (); defaultContext . put ( EvlValidator . VALIDATION_MONITOR , monitor ); return defaultContext ; } /** * Find all {@link EVlValidator}s and configure them. * @param cmpsVal * @return */ private void findEvlValidators ( CompositeEValidator cmpsVal ) { for ( EValidator nstdVal : cmpsVal . getDelegates ()) { if ( nstdVal instanceof EVlValidator ) { EVlValidator evlVal = ( EVlValidator ) nstdVal ; evlVal . setShowErrorDialog ( false ); // Other settings or hook error listeners // evlVal.addValidationProblemListener(this); } } } }","title":"EVL-EMF Validation Integration"},{"location":"doc/articles/evl-emf-integration/#evl-emf-validation-integration","text":"The Eclipse Modeling Framework (EMF) provides an extensible model validation service via the EValidator API. The API allows contributing additional validators for Ecore metamodels via the EValidator.Registry class. In this way, you can provide additional validation constraints for metamodels that will be invoked when models conforming to these metamodels are validated by EMF (e.g. through the Model \u2192 Right-click \u2192 Validate menu in EMF's built-in reflective).","title":"EVL-EMF Validation Integration"},{"location":"doc/articles/evl-emf-integration/#the-evlvalidator-class","text":"Epsilon provides an implementation of EMF's EValidator interface ( EvlValidator ) that can execute EVL constraints against EMF models.","title":"The EvlValidator Class"},{"location":"doc/articles/evl-emf-integration/#registering-evl-constraints","text":"There are two ways to register your EVL constraints for an Ecore metamodel ( EPackage ): programmatically or via an extension point.","title":"Registering EVL Constraints"},{"location":"doc/articles/evl-emf-integration/#programmatically","text":"For this you need to create a new instance of an EvlValidator and then add it to the EValidatorRegistry . Note that if there are existing validators registered for the metamodel, you should not remove/overwrite them; instead you should combine them in a CompositeEValidator . The following snippet outlines the general idea (you need to make your own provisions if you need to validate multiple EPackages with the same validator (e.g. use the EvlValidator#addAdditionalPackage method)). // Assuming you have generated the metamodel code EPackage ePackage = YourPackage . eINSTANCE ; // Pass a model name if your script uses it // Pass a valid bundle ID as it used for reporting (if not in a plugin use your project name or similar) EvlValidator evlValidator = new EvlValidator ( evlScriptURI , modelName , ePackage . nsUri (), bundleId ); EValidator existingValidator = EValidator . Registry . INSTANCE . getEValidator ( ePackage ); if ( existingValidator instanceof CompositeEValidator ) { (( CompositeEValidator ) existingValidator ). getDelegates (). add ( evlValidator ); } else { if ( existingValidator == null ) { existingValidator = EObjectValidator . INSTANCE ; } CompositeEValidator newValidator = new CompositeEValidator (); newValidator . getDelegates (). add ( existingValidator ); newValidator . getDelegates (). add ( evlValidator ); EValidator . Registry . INSTANCE . put ( ePackage , newValidator ); }","title":"Programmatically"},{"location":"doc/articles/evl-emf-integration/#via-the-extension-point","text":"Epsilon provides the org.eclipse.epsilon.evl.emf.validation extension point for registering EVL constraints against EPackages in Eclipse. The extension point will handle the EvlValidator instantiation and registration for you. <plugin> ... <extension point= \"org.eclipse.epsilon.evl.emf.validation\" > <constraintsBinding compose= \"true\" constraints= \"src/test.evl\" namespaceURI= \"http://your.package.uri\" validator= \"my.project.evl.EvlExtendedValidator\" > <additionalNamespaceURI namespaceURI= \"http://some.other.pacakge.uri\" > </additionalNamespaceURI> </constraintsBinding> </extension> </plugin> We recommend setting the compose attribute to true , else you will overwrite existing validators. You can also specify additional metamodels to be accessed by this validator using the additionalNamespaceURI entries. Note that you can also provide your own validator implementation. If omitted, the default EvlValidator will be used (should be sufficient for most cases).","title":"Via the Extension Point"},{"location":"doc/articles/evl-emf-integration/#runtime-adjustments","text":"Note The following adjustments are only possible if you control invocation of the validation, i.e. you are calling it programatically and not via the EMF/Eclipse right-click menu. There are three important runtime aspects to be taken into consideration when using the EVL-EMF integration.","title":"Runtime Adjustments"},{"location":"doc/articles/evl-emf-integration/#error-dialogs","text":"Within Eclipse, Epsilon reports errors via Eclipse's JFace MessageDialog API. This is appropriate when checking constraints via the Model \u2192 Right-click \u2192 Validate menu in EMF's built-in tree-based editor, but can be cumbersome when the validation is integrated into other parts of your UI. To disable error reporting via message dialogs you can use use the EvlValidator#setShowErrorDialog function. You can either call this on you instance or override the isShowErrorDialog() if you extend the EvlValidator class.","title":"Error Dialogs"},{"location":"doc/articles/evl-emf-integration/#logging","text":"Epsilon logs errors in the console. As with the dialogs, this can be enabled/disabled. For this, you can use use the EvlValidator#setLogErrors method. Similarly, the isLogErrors() can be overridden. Tip The dialogs are part of the logging, so disabling logging will disable the dialogs too.","title":"Logging"},{"location":"doc/articles/evl-emf-integration/#validation-progress-and-cancellation","text":"Within Eclipse it is important to allow uses to cancel a running validation. To do so, we need to pass an IProgressMonitor to the EvlValidator. For this, you need to provide your own Diagnostician . public class MyDiagnostician extends Diagnostician { public Diagnostic validate ( EObject eObject , IProgressMonitor monitor ) { BasicDiagnostic diagnostics = createDefaultDiagnostic ( eObject ); validate ( eObject , diagnostics , createDefaultContext ( monitor ), monitor ); return diagnostics ; } // Overload the Diagnostician implementation to inject the monitor into the context public Map < Object , Object > createDefaultContext ( IProgressMonitor monitor ) { final Map < Object , Object > defaultContext = super . createDefaultContext (); defaultContext . put ( EvlValidator . VALIDATION_MONITOR , monitor ); return defaultContext ; } } And then in your code (e.g. command handler): @Override public void run ( IProgressMonitor monitor ) throws CoreException { myDgnstc = new MyDiagnostician (); Diagnostic dgnstc = rnblDgnstc . validate ( model . getContents (). get ( 0 ), monitor ); ... The extended diagnostician can also be used to configure any EvlValidators provided via extension points, e.g. to disable logging or dialogs. In this case we assume that all EvlValidators are within CompositeEValidators (adjust if not using them). This implementation uses a brute force approach; ideally you should search for a specific EPackage instead. public class MyDiagnostician extends Diagnostician { public MyDiagnostician () { super (); for ( Object validator : eValidatorRegistry . values ()) { if ( validator instanceof CompositeEValidator ) { CompositeEValidator cmpsVal = ( CompositeEValidator ) validator ; findEvlValidators ( cmpsVal ); } } } public Diagnostic validate ( EObject eObject , IProgressMonitor monitor ) { BasicDiagnostic diagnostics = createDefaultDiagnostic ( eObject ); validate ( eObject , diagnostics , createDefaultContext ( monitor ), monitor ); return diagnostics ; } // Overload the Diagnostician implementation to inject the monitor into the context public Map < Object , Object > createDefaultContext ( IProgressMonitor monitor ) { final Map < Object , Object > defaultContext = super . createDefaultContext (); defaultContext . put ( EvlValidator . VALIDATION_MONITOR , monitor ); return defaultContext ; } /** * Find all {@link EVlValidator}s and configure them. * @param cmpsVal * @return */ private void findEvlValidators ( CompositeEValidator cmpsVal ) { for ( EValidator nstdVal : cmpsVal . getDelegates ()) { if ( nstdVal instanceof EVlValidator ) { EVlValidator evlVal = ( EVlValidator ) nstdVal ; evlVal . setShowErrorDialog ( false ); // Other settings or hook error listeners // evlVal.addValidationProblemListener(this); } } } }","title":"Validation progress and cancellation"},{"location":"doc/articles/run-epsilon-from-java/","text":"Running Epsilon from Java \u00b6 While Epsilon's development tools are based on Eclipse, its runtime is not, and can be used from any (headless) Java application. For example, the back-end of the Epsilon Playground is a headless, server-less Java application that runs on Google's Cloud Platform. Did you know that ... Contrary to popular belief, EMF is not tightly coupled to the Eclipse IDE either, and can also be embedded in any Java application by importing a couple of dependencies from Maven Central . Dependencies \u00b6 Epsilon libraries are available on MavenCentral . Below is a fragment of a Maven pom.xml file, where we declare dependencies to the execution engine of Epsilon's core expression language and on Epsilon's driver for EMF-based models. As the EMF driver has a dependency on EMF, we don't need to declare a dependency to the EMF libraries on MavenCentral; Maven will fetch these automatically for us. <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.emc.emf </artifactId> <version> 2.2.0 </version> </dependency> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.2.0 </version> </dependency> ... </dependencies> Parsing and Executing Epsilon Programs \u00b6 Having declared a dependency to the EOL engine, parsing and executing an EOL program is as simple as that. EolModule module = new EolModule (); module . parse ( new File ( \"program.eol\" )); module . execute (); Tip By replacing EolModule with EtlModule , EvlModule etc. you can parse and execute ETL transformations , EVL validation constraints etc. EGL deviates from this pattern and if you wish to execute a single template you should use the EglTemplateFactoryModuleAdapter class. Loading Models \u00b6 Most of your Epsilon programs will need to run against models of some sort. To run an EOL program against a model ( model.xmi ) that conforms to a file-based Ecore metamodel ( metamodel.ecore ), you can extend the code above as follows. // Loads the EMF model EmfModel model = new EmfModel (); model . setMetamodelFile ( \"metamodel.ecore\" ); model . setModelFile ( \"model.xmi\" ); // Set the name by which the model will be // referred to in the program. Useful if // the program manages more than one models model . setName ( \"M\" ); // Read the contents of the model from disk // when the model is loaded. Set to false // to ignore existing model contents (e.g. // if the model is the target of a // model-to-text transformation) model . setReadOnLoad ( true ); // Save any changes made to the model // when it is disposed model . setStoredOnDisposal ( true ); model . load (); // Parses and executes the EOL program EolModule module = new EolModule (); module . parse ( new File ( \"program.eol\" )); // Makes the model accessible from the program module . getContext (). getModelRepository (). addModel ( model ); module . execute (); // Saves any changes to the model // and unloads it from memory // Use model.getContext(). // getModelRepository().dispose() // instead if multiple models are involved model . dispose (); Adding Variables \u00b6 You can add variables to your Epsilon program and provide their values from Java as shown below. EolModule module = new EolModule (); module . parse ( \"s.println();\" ); module . getContext (). getFrameStack (). put ( Variable . createReadOnlyVariable ( \"s\" , \"Hello World\" )); module . execute (); Analysing Epsilon Programs \u00b6 Epsilon programs do not have an Ecore-based metamodel, but you can query and analyse them through Epsilon's Java API as shown below. // Parse an ETL transformation EtlModule m = new EtlModule (); m . parse ( \"rule A2B transform a : In!A to b : Out!B { b.name = a.name; }\" ); // Get the first rule of the transformation TransformationRule a2b = m . getTransformationRules (). get ( 0 ); // Print its name System . out . println ( a2b . getName ()); // Get the body of the A2B rule StatementBlock body = ( StatementBlock ) a2b . getBody (). getBody (); // Print the number of statements it contains System . out . println ( body . getStatements (). size ()); As of version 2.3, Epsilon programs can also be analysed using visitors . As an example, see the EolUnparser class which recursively visits the contents of an EolModule and pretty-prints it. To implement your own analyser, you will need to implement the IEolVisitor interface for EOL, or the respective IE*lVisitor interfaces for other Epsilon-based languages. Using a combination of E*lUnparser and your custom visitor, you can easily rewrite Epsilon programs too. EolModule module = new EolModule (); module . parse ( \"'Hello world'.println();\" ); EolUnparser unparser = new EolUnparser (); // Prints \"Hello world\".println(); System . out . println ( unparser . unparse ( module )); More Examples \u00b6 In Epsilon's Git repository, there are two example projects that show how to run Epsilon from Java , and the ANT Epsilon tasks in a headless environment (i.e. from command line).","title":"Running Epsilon from Java"},{"location":"doc/articles/run-epsilon-from-java/#running-epsilon-from-java","text":"While Epsilon's development tools are based on Eclipse, its runtime is not, and can be used from any (headless) Java application. For example, the back-end of the Epsilon Playground is a headless, server-less Java application that runs on Google's Cloud Platform. Did you know that ... Contrary to popular belief, EMF is not tightly coupled to the Eclipse IDE either, and can also be embedded in any Java application by importing a couple of dependencies from Maven Central .","title":"Running Epsilon from Java"},{"location":"doc/articles/run-epsilon-from-java/#dependencies","text":"Epsilon libraries are available on MavenCentral . Below is a fragment of a Maven pom.xml file, where we declare dependencies to the execution engine of Epsilon's core expression language and on Epsilon's driver for EMF-based models. As the EMF driver has a dependency on EMF, we don't need to declare a dependency to the EMF libraries on MavenCentral; Maven will fetch these automatically for us. <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.emc.emf </artifactId> <version> 2.2.0 </version> </dependency> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.2.0 </version> </dependency> ... </dependencies>","title":"Dependencies"},{"location":"doc/articles/run-epsilon-from-java/#parsing-and-executing-epsilon-programs","text":"Having declared a dependency to the EOL engine, parsing and executing an EOL program is as simple as that. EolModule module = new EolModule (); module . parse ( new File ( \"program.eol\" )); module . execute (); Tip By replacing EolModule with EtlModule , EvlModule etc. you can parse and execute ETL transformations , EVL validation constraints etc. EGL deviates from this pattern and if you wish to execute a single template you should use the EglTemplateFactoryModuleAdapter class.","title":"Parsing and Executing Epsilon Programs"},{"location":"doc/articles/run-epsilon-from-java/#loading-models","text":"Most of your Epsilon programs will need to run against models of some sort. To run an EOL program against a model ( model.xmi ) that conforms to a file-based Ecore metamodel ( metamodel.ecore ), you can extend the code above as follows. // Loads the EMF model EmfModel model = new EmfModel (); model . setMetamodelFile ( \"metamodel.ecore\" ); model . setModelFile ( \"model.xmi\" ); // Set the name by which the model will be // referred to in the program. Useful if // the program manages more than one models model . setName ( \"M\" ); // Read the contents of the model from disk // when the model is loaded. Set to false // to ignore existing model contents (e.g. // if the model is the target of a // model-to-text transformation) model . setReadOnLoad ( true ); // Save any changes made to the model // when it is disposed model . setStoredOnDisposal ( true ); model . load (); // Parses and executes the EOL program EolModule module = new EolModule (); module . parse ( new File ( \"program.eol\" )); // Makes the model accessible from the program module . getContext (). getModelRepository (). addModel ( model ); module . execute (); // Saves any changes to the model // and unloads it from memory // Use model.getContext(). // getModelRepository().dispose() // instead if multiple models are involved model . dispose ();","title":"Loading Models"},{"location":"doc/articles/run-epsilon-from-java/#adding-variables","text":"You can add variables to your Epsilon program and provide their values from Java as shown below. EolModule module = new EolModule (); module . parse ( \"s.println();\" ); module . getContext (). getFrameStack (). put ( Variable . createReadOnlyVariable ( \"s\" , \"Hello World\" )); module . execute ();","title":"Adding Variables"},{"location":"doc/articles/run-epsilon-from-java/#analysing-epsilon-programs","text":"Epsilon programs do not have an Ecore-based metamodel, but you can query and analyse them through Epsilon's Java API as shown below. // Parse an ETL transformation EtlModule m = new EtlModule (); m . parse ( \"rule A2B transform a : In!A to b : Out!B { b.name = a.name; }\" ); // Get the first rule of the transformation TransformationRule a2b = m . getTransformationRules (). get ( 0 ); // Print its name System . out . println ( a2b . getName ()); // Get the body of the A2B rule StatementBlock body = ( StatementBlock ) a2b . getBody (). getBody (); // Print the number of statements it contains System . out . println ( body . getStatements (). size ()); As of version 2.3, Epsilon programs can also be analysed using visitors . As an example, see the EolUnparser class which recursively visits the contents of an EolModule and pretty-prints it. To implement your own analyser, you will need to implement the IEolVisitor interface for EOL, or the respective IE*lVisitor interfaces for other Epsilon-based languages. Using a combination of E*lUnparser and your custom visitor, you can easily rewrite Epsilon programs too. EolModule module = new EolModule (); module . parse ( \"'Hello world'.println();\" ); EolUnparser unparser = new EolUnparser (); // Prints \"Hello world\".println(); System . out . println ( unparser . unparse ( module ));","title":"Analysing Epsilon Programs"},{"location":"doc/articles/run-epsilon-from-java/#more-examples","text":"In Epsilon's Git repository, there are two example projects that show how to run Epsilon from Java , and the ANT Epsilon tasks in a headless environment (i.e. from command line).","title":"More Examples"},{"location":"doc/articles/xml-to-emf/","text":"XML to EMF Transformation with ETL \u00b6 This example shows how to transform an XML document into an EMF model using the Epsilon Transformation Language and Epsilon's XML driver . We start with our source XML file ( tree.xml ), which is shown below: <?xml version=\"1.0\"?> <tree name= \"t1\" > <tree name= \"t2\" /> <tree name= \"t3\" > <tree name= \"t4\" /> </tree> </tree> The Ecore metamodel (expressed in Emfatic ) to which our target EMF model will conform to is shown below: package tree; class Tree { attr String label; ref Tree#children parent; val Tree[*]#parent children; } Finally, our ETL transformation ( xml2emf.etl ) is in the listing below: rule XmlTree2EmfTree transform s : Xml!t_tree to t : Emf!Tree { t.label = s.a_name; t.children ::= s.c_tree; } The transformation consists of one rule which transforms every tree element in the XML document ( Xml!t_tree ) into an instance of the Tree class of our Ecore metamodel above. The rule sets the label of the latter to the name of the former, and the children of the latter, to the equivalent model elements produced by the tree child elements of the former. To run the transformation: Right-click on tree.emf or tree.ecore and select Register EPackages Right-click on xml2emf.launch and select Run As \u2192 xml2emf Once the transformation has executed you can open tree.model to inspect the EMF model it has produced with the reflective tree-based editor. The complete source code of the example is available here .","title":"XML to EMF Transformation with ETL"},{"location":"doc/articles/xml-to-emf/#xml-to-emf-transformation-with-etl","text":"This example shows how to transform an XML document into an EMF model using the Epsilon Transformation Language and Epsilon's XML driver . We start with our source XML file ( tree.xml ), which is shown below: <?xml version=\"1.0\"?> <tree name= \"t1\" > <tree name= \"t2\" /> <tree name= \"t3\" > <tree name= \"t4\" /> </tree> </tree> The Ecore metamodel (expressed in Emfatic ) to which our target EMF model will conform to is shown below: package tree; class Tree { attr String label; ref Tree#children parent; val Tree[*]#parent children; } Finally, our ETL transformation ( xml2emf.etl ) is in the listing below: rule XmlTree2EmfTree transform s : Xml!t_tree to t : Emf!Tree { t.label = s.a_name; t.children ::= s.c_tree; } The transformation consists of one rule which transforms every tree element in the XML document ( Xml!t_tree ) into an instance of the Tree class of our Ecore metamodel above. The rule sets the label of the latter to the name of the former, and the children of the latter, to the equivalent model elements produced by the tree child elements of the former. To run the transformation: Right-click on tree.emf or tree.ecore and select Register EPackages Right-click on xml2emf.launch and select Run As \u2192 xml2emf Once the transformation has executed you can open tree.model to inspect the EMF model it has produced with the reflective tree-based editor. The complete source code of the example is available here .","title":"XML to EMF Transformation with ETL"},{"location":"doc/articles/adding-new-plugins/","text":"Adding new plugins \u00b6 This article outlines the process of adding new plugins to the main Epsilon repository. Move them to the Epsilon repository. Plugins, features, tests and examples should be placed under the respective directories in the repository. Add pom.xml files similar to the ones we already have for each plugin, but changing the <artifactId> to the Eclipse plugin name. If you want its tests to be run from Hudson as plug-in tests, add them to the EpsilonHudsonPluggedInTestSuite in org.eclipse.epsilon.test . Define a feature for the new plugins (feature project in features/, as usual, but with its own POM) and add it to the site.xml in the org.eclipse.epsilon.updatesite.interim project. Change the plugins/pom.xml , tests/pom.xml and features/pom.xml so they mention the new projects in their <modules> section. If you want a specific standalone JAR for this, you\\'ll need to update the jarmodel.xml , rerun the jarmodel2mvn.launch launch config, and then mention the new Maven assembly descriptor in the org.eclipse.epsilon.standalone/pom.xml file. There's a readme.txt file in that folder that explains the process. Update org.eclipse.epsilon/standalone/org.eclipse.epsilon.standalone/pom.xml with the details of the new plugins.","title":"Adding new plugins"},{"location":"doc/articles/adding-new-plugins/#adding-new-plugins","text":"This article outlines the process of adding new plugins to the main Epsilon repository. Move them to the Epsilon repository. Plugins, features, tests and examples should be placed under the respective directories in the repository. Add pom.xml files similar to the ones we already have for each plugin, but changing the <artifactId> to the Eclipse plugin name. If you want its tests to be run from Hudson as plug-in tests, add them to the EpsilonHudsonPluggedInTestSuite in org.eclipse.epsilon.test . Define a feature for the new plugins (feature project in features/, as usual, but with its own POM) and add it to the site.xml in the org.eclipse.epsilon.updatesite.interim project. Change the plugins/pom.xml , tests/pom.xml and features/pom.xml so they mention the new projects in their <modules> section. If you want a specific standalone JAR for this, you\\'ll need to update the jarmodel.xml , rerun the jarmodel2mvn.launch launch config, and then mention the new Maven assembly descriptor in the org.eclipse.epsilon.standalone/pom.xml file. There's a readme.txt file in that folder that explains the process. Update org.eclipse.epsilon/standalone/org.eclipse.epsilon.standalone/pom.xml with the details of the new plugins.","title":"Adding new plugins"},{"location":"doc/articles/bibtex/","text":"Scripting BibTeX files using Epsilon \u00b6 In this article we demonstrate how you can query list of references stored in BibTeX files in Epsilon programs using the BibTeX EMC driver. All the examples in this article demonstrate using EOL to script BibTeX files. However, it's worth stressing that BibTeX files are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or to text), compare and merge your BibTeX files. Querying a BibTeX file \u00b6 We use the following eclipse.bib as a base for demonstrating the EOL syntax for querying BibTeX files. @book { steinberg09emf , author = {Steinberg, D. and Budinsky, F. and Paternostro, M. and Merks, E.} , title = {{EMF}: {E}clipse {M}odeling {F}ramework} , year = {2008} , publisher = {Addison-Wesley Professional} , address = {Boston, Massachusetts} } @inproceedings { gronback06gmf , author = {Gronback, R.} , title = {Introduction to the {Eclipse Graphical Modeling Framework}} , booktitle = {Proc. EclipseCon} , year = {2006} , address = {Santa Clara, California} } @article { brooks86nosilverbullet , author = {Brooks Jr., F.P.} , title = {No Silver Bullet - Essence and Accidents of Software Engineering} , journal = {IEEE Computer} , volume = {20} , number = {4} , year = {1987} , pages = {10-19} , } How can I access all publications? \u00b6 Presuming that we have specified the name MyPubs when loading the BibTeX file as a model, the allContents method can be used to access all of the entries in the BibTeX file: // Get all publications var publications = MyPubs.allContents(); How can I access a publication? \u00b6 Publications (entries) in a BibTeX file can be accessed by type: // Get all @book elements var books = Book.all; // Get a random book var b = Book.all.random(); Note that the BibTeX driver recognises only those types defined in your BibTeX file. For example, attempting to call Phdthesis.all will result in an error for the BibTeX file shown above, as that BibTeX file contains no @phdthesis entries. How can I access and change the properties of a particular publication? \u00b6 Properties are accessed via the dot notation: // Get a random book var b = Book.all.random(); // Get the title of the random book var t = b.title; // Get the Amazon rating of the random book var a = b.amazonRating; Note that the empty string is returned when accessing a property that does not exist (such as the amazonRating property in the example above). Properties can be changed using an assignment statement: // Get a random book var b = Book.all.random(); // Get the title of the random book b.title = \"On the Criteria To Be Used in Decomposing Systems into Modules\" Note that the current version of the BibTeX driver does not support saving changes to disk. Any changes made to properties are volatile (and persist only during the duration of the Epsilon program's execution). Adding a BibTeX file to your launch configuration \u00b6 To add a BibTeX file to your Epsilon launch configuration, you need to select \"Show all model types\" and then choose \"BibTeX model\" from the list of available model types. Then you can configure the details of your BibTeX (name, file etc.) in the screen that pops up. Unsupported features \u00b6 The current version of the BibTeX driver for Epsilon is not yet a complete implementation. In particular, the following features are not yet supported: Storing changes to BibTeX models to disk. Deleting entries from a BibTeX file. Please file an enhancement request if you require -- or can provide a patch for -- these features.","title":"Scripting BibTeX files using Epsilon"},{"location":"doc/articles/bibtex/#scripting-bibtex-files-using-epsilon","text":"In this article we demonstrate how you can query list of references stored in BibTeX files in Epsilon programs using the BibTeX EMC driver. All the examples in this article demonstrate using EOL to script BibTeX files. However, it's worth stressing that BibTeX files are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or to text), compare and merge your BibTeX files.","title":"Scripting BibTeX files using Epsilon"},{"location":"doc/articles/bibtex/#querying-a-bibtex-file","text":"We use the following eclipse.bib as a base for demonstrating the EOL syntax for querying BibTeX files. @book { steinberg09emf , author = {Steinberg, D. and Budinsky, F. and Paternostro, M. and Merks, E.} , title = {{EMF}: {E}clipse {M}odeling {F}ramework} , year = {2008} , publisher = {Addison-Wesley Professional} , address = {Boston, Massachusetts} } @inproceedings { gronback06gmf , author = {Gronback, R.} , title = {Introduction to the {Eclipse Graphical Modeling Framework}} , booktitle = {Proc. EclipseCon} , year = {2006} , address = {Santa Clara, California} } @article { brooks86nosilverbullet , author = {Brooks Jr., F.P.} , title = {No Silver Bullet - Essence and Accidents of Software Engineering} , journal = {IEEE Computer} , volume = {20} , number = {4} , year = {1987} , pages = {10-19} , }","title":"Querying a BibTeX file"},{"location":"doc/articles/bibtex/#how-can-i-access-all-publications","text":"Presuming that we have specified the name MyPubs when loading the BibTeX file as a model, the allContents method can be used to access all of the entries in the BibTeX file: // Get all publications var publications = MyPubs.allContents();","title":"How can I access all publications?"},{"location":"doc/articles/bibtex/#how-can-i-access-a-publication","text":"Publications (entries) in a BibTeX file can be accessed by type: // Get all @book elements var books = Book.all; // Get a random book var b = Book.all.random(); Note that the BibTeX driver recognises only those types defined in your BibTeX file. For example, attempting to call Phdthesis.all will result in an error for the BibTeX file shown above, as that BibTeX file contains no @phdthesis entries.","title":"How can I access a publication?"},{"location":"doc/articles/bibtex/#how-can-i-access-and-change-the-properties-of-a-particular-publication","text":"Properties are accessed via the dot notation: // Get a random book var b = Book.all.random(); // Get the title of the random book var t = b.title; // Get the Amazon rating of the random book var a = b.amazonRating; Note that the empty string is returned when accessing a property that does not exist (such as the amazonRating property in the example above). Properties can be changed using an assignment statement: // Get a random book var b = Book.all.random(); // Get the title of the random book b.title = \"On the Criteria To Be Used in Decomposing Systems into Modules\" Note that the current version of the BibTeX driver does not support saving changes to disk. Any changes made to properties are volatile (and persist only during the duration of the Epsilon program's execution).","title":"How can I access and change the properties of a particular publication?"},{"location":"doc/articles/bibtex/#adding-a-bibtex-file-to-your-launch-configuration","text":"To add a BibTeX file to your Epsilon launch configuration, you need to select \"Show all model types\" and then choose \"BibTeX model\" from the list of available model types. Then you can configure the details of your BibTeX (name, file etc.) in the screen that pops up.","title":"Adding a BibTeX file to your launch configuration"},{"location":"doc/articles/bibtex/#unsupported-features","text":"The current version of the BibTeX driver for Epsilon is not yet a complete implementation. In particular, the following features are not yet supported: Storing changes to BibTeX models to disk. Deleting entries from a BibTeX file. Please file an enhancement request if you require -- or can provide a patch for -- these features.","title":"Unsupported features"},{"location":"doc/articles/call-for-user-stories/","text":"Call for User Stories \u00b6 Over the last few years we've been delighted to see the Epsilon community grow and expand. We'd like to take the opportunity to thank you all for your feedback and contributions, and if it's not too much of a hassle, we'd like to ask for your help one more time. Epsilon is developed and maintained by members of staff at the University of York (UK) and University of Cadiz (Spain). In the context of the UK Research Excellence Framework 2014, we (the York people ) need to prepare a portfolio that demonstrates the impact of our research (for some definition of impact ). In this direction it'd be really appreciated if you spare a few minutes to write a few sentences on what you're using Epsilon for in your company/research group and why it's cool, and share them with us at epsilon.devs@gmail.com . All responses, no matter how short or seemingly trivial , would be very helpful for us, and will be rewarded accordingly next time we meet. Of course, no user story will be made publicly available without your explicit consent. In case you'd like an example, we recently received the following statement from Jendrik Johannes, a founder of DevBoost . Our thanks to Jendrik for his statement and for kindly allowing us to use it here. \"We used Eugenia in a project where we developed a graphical editor for a client as an extension for their existing tool for modeling wind farms. The client already used a model as the basis for the tool and thus it was a matter of minutes to generate a prototype of the editor with Eugenia. This gave us the possibility to discuss the clients requirements directly on a working prototype which later on also served as the basis for the actual implementation. Using Eugenia, we implemented the prototype within a week - a task that usually takes a month.\" [Jendrik Johannes, founder of DevBoost ]","title":"Call for User Stories"},{"location":"doc/articles/call-for-user-stories/#call-for-user-stories","text":"Over the last few years we've been delighted to see the Epsilon community grow and expand. We'd like to take the opportunity to thank you all for your feedback and contributions, and if it's not too much of a hassle, we'd like to ask for your help one more time. Epsilon is developed and maintained by members of staff at the University of York (UK) and University of Cadiz (Spain). In the context of the UK Research Excellence Framework 2014, we (the York people ) need to prepare a portfolio that demonstrates the impact of our research (for some definition of impact ). In this direction it'd be really appreciated if you spare a few minutes to write a few sentences on what you're using Epsilon for in your company/research group and why it's cool, and share them with us at epsilon.devs@gmail.com . All responses, no matter how short or seemingly trivial , would be very helpful for us, and will be rewarded accordingly next time we meet. Of course, no user story will be made publicly available without your explicit consent. In case you'd like an example, we recently received the following statement from Jendrik Johannes, a founder of DevBoost . Our thanks to Jendrik for his statement and for kindly allowing us to use it here. \"We used Eugenia in a project where we developed a graphical editor for a client as an extension for their existing tool for modeling wind farms. The client already used a model as the basis for the tool and thus it was a matter of minutes to generate a prototype of the editor with Eugenia. This gave us the possibility to discuss the clients requirements directly on a working prototype which later on also served as the basis for the actual implementation. Using Eugenia, we implemented the prototype within a week - a task that usually takes a month.\" [Jendrik Johannes, founder of DevBoost ]","title":"Call for User Stories"},{"location":"doc/articles/call-java-from-epsilon/","text":"Call Java from Epsilon \u00b6 Model management languages such as those provided by Epsilon are by design not general purpose languages. Therefore, there are features that such languages do not support inherently (mainly because such features are typically not needed in the context of model management). However, there are cases where a feature that is not built-in may be necessary for a specific task. To address such issues and enable developers to implement non-standard functionality, Epsilon supports the Tool concept. A tool is a normal Java class that (optionally) conforms to a specific interface ( org.eclipse.epsilon.eol.tools.ITool ) and which can be instantiated and accessed from the context of an EOL (or any other EOL-based language such as EML, ETL, EVL etc) program. After instantiation, EOL can be used to invoke methods and access properties of the object. In this article we show how to create and declare a new tool ( org.eclipse.epsilon.examples.tools.SampleTool ), and then use it from an EOL program. Create the tool \u00b6 The first step is to create a new plugin project named org.eclipse.epsilon.examples.tools . Then create a class named SampleTool with the following content. package org.eclipse.epsilon.examples.tools ; public class SampleTool { protected String name ; public void setName ( String name ) { this . name = name ; } public String getName () { return name ; } public String sayHello () { return \"Hello \" + name ; } } Declare the tool \u00b6 Add org.eclipse.epsilon.common.dt to the dependencies of your plugin Create an extension to the org.eclipse.epsilon.common.dt.tool extension point Set the class to org.eclipse.epsilon.examples.tools.SampleTool Set the name to SampleTool Add org.eclipse.epsilon.examples.tools to the exported packages list in the Runtime tab Invoke the tool \u00b6 To invoke the tool you have two options: You can either run a new Eclipse instance, or export the plugin and place it in the dropins folder of your installation. Then you can invoke the tool using the following EOL program. var sampleTool = new Native(\"org.eclipse.epsilon.examples.tools.SampleTool\"); sampleTool.name = \"George\"; sampleTool.sayHello().println(); // Prints Hello George Standalone setup \u00b6 To use tools contributed via extensions in a standalone Java setup within Eclipse you'll need to add the following line of code. context . getNativeTypeDelegates (). add ( new ExtensionPointToolNativeTypeDelegate ()); You can get the source code of this example here .","title":"Call Java from Epsilon"},{"location":"doc/articles/call-java-from-epsilon/#call-java-from-epsilon","text":"Model management languages such as those provided by Epsilon are by design not general purpose languages. Therefore, there are features that such languages do not support inherently (mainly because such features are typically not needed in the context of model management). However, there are cases where a feature that is not built-in may be necessary for a specific task. To address such issues and enable developers to implement non-standard functionality, Epsilon supports the Tool concept. A tool is a normal Java class that (optionally) conforms to a specific interface ( org.eclipse.epsilon.eol.tools.ITool ) and which can be instantiated and accessed from the context of an EOL (or any other EOL-based language such as EML, ETL, EVL etc) program. After instantiation, EOL can be used to invoke methods and access properties of the object. In this article we show how to create and declare a new tool ( org.eclipse.epsilon.examples.tools.SampleTool ), and then use it from an EOL program.","title":"Call Java from Epsilon"},{"location":"doc/articles/call-java-from-epsilon/#create-the-tool","text":"The first step is to create a new plugin project named org.eclipse.epsilon.examples.tools . Then create a class named SampleTool with the following content. package org.eclipse.epsilon.examples.tools ; public class SampleTool { protected String name ; public void setName ( String name ) { this . name = name ; } public String getName () { return name ; } public String sayHello () { return \"Hello \" + name ; } }","title":"Create the tool"},{"location":"doc/articles/call-java-from-epsilon/#declare-the-tool","text":"Add org.eclipse.epsilon.common.dt to the dependencies of your plugin Create an extension to the org.eclipse.epsilon.common.dt.tool extension point Set the class to org.eclipse.epsilon.examples.tools.SampleTool Set the name to SampleTool Add org.eclipse.epsilon.examples.tools to the exported packages list in the Runtime tab","title":"Declare the tool"},{"location":"doc/articles/call-java-from-epsilon/#invoke-the-tool","text":"To invoke the tool you have two options: You can either run a new Eclipse instance, or export the plugin and place it in the dropins folder of your installation. Then you can invoke the tool using the following EOL program. var sampleTool = new Native(\"org.eclipse.epsilon.examples.tools.SampleTool\"); sampleTool.name = \"George\"; sampleTool.sayHello().println(); // Prints Hello George","title":"Invoke the tool"},{"location":"doc/articles/call-java-from-epsilon/#standalone-setup","text":"To use tools contributed via extensions in a standalone Java setup within Eclipse you'll need to add the following line of code. context . getNativeTypeDelegates (). add ( new ExtensionPointToolNativeTypeDelegate ()); You can get the source code of this example here .","title":"Standalone setup"},{"location":"doc/articles/code-generation-tutorial-egl/","text":"Code Generation Tutorial with EGL \u00b6 EGL is a template-based language that can be used to generate code (or any other kind of text) from different types of models supported by Epsilon (e.g. EMF, UML, XML). This example demonstrates using EGL to generate HTML code from the XML document below. <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" public= \"true\" > <id> EMFBook </id> <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" public= \"true\" > <id> EMPBook </id> <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" public= \"false\" > <id> Eclipse3FAQs </id> <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> More specifically, we will generate one HTML file for each <book> element that has a public attribute set to true . Below is an EGL template ( book2page.egl ) that can generate an HTML file from a single <book> element. For more details on using EGL's expression language to navigate and query XML documents, please refer to this article . <h1>Book [%=index%]: [%=book.a_title%]</h1> <h2>Authors</h2> <ul> [%for (author in book.c_author) { %] <li>[%=author.text%] [%}%] </ul> The template above can generate one HTML file from one <book> element. To run this template against '''all''' <book> elements anywhere in the XML document, and generate appropriately-named HTML files, we need to use an EGX co-ordination program such as the one illustrated below ( main.egx ). The Book2Page rule of the EGX program will transform every <book> element ( t_book ) that satisfies the declared guard (has a public attribute set to true ), into a target file, using the specified template ( book2page.egl ). In addition, the EGX program specifies a Library2Page rule, that generates an HTML (index) file for each <library> element in the document. rule Book2Page transform book : t_book { // We only want to generate pages // for books that have their public // attribute set to true guard : book.b_public parameters { // These parameters will be made available // to the invoked template as variables var params : new Map; params.put(\"index\", t_book.all.indexOf(book) + 1); return params; } // The EGL template to be invoked template : \"book2page.egl\" // Output file target : \"gen/\" + book.e_id.text + \".html\" } rule Library2Page transform library : t_library { template : \"library2page.egl\" target : \"gen/index.html\" } For completeness, the source code of the library2page.egl template appears below. <h1>Books</h1> <ul> [%for (book in library.c_book.select(b|b.b_public)) { %] <li><a href=\"[%=book.e_id.text%].html\">[%=book.a_title%]</a> [%}%] </ul> Running the Code Generator from Eclipse \u00b6 Screenshots of the Eclipse run configuration appear below. The complete source for this example is available here . Running the Code Generator from Java \u00b6 The following snippet demonstrates using Epsilon's Java API to parse the XML document and execute the EGX program. The complete source for this example is available here (please read lib/readme.txt for instructions on how to obtain the missing Epsilon JAR). import java.io.File ; import org.eclipse.epsilon.egl.EglFileGeneratingTemplateFactory ; import org.eclipse.epsilon.egl.EgxModule ; import org.eclipse.epsilon.emc.plainxml.PlainXmlModel ; public class App { public static void main ( String [] args ) throws Exception { // Parse main.egx EgxModule module = new EgxModule ( new EglFileGeneratingTemplateFactory ()); module . parse ( new File ( \"main.egx\" ). getAbsoluteFile ()); if ( ! module . getParseProblems (). isEmpty ()) { System . out . println ( \"Syntax errors found. Exiting.\" ); return ; } // Load the XML document PlainXmlModel model = new PlainXmlModel (); model . setFile ( new File ( \"library.xml\" )); model . setName ( \"L\" ); model . load (); // Make the document visible to the EGX program module . getContext (). getModelRepository (). addModel ( model ); // ... and execute module . execute (); } }","title":"Code Generation Tutorial with EGL"},{"location":"doc/articles/code-generation-tutorial-egl/#code-generation-tutorial-with-egl","text":"EGL is a template-based language that can be used to generate code (or any other kind of text) from different types of models supported by Epsilon (e.g. EMF, UML, XML). This example demonstrates using EGL to generate HTML code from the XML document below. <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" public= \"true\" > <id> EMFBook </id> <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" public= \"true\" > <id> EMPBook </id> <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" public= \"false\" > <id> Eclipse3FAQs </id> <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> More specifically, we will generate one HTML file for each <book> element that has a public attribute set to true . Below is an EGL template ( book2page.egl ) that can generate an HTML file from a single <book> element. For more details on using EGL's expression language to navigate and query XML documents, please refer to this article . <h1>Book [%=index%]: [%=book.a_title%]</h1> <h2>Authors</h2> <ul> [%for (author in book.c_author) { %] <li>[%=author.text%] [%}%] </ul> The template above can generate one HTML file from one <book> element. To run this template against '''all''' <book> elements anywhere in the XML document, and generate appropriately-named HTML files, we need to use an EGX co-ordination program such as the one illustrated below ( main.egx ). The Book2Page rule of the EGX program will transform every <book> element ( t_book ) that satisfies the declared guard (has a public attribute set to true ), into a target file, using the specified template ( book2page.egl ). In addition, the EGX program specifies a Library2Page rule, that generates an HTML (index) file for each <library> element in the document. rule Book2Page transform book : t_book { // We only want to generate pages // for books that have their public // attribute set to true guard : book.b_public parameters { // These parameters will be made available // to the invoked template as variables var params : new Map; params.put(\"index\", t_book.all.indexOf(book) + 1); return params; } // The EGL template to be invoked template : \"book2page.egl\" // Output file target : \"gen/\" + book.e_id.text + \".html\" } rule Library2Page transform library : t_library { template : \"library2page.egl\" target : \"gen/index.html\" } For completeness, the source code of the library2page.egl template appears below. <h1>Books</h1> <ul> [%for (book in library.c_book.select(b|b.b_public)) { %] <li><a href=\"[%=book.e_id.text%].html\">[%=book.a_title%]</a> [%}%] </ul>","title":"Code Generation Tutorial with EGL"},{"location":"doc/articles/code-generation-tutorial-egl/#running-the-code-generator-from-eclipse","text":"Screenshots of the Eclipse run configuration appear below. The complete source for this example is available here .","title":"Running the Code Generator from Eclipse"},{"location":"doc/articles/code-generation-tutorial-egl/#running-the-code-generator-from-java","text":"The following snippet demonstrates using Epsilon's Java API to parse the XML document and execute the EGX program. The complete source for this example is available here (please read lib/readme.txt for instructions on how to obtain the missing Epsilon JAR). import java.io.File ; import org.eclipse.epsilon.egl.EglFileGeneratingTemplateFactory ; import org.eclipse.epsilon.egl.EgxModule ; import org.eclipse.epsilon.emc.plainxml.PlainXmlModel ; public class App { public static void main ( String [] args ) throws Exception { // Parse main.egx EgxModule module = new EgxModule ( new EglFileGeneratingTemplateFactory ()); module . parse ( new File ( \"main.egx\" ). getAbsoluteFile ()); if ( ! module . getParseProblems (). isEmpty ()) { System . out . println ( \"Syntax errors found. Exiting.\" ); return ; } // Load the XML document PlainXmlModel model = new PlainXmlModel (); model . setFile ( new File ( \"library.xml\" )); model . setName ( \"L\" ); model . load (); // Make the document visible to the EGX program module . getContext (). getModelRepository (). addModel ( model ); // ... and execute module . execute (); } }","title":"Running the Code Generator from Java"},{"location":"doc/articles/csv-emc/","text":"Scripting CSV documents using Epsilon \u00b6 In this article we demonstrate how you can create, query and modify CSV documents in Epsilon programs using the CSV driver. The examples in this article demonstrate using EOL and ETL to script CSV documents. However, it's worth stressing that CSV documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or totext), compare and merge your CSV documents. Note: This article is consistent with Epsilon versions 1.5+. The CSV Model Configuration Dialog \u00b6 To add a CSV document to your Epsilon launch configuration you first need to click on \"Show all model types\" in order to display the CSV Model type. From there you can select \"CSV Model\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. You need to provide a name for the model and select the CSV file using the \"Browse Workspace...\" button. The CSV section allows you to define specific behaviour for the CSV model. The Field Separator allows you to select a different separator than comma.... yes, they are called comma-separated files, but sometimes a colon, or a semi-colon, or other char is used as a field separator. Now you can tell the model loader which one too use. By default it is a comma. The Quote Character allows you to select the character used for quotes. Quotes are used when a column value contains the field separator to avoid erroneous input. The Known Headers tells the loader that the first row of your file contains headers. Headers can late be used to access fields of a row. The Varargs Header tells the loader that the last column/field of the file can span multiple columns. This is not the \"standard\" (did you know that RFC 4180 describes CSV file standards?), but in some cases it can be useful. Finally, the Id Field allows you to optionally select one of the fields as an id for your model elements. When using Known Headers , this should be the name of one of the fields. If not, it should be the index (integer) of the field. Next we show how the different options can be used when working with CSV models. Querying a CSV document \u00b6 All elements in the CSV model are of type Row , that is, all model access has to be done using that type. Header-less CSV Model \u00b6 Consider the following NoHeaders.csv input. 604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,2558058636921002,Horror 272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Drama 844-07-0023,Matteo,Macer,mmacer2@sogou.com,Male,Tax Accountant,3542981651057648,Horror 429-41-4964,Kattie,Fysh,kfysh3@angelfire.com,Female,Senior Financial Analyst,,Comedy 378-90-9530,Link,Proffitt,lproffitt4@cloudflare.com,Male,Paralegal,,Drama 811-26-0387,Rafferty,Sobieski,rsobieski5@usatoday.com,Male,Physical Therapy Assistant,5602242765074843,Horror 386-53-1139,Ernestine,Kringe,ekringe6@gov.uk,Female,Software Consultant,3531096662484096,Drama 850-05-5333,Flossy,Mobberley,fmobberley7@msn.com,Female,Chief Design Engineer,3558038696922012,Romance 605-52-9809,Tull,Ingerith,tingerith8@surveymonkey.com,Male,VP Quality Control,,Drama 580-79-7291,Derry,Laurisch,dlaurisch9@taobao.com,Male,Software Test Engineer I,,War 676-89-8860,Cosetta,Vlasov,cvlasova@livejournal.com,Female,Nurse Practicioner,,Thriller 748-10-2370,Lissa,Stanger,lstangerb@tmall.com,Female,Analyst Programmer,,Thriller 164-18-3409,Giffie,Boards,gboardsc@gmpg.org,Male,Graphic Designer,3575314620284632,Comedy 212-06-7778,Rabbi,Varran,rvarrand@jugem.jp,Male,GIS Technical Architect,3551249058791476,Horror 628-02-3617,Olvan,Alabone,oalabonee@archive.org,Male,Help Desk Technician,,Thriller 318-48-3006,Constantino,Eyckelbeck,ceyckelbeckf@histats.com,Male,Recruiter,564182300132483644,War 122-74-6759,Nickolas,Collard,ncollardg@dot.gov,Male,Web Designer IV,,Drama 309-57-3090,Chere,Hurry,churryh@huffingtonpost.com,Female,Tax Accountant,,Mystery 833-32-9040,Mattie,Hamon,mhamoni@auda.org.au,Male,Structural Engineer,,Drama 101-82-2564,Hew,Goble,hgoblej@ocn.ne.jp,Male,VP Accounting,,Comedy Since there are no headers, we need to access the information via the general field attribute and index (0 based): // Get all Rows elements var people = Row.all; // Get a random person var p = people.random(); // Check the gender of p (field 4) // Prints 'Male' or 'Female' p.field.at(4).println(); // Get the emails (field 3) of people that like Horror movies (field 7) so we can let them know a new movie is out. // Prints 'Sequence {rdwyr0@parallels.com, mmacer2@sogou.com, rsobieski5@usatoday.com, rvarrand@jugem.jp}' people.select(p | p.field.at(7) == 'Horror').collect(p | p.field.at(3)).println(); Header-full CSV Model \u00b6 Consider that we add headers to the previous CSV model ( Headers.csv ) id,first_name,last_name,email,gender,job,credit_card,movies 604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,2558058636921002,Horror 272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Drama ... We can query the same information as before, but this time we can use the field names defined by the header: // Get all Rows elements var people = Row.all; // Get a random person var p = people.random(); // Check the gender of p // Prints 'Male' or 'Female' p.gender.println(); // Get the emails of people that like Horror movies so we can let them know a new movie is out. // Prints 'Sequence {rdwyr0@parallels.com, mmacer2@sogou.com, rsobieski5@usatoday.com, rvarrand@jugem.jp}' people.select(p | p.movies == 'Horror').collect(p | p.email).println(); // Get all males and females that like Thrillers and set up dates // Prints // Olvan and Cosetta is a match made in heaven! // Olvan and Lissa is a match made in heaven! var mt = people.select(p | p.movies == 'Thriller' and p.gender == 'Male'); var ft = people.select(p | p.movies == 'Thriller' and p.gender == 'Female'); for (m in mt) { for (f in ft) { (m.first_name + \" and \" + f.first_name + \" is a match made in heaven!\").println(); } } Header-full with Varargs CSV Model \u00b6 Last, we have a CSV model with some vararg information, is the same as before, but in this case persons are allowed to have multiple movies. We have also added a quote field that shows the quote character in action. id,first_name,last_name,email,gender,job,credit_card,quote,movies 604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,,Duis at velit eu est congue elementum.,Horror 272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Aenean sit amet justo. Morbi ut odio.,Drama,Film-Noir,Thriller 844-07-0023,Matteo,Macer,mmacer2@sogou.com,Male,Tax Accountant,3542981651057648,In hac habitasse platea dictumst.,Horror,Mystery,Thriller 429-41-4964,Kattie,Fysh,kfysh3@angelfire.com,Female,Senior Financial Analyst,,Suspendisse potenti. In eleifend quam a odio.,Comedy 378-90-9530,Link,Proffitt,lproffitt4@cloudflare.com,Male,Paralegal,,Suspendisse accumsan tortor quis turpis. Sed ante.,Drama 811-26-0387,Rafferty,Sobieski,rsobieski5@usatoday.com,Male,Physical Therapy Assistant,5602242765074843,\"Nulla neque libero, convallis eget, eleifend luctus, ultricies eu, nibh. Quisque id justo sit amet sapien dignissim vestibulum.\",Horror 386-53-1139,Ernestine,Kringe,ekringe6@gov.uk,Female,Software Consultant,3531096662484096,Nulla justo. Aliquam quis turpis eget elit sodales scelerisque.,Drama 850-05-5333,Flossy,Mobberley,fmobberley7@msn.com,Female,Chief Design Engineer,3558038696922012,Nulla tempus.,Comedy,Romance 605-52-9809,Tull,Ingerith,tingerith8@surveymonkey.com,Male,VP Quality Control,,\"Morbi vestibulum, velit id pretium iaculis, diam erat fermentum justo, nec condimentum neque sapien placerat ante. Nulla justo.\",Drama 580-79-7291,Derry,Laurisch,dlaurisch9@taobao.com,Male,Software Test Engineer I,,Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.,Drama,War 676-89-8860,Cosetta,Vlasov,cvlasova@livejournal.com,Female,Nurse Practicioner,,In hac habitasse platea dictumst.,Crime,Film-Noir,Thriller 748-10-2370,Lissa,Stanger,lstangerb@tmall.com,Female,Analyst Programmer,,Pellentesque at nulla.,Action,Adventure,Thriller 164-18-3409,Giffie,Boards,gboardsc@gmpg.org,Male,Graphic Designer,3575314620284632,\"Morbi vel lectus in quam fringilla rhoncus. Mauris enim leo, rhoncus sed, vestibulum sit amet, cursus id, turpis.\",Comedy 212-06-7778,Rabbi,Varran,rvarrand@jugem.jp,Male,GIS Technical Architect,3551249058791476,Suspendisse potenti.,Horror 628-02-3617,Olvan,Alabone,oalabonee@archive.org,Male,Help Desk Technician,,Pellentesque viverra pede ac diam. Cras pellentesque volutpat dui.,Action,Adventure,Sci-Fi,Thriller 318-48-3006,Constantino,Eyckelbeck,ceyckelbeckf@histats.com,Male,Recruiter,564182300132483644,In hac habitasse platea dictumst. Maecenas ut massa quis augue luctus tincidunt.,War 122-74-6759,Nickolas,Collard,ncollardg@dot.gov,Male,Web Designer IV,,Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.,Drama 309-57-3090,Chere,Hurry,churryh@huffingtonpost.com,Female,Tax Accountant,,\"In tempor, turpis nec euismod scelerisque, quam turpis adipiscing lorem, vitae mattis nibh ligula nec sem.\",Drama,Fantasy,Mystery 833-32-9040,Mattie,Hamon,mhamoni@auda.org.au,Male,Structural Engineer,,Duis at velit eu est congue elementum. In hac habitasse platea dictumst.,Drama 101-82-2564,Hew,Goble,hgoblej@ocn.ne.jp,Male,VP Accounting,,Etiam pretium iaculis justo.,Comedy // Get all Rows elements var people = Row.all; // Random thoughts for (p in people) { if (p.gender == \"Female\" and p.movies.includes(\"Thriller\")) { (p.first_name + \" screams '\" + p.quote + \"' when watching a Thriller. She is afraid of being a \" + p.job + \".\").println(); } else if (p.gender == \"Male\" and p.movies.includes(\"Drama\")) { (p.first_name + \" sighs, but blames '\" + p.quote + \"' for the tear in his eye. Being a \" + p.job + \" will never be the same.\").println(); } } // Output //Norry screams 'Aenean sit amet justo. Morbi ut odio.' when watching a Thriller. She is afraid of being a Legal Assistant. //Link sighs, but blames 'Suspendisse accumsan tortor quis turpis. Sed ante.' for the tear in his eye. Being a Paralegal will never be the same. //Tull sighs, but blames 'Morbi vestibulum, velit id pretium iaculis, diam erat fermentum justo, nec condimentum neque sapien placerat ante. Nulla justo.' for the tear in his eye. Being a VP Quality Control will never be the same. //Derry sighs, but blames 'Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.' for the tear in his eye. Being a Software Test Engineer I will never be the same. //Cosetta screams 'In hac habitasse platea dictumst.' when watching a Thriller. She is afraid of being a Nurse Practicioner. //Lissa screams 'Pellentesque at nulla.' when watching a Thriller. She is afraid of being a Analyst Programmer. //Nickolas sighs, but blames 'Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.' for the tear in his eye. Being a Web Designer IV will never be the same. //Mattie sighs, but blames 'Duis at velit eu est congue elementum. In hac habitasse platea dictumst.' for the tear in his eye. Being a Structural Engineer will never be the same. Querying/modifying CSV documents in EOL \u00b6 The CSV driver support direct query and modification of attribute values: // Get all Rows elements var people = Row.all; // Get a random person var p = people.random(); p.name.println(); // Change the name p.name = \"Maria Antonieta\" p.name.println(); How do I create an element? \u00b6 You can use the new operator for this, and remember that all CSV elements are rows! New Rows will be added at the end of the file when persisting the changes. // Check how many entries are in the model // Prints '20' Row.all.size().println(); // Creates a new book element var b = new Row; // Check again // Prints '21' Row.all.size().println(); Loading an CSV document in your ANT buildfile \u00b6 The following ANT build file demonstrates how you can use ANT to load/store and process CSV documents with Epsilon. <project default= \"main\" > <target name= \"main\" > <epsilon.csv.loadModel name= \"people\" file= \"people.csv\" read= \"true\" store= \"false\" , knownHeaders= \"true\" /> </epsilon.csv.loadModel> <epsilon.eol src= \"my.eol\" > <model ref= \"people\" /> </epsilon.eol> </target> </project> Loading an CSV document through Java code \u00b6 The following excerpt demonstrates using CSV models using Epsilon\\'s Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); CsvModel model = new CsvModel (); model . setName ( \"M\" ); model . setFile ( new File ( \"...\" )); char fieldSeparator = ',' ; model . setFieldSeparator ( fieldSeparator ); model . setKnownHeaders ( false ); model . setVarargsHeaders ( false ); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute ();","title":"Scripting CSV documents using Epsilon"},{"location":"doc/articles/csv-emc/#scripting-csv-documents-using-epsilon","text":"In this article we demonstrate how you can create, query and modify CSV documents in Epsilon programs using the CSV driver. The examples in this article demonstrate using EOL and ETL to script CSV documents. However, it's worth stressing that CSV documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or totext), compare and merge your CSV documents. Note: This article is consistent with Epsilon versions 1.5+.","title":"Scripting CSV documents using Epsilon"},{"location":"doc/articles/csv-emc/#the-csv-model-configuration-dialog","text":"To add a CSV document to your Epsilon launch configuration you first need to click on \"Show all model types\" in order to display the CSV Model type. From there you can select \"CSV Model\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. You need to provide a name for the model and select the CSV file using the \"Browse Workspace...\" button. The CSV section allows you to define specific behaviour for the CSV model. The Field Separator allows you to select a different separator than comma.... yes, they are called comma-separated files, but sometimes a colon, or a semi-colon, or other char is used as a field separator. Now you can tell the model loader which one too use. By default it is a comma. The Quote Character allows you to select the character used for quotes. Quotes are used when a column value contains the field separator to avoid erroneous input. The Known Headers tells the loader that the first row of your file contains headers. Headers can late be used to access fields of a row. The Varargs Header tells the loader that the last column/field of the file can span multiple columns. This is not the \"standard\" (did you know that RFC 4180 describes CSV file standards?), but in some cases it can be useful. Finally, the Id Field allows you to optionally select one of the fields as an id for your model elements. When using Known Headers , this should be the name of one of the fields. If not, it should be the index (integer) of the field. Next we show how the different options can be used when working with CSV models.","title":"The CSV Model Configuration Dialog"},{"location":"doc/articles/csv-emc/#querying-a-csv-document","text":"All elements in the CSV model are of type Row , that is, all model access has to be done using that type.","title":"Querying a CSV document"},{"location":"doc/articles/csv-emc/#header-less-csv-model","text":"Consider the following NoHeaders.csv input. 604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,2558058636921002,Horror 272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Drama 844-07-0023,Matteo,Macer,mmacer2@sogou.com,Male,Tax Accountant,3542981651057648,Horror 429-41-4964,Kattie,Fysh,kfysh3@angelfire.com,Female,Senior Financial Analyst,,Comedy 378-90-9530,Link,Proffitt,lproffitt4@cloudflare.com,Male,Paralegal,,Drama 811-26-0387,Rafferty,Sobieski,rsobieski5@usatoday.com,Male,Physical Therapy Assistant,5602242765074843,Horror 386-53-1139,Ernestine,Kringe,ekringe6@gov.uk,Female,Software Consultant,3531096662484096,Drama 850-05-5333,Flossy,Mobberley,fmobberley7@msn.com,Female,Chief Design Engineer,3558038696922012,Romance 605-52-9809,Tull,Ingerith,tingerith8@surveymonkey.com,Male,VP Quality Control,,Drama 580-79-7291,Derry,Laurisch,dlaurisch9@taobao.com,Male,Software Test Engineer I,,War 676-89-8860,Cosetta,Vlasov,cvlasova@livejournal.com,Female,Nurse Practicioner,,Thriller 748-10-2370,Lissa,Stanger,lstangerb@tmall.com,Female,Analyst Programmer,,Thriller 164-18-3409,Giffie,Boards,gboardsc@gmpg.org,Male,Graphic Designer,3575314620284632,Comedy 212-06-7778,Rabbi,Varran,rvarrand@jugem.jp,Male,GIS Technical Architect,3551249058791476,Horror 628-02-3617,Olvan,Alabone,oalabonee@archive.org,Male,Help Desk Technician,,Thriller 318-48-3006,Constantino,Eyckelbeck,ceyckelbeckf@histats.com,Male,Recruiter,564182300132483644,War 122-74-6759,Nickolas,Collard,ncollardg@dot.gov,Male,Web Designer IV,,Drama 309-57-3090,Chere,Hurry,churryh@huffingtonpost.com,Female,Tax Accountant,,Mystery 833-32-9040,Mattie,Hamon,mhamoni@auda.org.au,Male,Structural Engineer,,Drama 101-82-2564,Hew,Goble,hgoblej@ocn.ne.jp,Male,VP Accounting,,Comedy Since there are no headers, we need to access the information via the general field attribute and index (0 based): // Get all Rows elements var people = Row.all; // Get a random person var p = people.random(); // Check the gender of p (field 4) // Prints 'Male' or 'Female' p.field.at(4).println(); // Get the emails (field 3) of people that like Horror movies (field 7) so we can let them know a new movie is out. // Prints 'Sequence {rdwyr0@parallels.com, mmacer2@sogou.com, rsobieski5@usatoday.com, rvarrand@jugem.jp}' people.select(p | p.field.at(7) == 'Horror').collect(p | p.field.at(3)).println();","title":"Header-less CSV Model"},{"location":"doc/articles/csv-emc/#header-full-csv-model","text":"Consider that we add headers to the previous CSV model ( Headers.csv ) id,first_name,last_name,email,gender,job,credit_card,movies 604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,2558058636921002,Horror 272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Drama ... We can query the same information as before, but this time we can use the field names defined by the header: // Get all Rows elements var people = Row.all; // Get a random person var p = people.random(); // Check the gender of p // Prints 'Male' or 'Female' p.gender.println(); // Get the emails of people that like Horror movies so we can let them know a new movie is out. // Prints 'Sequence {rdwyr0@parallels.com, mmacer2@sogou.com, rsobieski5@usatoday.com, rvarrand@jugem.jp}' people.select(p | p.movies == 'Horror').collect(p | p.email).println(); // Get all males and females that like Thrillers and set up dates // Prints // Olvan and Cosetta is a match made in heaven! // Olvan and Lissa is a match made in heaven! var mt = people.select(p | p.movies == 'Thriller' and p.gender == 'Male'); var ft = people.select(p | p.movies == 'Thriller' and p.gender == 'Female'); for (m in mt) { for (f in ft) { (m.first_name + \" and \" + f.first_name + \" is a match made in heaven!\").println(); } }","title":"Header-full CSV Model"},{"location":"doc/articles/csv-emc/#header-full-with-varargs-csv-model","text":"Last, we have a CSV model with some vararg information, is the same as before, but in this case persons are allowed to have multiple movies. We have also added a quote field that shows the quote character in action. id,first_name,last_name,email,gender,job,credit_card,quote,movies 604-78-8459,Ricoriki,Dwyr,rdwyr0@parallels.com,Male,VP Quality Control,,Duis at velit eu est congue elementum.,Horror 272-41-1349,Norry,Halpin,nhalpin1@slashdot.org,Female,Legal Assistant,,Aenean sit amet justo. Morbi ut odio.,Drama,Film-Noir,Thriller 844-07-0023,Matteo,Macer,mmacer2@sogou.com,Male,Tax Accountant,3542981651057648,In hac habitasse platea dictumst.,Horror,Mystery,Thriller 429-41-4964,Kattie,Fysh,kfysh3@angelfire.com,Female,Senior Financial Analyst,,Suspendisse potenti. In eleifend quam a odio.,Comedy 378-90-9530,Link,Proffitt,lproffitt4@cloudflare.com,Male,Paralegal,,Suspendisse accumsan tortor quis turpis. Sed ante.,Drama 811-26-0387,Rafferty,Sobieski,rsobieski5@usatoday.com,Male,Physical Therapy Assistant,5602242765074843,\"Nulla neque libero, convallis eget, eleifend luctus, ultricies eu, nibh. Quisque id justo sit amet sapien dignissim vestibulum.\",Horror 386-53-1139,Ernestine,Kringe,ekringe6@gov.uk,Female,Software Consultant,3531096662484096,Nulla justo. Aliquam quis turpis eget elit sodales scelerisque.,Drama 850-05-5333,Flossy,Mobberley,fmobberley7@msn.com,Female,Chief Design Engineer,3558038696922012,Nulla tempus.,Comedy,Romance 605-52-9809,Tull,Ingerith,tingerith8@surveymonkey.com,Male,VP Quality Control,,\"Morbi vestibulum, velit id pretium iaculis, diam erat fermentum justo, nec condimentum neque sapien placerat ante. Nulla justo.\",Drama 580-79-7291,Derry,Laurisch,dlaurisch9@taobao.com,Male,Software Test Engineer I,,Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.,Drama,War 676-89-8860,Cosetta,Vlasov,cvlasova@livejournal.com,Female,Nurse Practicioner,,In hac habitasse platea dictumst.,Crime,Film-Noir,Thriller 748-10-2370,Lissa,Stanger,lstangerb@tmall.com,Female,Analyst Programmer,,Pellentesque at nulla.,Action,Adventure,Thriller 164-18-3409,Giffie,Boards,gboardsc@gmpg.org,Male,Graphic Designer,3575314620284632,\"Morbi vel lectus in quam fringilla rhoncus. Mauris enim leo, rhoncus sed, vestibulum sit amet, cursus id, turpis.\",Comedy 212-06-7778,Rabbi,Varran,rvarrand@jugem.jp,Male,GIS Technical Architect,3551249058791476,Suspendisse potenti.,Horror 628-02-3617,Olvan,Alabone,oalabonee@archive.org,Male,Help Desk Technician,,Pellentesque viverra pede ac diam. Cras pellentesque volutpat dui.,Action,Adventure,Sci-Fi,Thriller 318-48-3006,Constantino,Eyckelbeck,ceyckelbeckf@histats.com,Male,Recruiter,564182300132483644,In hac habitasse platea dictumst. Maecenas ut massa quis augue luctus tincidunt.,War 122-74-6759,Nickolas,Collard,ncollardg@dot.gov,Male,Web Designer IV,,Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.,Drama 309-57-3090,Chere,Hurry,churryh@huffingtonpost.com,Female,Tax Accountant,,\"In tempor, turpis nec euismod scelerisque, quam turpis adipiscing lorem, vitae mattis nibh ligula nec sem.\",Drama,Fantasy,Mystery 833-32-9040,Mattie,Hamon,mhamoni@auda.org.au,Male,Structural Engineer,,Duis at velit eu est congue elementum. In hac habitasse platea dictumst.,Drama 101-82-2564,Hew,Goble,hgoblej@ocn.ne.jp,Male,VP Accounting,,Etiam pretium iaculis justo.,Comedy // Get all Rows elements var people = Row.all; // Random thoughts for (p in people) { if (p.gender == \"Female\" and p.movies.includes(\"Thriller\")) { (p.first_name + \" screams '\" + p.quote + \"' when watching a Thriller. She is afraid of being a \" + p.job + \".\").println(); } else if (p.gender == \"Male\" and p.movies.includes(\"Drama\")) { (p.first_name + \" sighs, but blames '\" + p.quote + \"' for the tear in his eye. Being a \" + p.job + \" will never be the same.\").println(); } } // Output //Norry screams 'Aenean sit amet justo. Morbi ut odio.' when watching a Thriller. She is afraid of being a Legal Assistant. //Link sighs, but blames 'Suspendisse accumsan tortor quis turpis. Sed ante.' for the tear in his eye. Being a Paralegal will never be the same. //Tull sighs, but blames 'Morbi vestibulum, velit id pretium iaculis, diam erat fermentum justo, nec condimentum neque sapien placerat ante. Nulla justo.' for the tear in his eye. Being a VP Quality Control will never be the same. //Derry sighs, but blames 'Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.' for the tear in his eye. Being a Software Test Engineer I will never be the same. //Cosetta screams 'In hac habitasse platea dictumst.' when watching a Thriller. She is afraid of being a Nurse Practicioner. //Lissa screams 'Pellentesque at nulla.' when watching a Thriller. She is afraid of being a Analyst Programmer. //Nickolas sighs, but blames 'Praesent blandit lacinia erat. Vestibulum sed magna at nunc commodo placerat.' for the tear in his eye. Being a Web Designer IV will never be the same. //Mattie sighs, but blames 'Duis at velit eu est congue elementum. In hac habitasse platea dictumst.' for the tear in his eye. Being a Structural Engineer will never be the same.","title":"Header-full with Varargs CSV Model"},{"location":"doc/articles/csv-emc/#queryingmodifying-csv-documents-in-eol","text":"The CSV driver support direct query and modification of attribute values: // Get all Rows elements var people = Row.all; // Get a random person var p = people.random(); p.name.println(); // Change the name p.name = \"Maria Antonieta\" p.name.println();","title":"Querying/modifying CSV documents in EOL"},{"location":"doc/articles/csv-emc/#how-do-i-create-an-element","text":"You can use the new operator for this, and remember that all CSV elements are rows! New Rows will be added at the end of the file when persisting the changes. // Check how many entries are in the model // Prints '20' Row.all.size().println(); // Creates a new book element var b = new Row; // Check again // Prints '21' Row.all.size().println();","title":"How do I create an element?"},{"location":"doc/articles/csv-emc/#loading-an-csv-document-in-your-ant-buildfile","text":"The following ANT build file demonstrates how you can use ANT to load/store and process CSV documents with Epsilon. <project default= \"main\" > <target name= \"main\" > <epsilon.csv.loadModel name= \"people\" file= \"people.csv\" read= \"true\" store= \"false\" , knownHeaders= \"true\" /> </epsilon.csv.loadModel> <epsilon.eol src= \"my.eol\" > <model ref= \"people\" /> </epsilon.eol> </target> </project>","title":"Loading an CSV document in your ANT buildfile"},{"location":"doc/articles/csv-emc/#loading-an-csv-document-through-java-code","text":"The following excerpt demonstrates using CSV models using Epsilon\\'s Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); CsvModel model = new CsvModel (); model . setName ( \"M\" ); model . setFile ( new File ( \"...\" )); char fieldSeparator = ',' ; model . setFieldSeparator ( fieldSeparator ); model . setKnownHeaders ( false ); model . setVarargsHeaders ( false ); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute ();","title":"Loading an CSV document through Java code"},{"location":"doc/articles/dev-setup/","text":"Eclipse Setup for Epsilon Developers \u00b6 If you are a contributor to Epsilon (or you want to build on top of it), and don't already have Eclipse installed or the repository cloned, you can easily set this up automatically in a few clicks. Head to the Downloads page , download the installer for your platform and launch it. Then switch to Advanced Mode. Select \"Eclipse IDE for Java Developers\" in the Product page and then Next. On the Projects page, look for Epsilon and select it, then Next. You can customise variables to suit, such as where Eclipse will be installed and the protocol for cloning the repositories. The defaults should be fine. Keep going with Next and then Finish. If all went to plan, then you should have a local copy of the main Epsilon repository and the website , with projects imported into Eclipse. You may need to wait for setup tasks to finish when first launching Eclipse. This can also be manually triggered from the Help -> Perform Setup Tasks menu in Eclipse. If you encounter any issues, please let us know via the mailing list or forum .","title":"Eclipse Setup for Epsilon Developers"},{"location":"doc/articles/dev-setup/#eclipse-setup-for-epsilon-developers","text":"If you are a contributor to Epsilon (or you want to build on top of it), and don't already have Eclipse installed or the repository cloned, you can easily set this up automatically in a few clicks. Head to the Downloads page , download the installer for your platform and launch it. Then switch to Advanced Mode. Select \"Eclipse IDE for Java Developers\" in the Product page and then Next. On the Projects page, look for Epsilon and select it, then Next. You can customise variables to suit, such as where Eclipse will be installed and the protocol for cloning the repositories. The defaults should be fine. Keep going with Next and then Finish. If all went to plan, then you should have a local copy of the main Epsilon repository and the website , with projects imported into Eclipse. You may need to wait for setup tasks to finish when first launching Eclipse. This can also be manually triggered from the Help -> Perform Setup Tasks menu in Eclipse. If you encounter any issues, please let us know via the mailing list or forum .","title":"Eclipse Setup for Epsilon Developers"},{"location":"doc/articles/developing-a-new-emc-driver/","text":"Developing a new EMC Driver \u00b6 The following training session recording and decks of slides demonstrate the implementation of a new \"driver\" for Epsilon's Model Connectivity layer that allows all Epsilon languages to interact with CSV files. The complete source-code is located in the Epsilon Git repository (see details in the slides).","title":"Developing a new EMC Driver"},{"location":"doc/articles/developing-a-new-emc-driver/#developing-a-new-emc-driver","text":"The following training session recording and decks of slides demonstrate the implementation of a new \"driver\" for Epsilon's Model Connectivity layer that allows all Epsilon languages to interact with CSV files. The complete source-code is located in the Epsilon Git repository (see details in the slides).","title":"Developing a new EMC Driver"},{"location":"doc/articles/developing-a-new-language/","text":"Developing a new Epsilon Language \u00b6 The following decks of slides demonstrate the implementation of two minimal model management languages (and their supporting Eclipse-based development tools) on top of Epsilon: one using annotations (TestLang - with fewer than 200 lines of code), and one using grammar extension (EDL - with fewer than 300 lines of code). All the source-code for the two languages is located in the Epsilon Git repository (see details in the slides). Annotations: TestLang \u00b6 Grammar Extension: Epsilon Demo Language (EDL) \u00b6","title":"Developing a new Epsilon Language"},{"location":"doc/articles/developing-a-new-language/#developing-a-new-epsilon-language","text":"The following decks of slides demonstrate the implementation of two minimal model management languages (and their supporting Eclipse-based development tools) on top of Epsilon: one using annotations (TestLang - with fewer than 200 lines of code), and one using grammar extension (EDL - with fewer than 300 lines of code). All the source-code for the two languages is located in the Epsilon Git repository (see details in the slides).","title":"Developing a new Epsilon Language"},{"location":"doc/articles/developing-a-new-language/#annotations-testlang","text":"","title":"Annotations: TestLang"},{"location":"doc/articles/developing-a-new-language/#grammar-extension-epsilon-demo-language-edl","text":"","title":"Grammar Extension: Epsilon Demo Language (EDL)"},{"location":"doc/articles/development-principles/","text":"Epsilon Development Principles \u00b6 This article describes the guiding principles that the committers of Epsilon follow. In-keeping with agile development principles, we don't use a strict/heavy-weight development process. Each member of the development team is free to use quite different approaches to software development. However, we aim to follow the following principles to ensure that there is a basic level of consistency across the Epsilon platform and its development. General \u00b6 Be mindful of different use cases : design, implementation and evolution of the platform respects that Epsilon can be used in different environments (from Eclipse or stand-alone) and on different operating systems (Windows, Linux, Mac OS); and that Epsilon programs can be invoked in different manners (Eclipse launch configurations, Ant tasks, programmatically). Maintain backwards-compatibility : the APIs exposed by Epsilon should be stable. Changes should not break client code. We use deprecation to warn users that an API has changed, and might be changed in a breaking manner in a future version of Epsilon. Source code \u00b6 Collectively own the code : all of the code is owned by the entire team, and anybody can make changes anywhere. Often, we work together on changes to the core of the platform, or to languages that a particular committer has developed initially (e.g., we might work closely with Antonio on a change to EUnit, because Antonio has done most of the recent work on EUnit). Collaborate on design : although we rarely practice \"live\" pair programming, we do share patches and discuss important design decisions internally. Adhere to code conventions We do not place opening brackets on their own line. We always use braces for the bodies of if / while / for statements, unless it's a single statement that can be placed on the same line. Also, else if and else statements are not placed in the same line as the closing brace of the previous block, but on the next one. Avoid printing the stack traces of caught exceptions. When users run Epsilon from Eclipse they won't see these stack traces while and when they use Epsilon as a library, the stack traces will pollute the application's output. If you can handle the exception meaningfully in the catch block, then do it and don't print its stack trace, otherwise throw the exception for the caller to handle. // Not OK if ( true ) { return false ; } // OK if ( true ) { return false ; } // Not OK if ( true ) return false ; // OK if ( true ) return false ; // Not OK if ( something ) { do something ; } else if ( other thing ) { do other thing ; } else { do alternative thing ; } // OK if ( something ) { do something ; } else if ( other thing ) { do other thing ; } else { do alternative thing ; } // Not OK try { somethingDangerous (); } catch ( Exception ex ) { ex . printStackTrace (); } Testing \u00b6 Favour automated testing : to provide some assurance that we are shipping working code, we include automated tests along with feature code. Favour testing over testing-first : although we appreciate the benefits of test-first and test-driven development, we do not always develop tests first, often preferring peer review to make design decisions. Everyone uses the same testing frameworks : currently we favour JUnit 4 and Mockito for testing and mocking, respectively. Older code might still use other libraries (e.g. JUnit 3 and JMock), and we aim to replace these when we encounter them. Bug/Feature Tracking \u00b6 Trace changes using Bugzilla : we use Bugzilla to document and discuss design and implementation changes. We often raise our own bugs. We use bug numbers in commit messages to maintain trace links between the code and discussions about the code. Adhere to Bugzilla conventions : we follow a small set of Bugzilla conventions . Source Code Management \u00b6 Describe commits with meaningful messages : to ensure that the history of the code can be understood by every member of the team, we endeavour to make our commit messages understandable and traceable. Metadata is often include in commit messages, for example: \"[EOL] Fixes bug #123456, which prevented the creation of widgets.\" Avoid large commits : to ensure that the history of the code can be understood by every member of the team, we favour breaking large commits into smaller consecutive commits. Technical Support \u00b6 No forum post goes unanswered : to maintain and foster the community around Epsilon, we answer every question on the user forum. Encourage users to produce minimal examples : if we need to reproduce a user's issue, we will often ask for a minimal example to aid in debugging. We have found this to be effective because it allows us to focus most of our time on fixing issues, and because users sometimes discover the solution to their issue while producing the minimal example.","title":"Epsilon Development Principles"},{"location":"doc/articles/development-principles/#epsilon-development-principles","text":"This article describes the guiding principles that the committers of Epsilon follow. In-keeping with agile development principles, we don't use a strict/heavy-weight development process. Each member of the development team is free to use quite different approaches to software development. However, we aim to follow the following principles to ensure that there is a basic level of consistency across the Epsilon platform and its development.","title":"Epsilon Development Principles"},{"location":"doc/articles/development-principles/#general","text":"Be mindful of different use cases : design, implementation and evolution of the platform respects that Epsilon can be used in different environments (from Eclipse or stand-alone) and on different operating systems (Windows, Linux, Mac OS); and that Epsilon programs can be invoked in different manners (Eclipse launch configurations, Ant tasks, programmatically). Maintain backwards-compatibility : the APIs exposed by Epsilon should be stable. Changes should not break client code. We use deprecation to warn users that an API has changed, and might be changed in a breaking manner in a future version of Epsilon.","title":"General"},{"location":"doc/articles/development-principles/#source-code","text":"Collectively own the code : all of the code is owned by the entire team, and anybody can make changes anywhere. Often, we work together on changes to the core of the platform, or to languages that a particular committer has developed initially (e.g., we might work closely with Antonio on a change to EUnit, because Antonio has done most of the recent work on EUnit). Collaborate on design : although we rarely practice \"live\" pair programming, we do share patches and discuss important design decisions internally. Adhere to code conventions We do not place opening brackets on their own line. We always use braces for the bodies of if / while / for statements, unless it's a single statement that can be placed on the same line. Also, else if and else statements are not placed in the same line as the closing brace of the previous block, but on the next one. Avoid printing the stack traces of caught exceptions. When users run Epsilon from Eclipse they won't see these stack traces while and when they use Epsilon as a library, the stack traces will pollute the application's output. If you can handle the exception meaningfully in the catch block, then do it and don't print its stack trace, otherwise throw the exception for the caller to handle. // Not OK if ( true ) { return false ; } // OK if ( true ) { return false ; } // Not OK if ( true ) return false ; // OK if ( true ) return false ; // Not OK if ( something ) { do something ; } else if ( other thing ) { do other thing ; } else { do alternative thing ; } // OK if ( something ) { do something ; } else if ( other thing ) { do other thing ; } else { do alternative thing ; } // Not OK try { somethingDangerous (); } catch ( Exception ex ) { ex . printStackTrace (); }","title":"Source code"},{"location":"doc/articles/development-principles/#testing","text":"Favour automated testing : to provide some assurance that we are shipping working code, we include automated tests along with feature code. Favour testing over testing-first : although we appreciate the benefits of test-first and test-driven development, we do not always develop tests first, often preferring peer review to make design decisions. Everyone uses the same testing frameworks : currently we favour JUnit 4 and Mockito for testing and mocking, respectively. Older code might still use other libraries (e.g. JUnit 3 and JMock), and we aim to replace these when we encounter them.","title":"Testing"},{"location":"doc/articles/development-principles/#bugfeature-tracking","text":"Trace changes using Bugzilla : we use Bugzilla to document and discuss design and implementation changes. We often raise our own bugs. We use bug numbers in commit messages to maintain trace links between the code and discussions about the code. Adhere to Bugzilla conventions : we follow a small set of Bugzilla conventions .","title":"Bug/Feature Tracking"},{"location":"doc/articles/development-principles/#source-code-management","text":"Describe commits with meaningful messages : to ensure that the history of the code can be understood by every member of the team, we endeavour to make our commit messages understandable and traceable. Metadata is often include in commit messages, for example: \"[EOL] Fixes bug #123456, which prevented the creation of widgets.\" Avoid large commits : to ensure that the history of the code can be understood by every member of the team, we favour breaking large commits into smaller consecutive commits.","title":"Source Code Management"},{"location":"doc/articles/development-principles/#technical-support","text":"No forum post goes unanswered : to maintain and foster the community around Epsilon, we answer every question on the user forum. Encourage users to produce minimal examples : if we need to reproduce a user's issue, we will often ask for a minimal example to aid in debugging. We have found this to be effective because it allows us to focus most of our time on fixing issues, and because users sometimes discover the solution to their issue while producing the minimal example.","title":"Technical Support"},{"location":"doc/articles/egl-invoke-egl/","text":"Re-using EGL templates \u00b6 Sometimes it may be handy to send the output of one EGL template into another EGL template. This is a great idea because it will make your templates more modular, cohesive and lead to less code overall. For example, suppose you've been generating an XML file for each Book in your model. Hence, you have a Book2XML.egl template with the following contents: <book> <title>[%=title%]</title> <isbn>[%=isbn%]</isbn> <pages>[%=pages.asString()%]</pages> <authors> [% for (author in authors) {%] <author name=\"[%=author.name%]\"/> [%}%] </authors> </book> Suppose that now you also want to generate a single XML for each Library; where a Library is a collection of Books. Instead of duplicating the code in Book2XML.egl, you can re-use it by calling it from Library2XML.egl, like so: <library id=[%=lib.id%] name=\"[%=lib.name%]\"> [% for (book in lib.books) { var bookTemplate : Template = TemplateFactory.load(\"/path/to/Book2XML.egl\"); bookTemplate.populate(\"book\", book); bookTemplate.populate(\"title\", book.title); bookTemplate.populate(\"isbn\", book.isbn); bookTemplate.populate(\"pages\", book.pages); bookTemplate.populate(\"authors\", book.authors); %] [%=bookTemplate.process()%] [%}%] As with EGX, you can pass parameters to the invoked template using the \"populate\" operation, where the first parameter is the variable name (that the invoked template will see) and the second parameter is the value.","title":"Re-using EGL templates"},{"location":"doc/articles/egl-invoke-egl/#re-using-egl-templates","text":"Sometimes it may be handy to send the output of one EGL template into another EGL template. This is a great idea because it will make your templates more modular, cohesive and lead to less code overall. For example, suppose you've been generating an XML file for each Book in your model. Hence, you have a Book2XML.egl template with the following contents: <book> <title>[%=title%]</title> <isbn>[%=isbn%]</isbn> <pages>[%=pages.asString()%]</pages> <authors> [% for (author in authors) {%] <author name=\"[%=author.name%]\"/> [%}%] </authors> </book> Suppose that now you also want to generate a single XML for each Library; where a Library is a collection of Books. Instead of duplicating the code in Book2XML.egl, you can re-use it by calling it from Library2XML.egl, like so: <library id=[%=lib.id%] name=\"[%=lib.name%]\"> [% for (book in lib.books) { var bookTemplate : Template = TemplateFactory.load(\"/path/to/Book2XML.egl\"); bookTemplate.populate(\"book\", book); bookTemplate.populate(\"title\", book.title); bookTemplate.populate(\"isbn\", book.isbn); bookTemplate.populate(\"pages\", book.pages); bookTemplate.populate(\"authors\", book.authors); %] [%=bookTemplate.process()%] [%}%] As with EGX, you can pass parameters to the invoked template using the \"populate\" operation, where the first parameter is the variable name (that the invoked template will see) and the second parameter is the value.","title":"Re-using EGL templates"},{"location":"doc/articles/egl-server-side/","text":"Using EGL as a server-side scripting language in Tomcat \u00b6 The original purpose of EGL was to enable batch generation of source code and other textual artefacts from EMF models. However, since there is no hard binding between the language and the file system, it is also possible to use EGL in other contexts. In this article, we demonstrate using EGL as a server-side scripting language in Tomcat, to produce web pages from EMF models on the fly. Setup \u00b6 Download a fresh copy of Tomcat 6.0 here and extract it Download egl-servlet-full.zip Extract all .jar files from the zip into the lib folder of Tomcat Open web.xml in the conf directory of Tomcat and add the following snippet <servlet> <servlet-name> egl </servlet-name> <servlet-class> org.eclipse.epsilon.egl.servlet.EglServlet </servlet-class> <load-on-startup> 1 </load-on-startup> </servlet> <servlet-mapping> <servlet-name> egl </servlet-name> <url-pattern> *.egl </url-pattern> </servlet-mapping> Make sure that there is an environment variable called JRE_HOME and it's pointing to your JRE installation directory (the root, not the bin ). In Windows, you can create this variable from System Properties \u2192 Advanced \u2192 Environment Variables \u2192 System Variables \u2192 New... Create a Hello World web application \u00b6 To create a hello world web application and test your installation, you need to go through the following steps: Go to the webapps folder and create a new directory named helloworld Inside helloworld , create a new file called index.egl and add to it the following code [%=\"Hello World\"%] Start Tomcat using bin/startup.bat (or startup.sh in Linux/MacOS) Open your browser and go to http://localhost:8080/helloworld/index.egl A web-page with the text Hello World should appear. If not, please make sure you've followed all the steps above and if it still doesn't work, please drop by the forum and we'll be happy to help. Accessing parameters from the URL \u00b6 To access parameters from the URL (or fields of a submitted form) you can use the request.getParameter('parameter-name') method. For example, by modifying the source code of index.egl to the following [%=\"Hello \"+request.getParameter(\"visitor\")%] and navigating to http://localhost:8080/helloworld/index.egl?visitor=John , you should get a page reading Hello John as a result. Other built-in objects \u00b6 EGL provides the following built-in objects which (should) function exactly like they do in JSP request response config application session You may want to have a look here for a tutorial that explains their functionality. Caching \u00b6 EGL provides the built-in cache object to facilitate two types of caching. Page caching can be used to ensure that repeated requests to the same URL do not result in the execution of EGL templates. Fragment caching can be used to share the text generated by a template between requests for different URLs. For example, the following code is used to ensure that repeated requests for pages matching the regular expression index.* are served from the page cache: [% cache.pages(\"index.*\"); %] The page cache can be expired programmatically, as shown below, or by restarting the Tomcat server. [% cache.expirePages(\"index.*\"); %] In addition to page caching, EGL supports fragment caching which allows the contents of a sub-template to be cached. For example, the following code processes sidebar.egl only the first time that the template is executed: [% var sidebarTemplate = TemplateFactory.load(\"Sidebar.egl\"); %] [%=cache.fragment(sidebarTemplate) %] Note that the fragment method should be used in a dynamic output section. Like pages, fragments can be expired programmatically (or by restarting the Tomcat server): [% cache.expireFragment(sidebarTemplate); %] A simple caching strategy is to populate the page and fragment caches from your main EGL templates, and to provide a ClearCache.egl template in a sub-directory that only administrators that can access. Loading EMF models in EGL pages \u00b6 The main motivation for turning EGL into a server-side scripting language is its ability to work well with EMF models. EGL provides the modelManager built-in object to let you load EMF models that reside in the web application. To experiment with modelManager , download the Graph.ecore and Ecore.ecore models and place them in your helloworld directory. Then, change your index.egl to look like this [% modelManager.registerMetamodel(\"Ecore.ecore\"); modelManager.loadModel(\"Sample\", \"Graph.ecore\", \"http://www.eclipse.org/emf/2002/Ecore\"); %] The metamodel has [%=EClass.all.size()%] classes Refresh the page in your browser and it should now read: The metamodel has 3 classes The Model Manager \u00b6 The modelManager built-in object provides the following methods: registerMetamodel(file : String) : Registers the file (should be an Ecore metamodel) in EPackage.Registry.INSTANCE loadModel(name : String, modelFile : String, metamodelURI : String) : Loads the model stored in modelFile using the registered metamodel metamodelURI . loadModelByFile(name : String, modelFile : String, metamodelFile : String) : Loads the model stored in modelFile using the metamodel in metamodelFile . loadModel(name : String, aliases : String, modelFile : String, metamodel : String, expand : Boolean, metamodelIsFilebased : Boolean) : Provides more parameters for loading models. uncacheModel(modelFile : String) : Removes the modelFile from the cache (next call to loadModel() will actually reload it) clear() : Clears cached models and metamodels Sharing models between templates \u00b6 Currently, each model is only loaded once (the first time the loadModel() or loadModelByFile() is called). If multiple pages need to access the same model, add the model loading logic in an operation in a separate models.eol file: operation loadModels() { modelManager.registerMetamodel(\"Ecore.ecore\"); modelManager.loadModel(\"Sample\", \"Graph.ecore\", \"http://www.eclipse.org/emf/2002/Ecore\"); } and then import and call it from each one of your pages: [% import \"models.eol\"; loadModels(); %] // Page code here Running EGL on Google App Engine \u00b6 By default App Engine will treat EGL files as static content and serve their source code instead of executing them. To work around this, add the following snippet under the root element of the appengine-web.xml configuration file of your App Engine application. <static-files> <exclude path= \"*.egl\" /> </static-files> Working with big models \u00b6 If you encounter a Java OutOfMemoryError while querying a big model you'll need to start Tomcat with more memory than the default 256 MB. To do this, go to bin/catalina.bat (on Windows -- if you're on Linux you should modify catalina.sh accordingly) and change line set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% to set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Xms1024m -Xmx1024m -XX:MaxPermSize=128m If you keep getting out of memory errors, you may find PSI Probe useful for figuring out what's going wrong.","title":"Using EGL as a server-side scripting language in Tomcat"},{"location":"doc/articles/egl-server-side/#using-egl-as-a-server-side-scripting-language-in-tomcat","text":"The original purpose of EGL was to enable batch generation of source code and other textual artefacts from EMF models. However, since there is no hard binding between the language and the file system, it is also possible to use EGL in other contexts. In this article, we demonstrate using EGL as a server-side scripting language in Tomcat, to produce web pages from EMF models on the fly.","title":"Using EGL as a server-side scripting language in Tomcat"},{"location":"doc/articles/egl-server-side/#setup","text":"Download a fresh copy of Tomcat 6.0 here and extract it Download egl-servlet-full.zip Extract all .jar files from the zip into the lib folder of Tomcat Open web.xml in the conf directory of Tomcat and add the following snippet <servlet> <servlet-name> egl </servlet-name> <servlet-class> org.eclipse.epsilon.egl.servlet.EglServlet </servlet-class> <load-on-startup> 1 </load-on-startup> </servlet> <servlet-mapping> <servlet-name> egl </servlet-name> <url-pattern> *.egl </url-pattern> </servlet-mapping> Make sure that there is an environment variable called JRE_HOME and it's pointing to your JRE installation directory (the root, not the bin ). In Windows, you can create this variable from System Properties \u2192 Advanced \u2192 Environment Variables \u2192 System Variables \u2192 New...","title":"Setup"},{"location":"doc/articles/egl-server-side/#create-a-hello-world-web-application","text":"To create a hello world web application and test your installation, you need to go through the following steps: Go to the webapps folder and create a new directory named helloworld Inside helloworld , create a new file called index.egl and add to it the following code [%=\"Hello World\"%] Start Tomcat using bin/startup.bat (or startup.sh in Linux/MacOS) Open your browser and go to http://localhost:8080/helloworld/index.egl A web-page with the text Hello World should appear. If not, please make sure you've followed all the steps above and if it still doesn't work, please drop by the forum and we'll be happy to help.","title":"Create a Hello World web application"},{"location":"doc/articles/egl-server-side/#accessing-parameters-from-the-url","text":"To access parameters from the URL (or fields of a submitted form) you can use the request.getParameter('parameter-name') method. For example, by modifying the source code of index.egl to the following [%=\"Hello \"+request.getParameter(\"visitor\")%] and navigating to http://localhost:8080/helloworld/index.egl?visitor=John , you should get a page reading Hello John as a result.","title":"Accessing parameters from the URL"},{"location":"doc/articles/egl-server-side/#other-built-in-objects","text":"EGL provides the following built-in objects which (should) function exactly like they do in JSP request response config application session You may want to have a look here for a tutorial that explains their functionality.","title":"Other built-in objects"},{"location":"doc/articles/egl-server-side/#caching","text":"EGL provides the built-in cache object to facilitate two types of caching. Page caching can be used to ensure that repeated requests to the same URL do not result in the execution of EGL templates. Fragment caching can be used to share the text generated by a template between requests for different URLs. For example, the following code is used to ensure that repeated requests for pages matching the regular expression index.* are served from the page cache: [% cache.pages(\"index.*\"); %] The page cache can be expired programmatically, as shown below, or by restarting the Tomcat server. [% cache.expirePages(\"index.*\"); %] In addition to page caching, EGL supports fragment caching which allows the contents of a sub-template to be cached. For example, the following code processes sidebar.egl only the first time that the template is executed: [% var sidebarTemplate = TemplateFactory.load(\"Sidebar.egl\"); %] [%=cache.fragment(sidebarTemplate) %] Note that the fragment method should be used in a dynamic output section. Like pages, fragments can be expired programmatically (or by restarting the Tomcat server): [% cache.expireFragment(sidebarTemplate); %] A simple caching strategy is to populate the page and fragment caches from your main EGL templates, and to provide a ClearCache.egl template in a sub-directory that only administrators that can access.","title":"Caching"},{"location":"doc/articles/egl-server-side/#loading-emf-models-in-egl-pages","text":"The main motivation for turning EGL into a server-side scripting language is its ability to work well with EMF models. EGL provides the modelManager built-in object to let you load EMF models that reside in the web application. To experiment with modelManager , download the Graph.ecore and Ecore.ecore models and place them in your helloworld directory. Then, change your index.egl to look like this [% modelManager.registerMetamodel(\"Ecore.ecore\"); modelManager.loadModel(\"Sample\", \"Graph.ecore\", \"http://www.eclipse.org/emf/2002/Ecore\"); %] The metamodel has [%=EClass.all.size()%] classes Refresh the page in your browser and it should now read: The metamodel has 3 classes","title":"Loading EMF models in EGL pages"},{"location":"doc/articles/egl-server-side/#the-model-manager","text":"The modelManager built-in object provides the following methods: registerMetamodel(file : String) : Registers the file (should be an Ecore metamodel) in EPackage.Registry.INSTANCE loadModel(name : String, modelFile : String, metamodelURI : String) : Loads the model stored in modelFile using the registered metamodel metamodelURI . loadModelByFile(name : String, modelFile : String, metamodelFile : String) : Loads the model stored in modelFile using the metamodel in metamodelFile . loadModel(name : String, aliases : String, modelFile : String, metamodel : String, expand : Boolean, metamodelIsFilebased : Boolean) : Provides more parameters for loading models. uncacheModel(modelFile : String) : Removes the modelFile from the cache (next call to loadModel() will actually reload it) clear() : Clears cached models and metamodels","title":"The Model Manager"},{"location":"doc/articles/egl-server-side/#sharing-models-between-templates","text":"Currently, each model is only loaded once (the first time the loadModel() or loadModelByFile() is called). If multiple pages need to access the same model, add the model loading logic in an operation in a separate models.eol file: operation loadModels() { modelManager.registerMetamodel(\"Ecore.ecore\"); modelManager.loadModel(\"Sample\", \"Graph.ecore\", \"http://www.eclipse.org/emf/2002/Ecore\"); } and then import and call it from each one of your pages: [% import \"models.eol\"; loadModels(); %] // Page code here","title":"Sharing models between templates"},{"location":"doc/articles/egl-server-side/#running-egl-on-google-app-engine","text":"By default App Engine will treat EGL files as static content and serve their source code instead of executing them. To work around this, add the following snippet under the root element of the appengine-web.xml configuration file of your App Engine application. <static-files> <exclude path= \"*.egl\" /> </static-files>","title":"Running EGL on Google App Engine"},{"location":"doc/articles/egl-server-side/#working-with-big-models","text":"If you encounter a Java OutOfMemoryError while querying a big model you'll need to start Tomcat with more memory than the default 256 MB. To do this, go to bin/catalina.bat (on Windows -- if you're on Linux you should modify catalina.sh accordingly) and change line set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% to set JAVA_OPTS=%JAVA_OPTS% %LOGGING_MANAGER% -Xms1024m -Xmx1024m -XX:MaxPermSize=128m If you keep getting out of memory errors, you may find PSI Probe useful for figuring out what's going wrong.","title":"Working with big models"},{"location":"doc/articles/egl-template-operations/","text":"Using template operations in EGL \u00b6 Template operations provide a way to re-use small fragments of EGL code. This article shows how to write EGL template operations and discusses when you might want to use them. Suppose we are writing a code generator for plain-old Java objects, and we have the following EGL code (which assumes the presence of a class object): class [%=class.name%] { [% for (feature in class.features) { %] /** * Gets the value of [%=feature.firstToLowerCase()%] */ public [%=feature.type%] get[%=feature%]() { return [%=feature.firstToLowerCase()%]; } /** * Sets the value of [%=feature.firstToLowerCase()%] */ public void set[%=feature%]([%=feature.type%] [%=feature.firstToLowerCase()%]) { this.[%=feature.firstToLowerCase()%] = [%=feature.firstToLowerCase()%]; } [% } %] } While the above code will work, it has a couple of drawbacks. Firstly, the code to generate getters and setters cannot be re-used in other templates. Secondly, the template is arguably hard to read - the purpose of the loop's body is not immediately clear. Using EGL template operations, the above code becomes: class [%=class.name%] { [% for (feature in class.features) { %] [%=feature.getter()%] [%=feature.setter()%] [% } %] } [% @template operation Feature getter() { %] /** * Gets the value of [%=self.firstToLowerCase()%] */ public [%=self.type%] get[%=self%]() { return [%=self.firstToLowerCase()%]; } [% } %] @template operation Feature setter() { %] /** * Sets the value of [%=self.firstToLowerCase()%] */ public void set[%=self%]([%=self.type%] [%=self.firstToLowerCase()%]) { this.[%=self.firstToLowerCase()%] = [%=self.firstToLowerCase()%]; } [% } %] Notice that, in the body of the loop, we call the template operations, getter and setter , to generate the getter and setter methods for each feature. This makes the loop arguably easier to read, and the getter and setter operations can be re-used in other templates. Template operations are annotated with @template and can mix dynamic and static sections, just like the main part of an EGL template. Operations are defined on metamodel types (Feature in the code above), and may be called on any model element that instantiates that type. In the body of an operation, the keyword self is used to refer to the model element on which the operation has been called. Common issues \u00b6 Issue: my template operation produces no output. Resolution: ensure that the call to the template operation is placed in a dynamic output section (e.g. [%=thing.op()%] ) rather than in a plain dynamic section (e.g. [% thing.op(); %] ). Template operations return a value, which must then be emitted to the main template using a dynamic output section. Thanks to Mark Tippetts for reporting this issue via the Epsilon forum .","title":"Using template operations in EGL"},{"location":"doc/articles/egl-template-operations/#using-template-operations-in-egl","text":"Template operations provide a way to re-use small fragments of EGL code. This article shows how to write EGL template operations and discusses when you might want to use them. Suppose we are writing a code generator for plain-old Java objects, and we have the following EGL code (which assumes the presence of a class object): class [%=class.name%] { [% for (feature in class.features) { %] /** * Gets the value of [%=feature.firstToLowerCase()%] */ public [%=feature.type%] get[%=feature%]() { return [%=feature.firstToLowerCase()%]; } /** * Sets the value of [%=feature.firstToLowerCase()%] */ public void set[%=feature%]([%=feature.type%] [%=feature.firstToLowerCase()%]) { this.[%=feature.firstToLowerCase()%] = [%=feature.firstToLowerCase()%]; } [% } %] } While the above code will work, it has a couple of drawbacks. Firstly, the code to generate getters and setters cannot be re-used in other templates. Secondly, the template is arguably hard to read - the purpose of the loop's body is not immediately clear. Using EGL template operations, the above code becomes: class [%=class.name%] { [% for (feature in class.features) { %] [%=feature.getter()%] [%=feature.setter()%] [% } %] } [% @template operation Feature getter() { %] /** * Gets the value of [%=self.firstToLowerCase()%] */ public [%=self.type%] get[%=self%]() { return [%=self.firstToLowerCase()%]; } [% } %] @template operation Feature setter() { %] /** * Sets the value of [%=self.firstToLowerCase()%] */ public void set[%=self%]([%=self.type%] [%=self.firstToLowerCase()%]) { this.[%=self.firstToLowerCase()%] = [%=self.firstToLowerCase()%]; } [% } %] Notice that, in the body of the loop, we call the template operations, getter and setter , to generate the getter and setter methods for each feature. This makes the loop arguably easier to read, and the getter and setter operations can be re-used in other templates. Template operations are annotated with @template and can mix dynamic and static sections, just like the main part of an EGL template. Operations are defined on metamodel types (Feature in the code above), and may be called on any model element that instantiates that type. In the body of an operation, the keyword self is used to refer to the model element on which the operation has been called.","title":"Using template operations in EGL"},{"location":"doc/articles/egl-template-operations/#common-issues","text":"Issue: my template operation produces no output. Resolution: ensure that the call to the template operation is placed in a dynamic output section (e.g. [%=thing.op()%] ) rather than in a plain dynamic section (e.g. [% thing.op(); %] ). Template operations return a value, which must then be emitted to the main template using a dynamic output section. Thanks to Mark Tippetts for reporting this issue via the Epsilon forum .","title":"Common issues"},{"location":"doc/articles/egx-parameters/","text":"Co-ordinating EGL template execution with EGX \u00b6 Suppose you're using Epsilon to make a compiler for a domain-specific language (DSL). Specifically, for every Library in the DSL, you want to generate a separate XML file with all of the properties of the Library and its Books. With EGX, you can parameterize your EGL templates to achieve this, like so: pre { var outDirLib : String = \"../libraries/\"; var extension : String = \".xml\"; var specialBook : String = \"Art of War\"; var bigLibThreshold : Integer = 9000; } rule Libraries transform lib : Library { parameters : Map { \"library\" = lib, \"name\" = lib.name, \"books\" = lib.books, \"hasSpecialBook\" = lib.books.exists(book | book.title == specialBook), \"isBigLibrary\" = lib.books.size() > bigLibThreshold } template: \"/path/to/Lib2XML.egl\" target: outDirLib+lib.name+extension } In this example, the Lib2XML EGL template will be invoked for every Library instance in the model, and the output will be written to the file specified in the \"target\". The Lib2XML template will receive all of the parameters put in the \"params\" variable in the parameters block of the rule. The variable is a mapping from variable name (that the EGL template will use to refer to it) and variable value. For reference, the Lib2XML template is shown below. Note There is no limit on the number of rules you can declare in an EGX program. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library id=[%=lib.id%] name=\"[%=name%]\" isBigLibrary=\"[%=isBigLibrary.asString()%]\"> [% for (book in books) {%] <book> <title>[%=book.title%]</title> <isbn>[%=book.isbn%]</isbn> <pages>[%=book.pages.asString()%]</pages> <authors> [% for (author in book.authors) {%] <author name=\"[%=author.name%]\"/> [%}%] </authors> </book> [%}%] </library>","title":"Co-ordinating EGL template execution with EGX"},{"location":"doc/articles/egx-parameters/#co-ordinating-egl-template-execution-with-egx","text":"Suppose you're using Epsilon to make a compiler for a domain-specific language (DSL). Specifically, for every Library in the DSL, you want to generate a separate XML file with all of the properties of the Library and its Books. With EGX, you can parameterize your EGL templates to achieve this, like so: pre { var outDirLib : String = \"../libraries/\"; var extension : String = \".xml\"; var specialBook : String = \"Art of War\"; var bigLibThreshold : Integer = 9000; } rule Libraries transform lib : Library { parameters : Map { \"library\" = lib, \"name\" = lib.name, \"books\" = lib.books, \"hasSpecialBook\" = lib.books.exists(book | book.title == specialBook), \"isBigLibrary\" = lib.books.size() > bigLibThreshold } template: \"/path/to/Lib2XML.egl\" target: outDirLib+lib.name+extension } In this example, the Lib2XML EGL template will be invoked for every Library instance in the model, and the output will be written to the file specified in the \"target\". The Lib2XML template will receive all of the parameters put in the \"params\" variable in the parameters block of the rule. The variable is a mapping from variable name (that the EGL template will use to refer to it) and variable value. For reference, the Lib2XML template is shown below. Note There is no limit on the number of rules you can declare in an EGX program. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library id=[%=lib.id%] name=\"[%=name%]\" isBigLibrary=\"[%=isBigLibrary.asString()%]\"> [% for (book in books) {%] <book> <title>[%=book.title%]</title> <isbn>[%=book.isbn%]</isbn> <pages>[%=book.pages.asString()%]</pages> <authors> [% for (author in book.authors) {%] <author name=\"[%=author.name%]\"/> [%}%] </authors> </book> [%}%] </library>","title":"Co-ordinating EGL template execution with EGX"},{"location":"doc/articles/eol-interpreter-view/","text":"EOL Interpreter View \u00b6 Acceleo provides an extensible interpreter view that can be used to evaluate queries on selections of model elements in EMF-based editors. Epsilon extends this view with support for writing and running Epsilon Object Language scripts. To show the view, click on Window \u2192 Show View \u2192 Other \u2192 Interpreter , and to switch to EOL, click on the respective button at the top-right of the view. More detailed instructions on using the different facilities offered by the interpreter view (e.g. variables, live evaluation) are provided here . Info The EOL interpreter view is available in versions of Epsilon >= 2.3.0 Accessing Selected Model Elements and Variables \u00b6 Selected model elements in EMF-based editors can be accessed from the EOL script through the self variable. If multiple model elements are selected, then self will be a list containing all these elements, and if no model elements are selected, self will be null . Variables are accessible by name. Importing External Operations \u00b6 You can import operations defined in EOL files in your workspace using an import statement with a platform:/resource URI, as shown below. // bar() is defined in bar.eol under the bar project import \"platform:/resource/bar/bar.eol\"; return foo() + bar(); operation foo() { return \"foo\"; }","title":"EOL Interpreter View"},{"location":"doc/articles/eol-interpreter-view/#eol-interpreter-view","text":"Acceleo provides an extensible interpreter view that can be used to evaluate queries on selections of model elements in EMF-based editors. Epsilon extends this view with support for writing and running Epsilon Object Language scripts. To show the view, click on Window \u2192 Show View \u2192 Other \u2192 Interpreter , and to switch to EOL, click on the respective button at the top-right of the view. More detailed instructions on using the different facilities offered by the interpreter view (e.g. variables, live evaluation) are provided here . Info The EOL interpreter view is available in versions of Epsilon >= 2.3.0","title":"EOL Interpreter View"},{"location":"doc/articles/eol-interpreter-view/#accessing-selected-model-elements-and-variables","text":"Selected model elements in EMF-based editors can be accessed from the EOL script through the self variable. If multiple model elements are selected, then self will be a list containing all these elements, and if no model elements are selected, self will be null . Variables are accessible by name.","title":"Accessing Selected Model Elements and Variables"},{"location":"doc/articles/eol-interpreter-view/#importing-external-operations","text":"You can import operations defined in EOL files in your workspace using an import statement with a platform:/resource URI, as shown below. // bar() is defined in bar.eol under the bar project import \"platform:/resource/bar/bar.eol\"; return foo() + bar(); operation foo() { return \"foo\"; }","title":"Importing External Operations"},{"location":"doc/articles/eol-syntax-updates/","text":"EOL Syntax Updates \u00b6 The following is a brief description of changes to the Epsilon Object Language's syntax in each release. 2.2 \u00b6 Tuple type. Similar to a Map with String keys, but its properties can be accessed like a regular object (using the . operator). Assign if null operator ?= as convenient shorthand for a = a ?: b , that is: a = a <> null ? a : b . 2.1 \u00b6 Elvis operator as a convenient shorthand to use an alternative value if an expression is null. a ?: b is a concise way of writing a <> null ? a else b . Null-safe navigation operator to allow for easy chaining of feature calls without resorting to null checks. For example, null?.getClass()?.getName() will return null without crashing. != can be used as an alias for <> (i.e. \"not equals\"). 2.0 \u00b6 Ternary expressions, which can be used almost anywhere, not just in assignments or returns. Syntax and semantics are identical to Java, but you can also use the else keyword in place of the : if you prefer. Native lambda expressions. You can use first-order operation syntax or JavaScript-style => for invoking functional interfaces. Removed old-style OCL comments ( -* and -- ). -- can be used to decrement integers. Thread-safe collection types: ConcurrentBag , ConcurrentMap and ConcurrentSet . 1.4 \u00b6 Added support for postfix increment operator (i.e. i++ ) and for composite assignment statements (i.e. a +=1; a -= 2; a *= 3; a /= 4; ) 0.9.1 \u00b6 Added support for externally defined variables. Support for Map literal expressions (e.g. Map {key1 = value1, k2 = v2} ) 0.8.8 \u00b6 In 0.8.8 we extended the syntax of EOL so that it looks and feels a bit more like Java. As the majority of Eclipse/EMF audience are Java programmers, this will hopefully make their (and our) lives a bit easier. Of course, all these changes also affect all languages built on top of EOL. More specifically, we have introduced: double quotes ( \" \" ) for string literals, backticks (` `) for reserved words, Java-like comments ( // and /**/ ), == as a comparison operator, = as an assignment operator (in 0.8.7) All these changes (except for the double quotes which have now been replaced by ` `) are non-breaking: the old syntax ( '' for strings, = for comparison and := for assignment still work). Below is an example demonstrating the new syntax: /* This is a multi line comment */ // This is a single line comment var i = 1; if (i == 1) { \"Hello World\".println(); } i = 2; // Assigns the value 2 to i var `variable with spaces` = 3; `variable with spaces`.println(); // Prints 3 If you have suggestions for further Java-ifications of the EOL syntax, please post your comments to the Epsilon forum or add them to bug 292403 .","title":"EOL Syntax Updates"},{"location":"doc/articles/eol-syntax-updates/#eol-syntax-updates","text":"The following is a brief description of changes to the Epsilon Object Language's syntax in each release.","title":"EOL Syntax Updates"},{"location":"doc/articles/eol-syntax-updates/#22","text":"Tuple type. Similar to a Map with String keys, but its properties can be accessed like a regular object (using the . operator). Assign if null operator ?= as convenient shorthand for a = a ?: b , that is: a = a <> null ? a : b .","title":"2.2"},{"location":"doc/articles/eol-syntax-updates/#21","text":"Elvis operator as a convenient shorthand to use an alternative value if an expression is null. a ?: b is a concise way of writing a <> null ? a else b . Null-safe navigation operator to allow for easy chaining of feature calls without resorting to null checks. For example, null?.getClass()?.getName() will return null without crashing. != can be used as an alias for <> (i.e. \"not equals\").","title":"2.1"},{"location":"doc/articles/eol-syntax-updates/#20","text":"Ternary expressions, which can be used almost anywhere, not just in assignments or returns. Syntax and semantics are identical to Java, but you can also use the else keyword in place of the : if you prefer. Native lambda expressions. You can use first-order operation syntax or JavaScript-style => for invoking functional interfaces. Removed old-style OCL comments ( -* and -- ). -- can be used to decrement integers. Thread-safe collection types: ConcurrentBag , ConcurrentMap and ConcurrentSet .","title":"2.0"},{"location":"doc/articles/eol-syntax-updates/#14","text":"Added support for postfix increment operator (i.e. i++ ) and for composite assignment statements (i.e. a +=1; a -= 2; a *= 3; a /= 4; )","title":"1.4"},{"location":"doc/articles/eol-syntax-updates/#091","text":"Added support for externally defined variables. Support for Map literal expressions (e.g. Map {key1 = value1, k2 = v2} )","title":"0.9.1"},{"location":"doc/articles/eol-syntax-updates/#088","text":"In 0.8.8 we extended the syntax of EOL so that it looks and feels a bit more like Java. As the majority of Eclipse/EMF audience are Java programmers, this will hopefully make their (and our) lives a bit easier. Of course, all these changes also affect all languages built on top of EOL. More specifically, we have introduced: double quotes ( \" \" ) for string literals, backticks (` `) for reserved words, Java-like comments ( // and /**/ ), == as a comparison operator, = as an assignment operator (in 0.8.7) All these changes (except for the double quotes which have now been replaced by ` `) are non-breaking: the old syntax ( '' for strings, = for comparison and := for assignment still work). Below is an example demonstrating the new syntax: /* This is a multi line comment */ // This is a single line comment var i = 1; if (i == 1) { \"Hello World\".println(); } i = 2; // Assigns the value 2 to i var `variable with spaces` = 3; `variable with spaces`.println(); // Prints 3 If you have suggestions for further Java-ifications of the EOL syntax, please post your comments to the Epsilon forum or add them to bug 292403 .","title":"0.8.8"},{"location":"doc/articles/epackage-registry-view/","text":"The EMF EPackage Registry View \u00b6 The EPackage registry ( EPackage.Registry.INSTANCE ) contains references to all registered Ecore EPackages in EMF. To visualise the contents of the registry, we have implemented the following EPackage Registry view. Using this view, one can browse through the EClasses contained in each registered EPackage, discover the super/sub types of each EClass, and navigate through its features and operations. The view provides options to show/hide derived features, operations, inherited features and opposite references, supports quick navigation from a feature to its type (double-click), and integrates with the Properties view. To make this view visible go to Window \u2192 Show view \u2192 Other... and select EPackage Registry under the Epsilon category. The view is populated and refreshed on demand. As such, when it first appears it is empty. To populate it with the registered EPackages, you need to click the Refresh button on the top right.","title":"The EMF EPackage Registry View"},{"location":"doc/articles/epackage-registry-view/#the-emf-epackage-registry-view","text":"The EPackage registry ( EPackage.Registry.INSTANCE ) contains references to all registered Ecore EPackages in EMF. To visualise the contents of the registry, we have implemented the following EPackage Registry view. Using this view, one can browse through the EClasses contained in each registered EPackage, discover the super/sub types of each EClass, and navigate through its features and operations. The view provides options to show/hide derived features, operations, inherited features and opposite references, supports quick navigation from a feature to its type (double-click), and integrates with the Properties view. To make this view visible go to Window \u2192 Show view \u2192 Other... and select EPackage Registry under the Epsilon category. The view is populated and refreshed on demand. As such, when it first appears it is empty. To populate it with the registered EPackages, you need to click the Refresh button on the top right.","title":"The EMF EPackage Registry View"},{"location":"doc/articles/epsilon-1.x/","text":"Working with versions of Epsilon prior to 2.0 \u00b6 In the old days before we embraced advancements in Eclipse provisioning technology (P2), to use Epsilon one needed to download an Eclipse distribution and manually install the pre-requisite plugins and features required to work with Epsilon. Pre-packaged distributions \u00b6 If you wish to use an older version of Epsilon, the easiest and most compatible way is to download one of the ready-made distributions bundled from the archives , since they contain the selected version of Epsilon all its mandatory and optional dependencies. You will only need a Java Runtime Environment . Navigate to the directory with the desired version, and download the archive file appropriate for your platform and unzip it. If you are using Windows, please extract the download close to the root of a drive (e.g. C:) as the maximum path length on Windows may not exceed 255 characters by default. From a Modeling Distribution \u00b6 For a more up-to-date IDE, we recommend that users install the Eclipse Modeling Tools distribution and install Epsilon along with its (optional) dependencies (these are mainly for working with Eugenia) by adding the following list of update sites through Help \u2192 Install New Software... : Epsilon : https://download.eclipse.org/epsilon/updates/1.5 (substitute 1.5 for the desired version) Emfatic : https://download.eclipse.org/emfatic/update GMF Tooling : https://download.eclipse.org/modeling/gmp/gmf-tooling/updates/releases QVTo : https://download.eclipse.org/mmt/qvto/updates/releases/3.9.1","title":"Working with versions of Epsilon prior to 2.0"},{"location":"doc/articles/epsilon-1.x/#working-with-versions-of-epsilon-prior-to-20","text":"In the old days before we embraced advancements in Eclipse provisioning technology (P2), to use Epsilon one needed to download an Eclipse distribution and manually install the pre-requisite plugins and features required to work with Epsilon.","title":"Working with versions of Epsilon prior to 2.0"},{"location":"doc/articles/epsilon-1.x/#pre-packaged-distributions","text":"If you wish to use an older version of Epsilon, the easiest and most compatible way is to download one of the ready-made distributions bundled from the archives , since they contain the selected version of Epsilon all its mandatory and optional dependencies. You will only need a Java Runtime Environment . Navigate to the directory with the desired version, and download the archive file appropriate for your platform and unzip it. If you are using Windows, please extract the download close to the root of a drive (e.g. C:) as the maximum path length on Windows may not exceed 255 characters by default.","title":"Pre-packaged distributions"},{"location":"doc/articles/epsilon-1.x/#from-a-modeling-distribution","text":"For a more up-to-date IDE, we recommend that users install the Eclipse Modeling Tools distribution and install Epsilon along with its (optional) dependencies (these are mainly for working with Eugenia) by adding the following list of update sites through Help \u2192 Install New Software... : Epsilon : https://download.eclipse.org/epsilon/updates/1.5 (substitute 1.5 for the desired version) Emfatic : https://download.eclipse.org/emfatic/update GMF Tooling : https://download.eclipse.org/modeling/gmp/gmf-tooling/updates/releases QVTo : https://download.eclipse.org/mmt/qvto/updates/releases/3.9.1","title":"From a Modeling Distribution"},{"location":"doc/articles/epsilon-emf/","text":"Epsilon and EMF \u00b6 Below are some frequently-asked questions related to querying and modifying EMF-based models with Epsilon. What is the difference between containment and non-containment references in EMF? \u00b6 Briefly, a model element can belong to as most one containment reference at a time. Containment references also demonstrate a cascade-delete behaviour. For example, consider the following Ecore metamodel (captured in Emfatic). package cars; class Person { ref Person[*] friends; //non-containment reference val Car[*] cars; // containment reference } class Car { } Now consider the following EOL code which demonstrates the similarities/differences of containment and non-containment references. // Set up a few model elements to play with var c1 = new Car; var c2 = new Car; var p1 = new Person; var p2 = new Person; var p3 = new Person; // p1's car is c1 and p2's car is c2 p1.cars.add(c1); p2.cars.add(c2); // p3 is a friend of both p1 and p2 p1.friends.add(p3); p2.friends.add(p3); p1.friends.println(); // prints {p3} p2.friends.println(); // prints {p3} //add c2 to p1's cars p1.cars.add(c2); p1.cars.println(); // prints {c1, c2} // The following statement prints an empty set! // As discussed above, model elements can belong to at // most 1 containment reference. As such, by adding c2 to // the cars of p1, EMF removes it from the cars of p2 p2.cars.println(); // Delete p1 from the model delete p1; Person.all.println(); // prints {p2, p3} // The following statement prints an empty set! // As discussed above, containment references demonstrate // a cascade-delete behaviour. As such, when we deleted p1, // all the model elements contained in its cars containment reference // were also deleted from the model. Note how the friends of p1 (p2 and p3) // were not deleted from the model, since they were referenced through a // non-containment reference (friends) Car.all.println(); How can I get all children of a model element? \u00b6 Epsilon does not provide a built-in method for this but you can use EObject's eContents() method if you're working with EMF. To get all descendants of an element, something like the following should do the trick: o.asSequence().closure(x | x.eContents()) . See https://www.eclipse.org/forums/index.php/t/855628/ for more details. How can I get the container of a model element? \u00b6 Epsilon does not provide a built-in method for this but you can use EObject's eContainer() method if you're working with EMF. How can I use an existing EMF Resource in Epsilon? \u00b6 To use an existing EMF Resource in your Epsilon program, you should wrap it as an InMemoryEmfModel first. How can I access the EMF Resource that underpins an EMF model? \u00b6 You can use the getResource() method of AbstractEmfModel for this. How can I use custom load/save options for my EMF model? \u00b6 You need to un-tick the \"Read on load\"/\"Store on disposal\" options in your model configuration dialog and use the underlying EMF resource's load/save methods directly from your EOL code. For example, to turn off the OPTION_DEFER_IDREF_RESOLUTION option, which is on by default in Epsilon's EMF driver and has been reported to slow down loading of models that use \"id\" attributes , you can use the following EOL statement. M . resource . load ( Map { \"DEFER_IDREF_RESOLUTION\" = false }); How do I load an Ecore metamodel? \u00b6 If you're developing a standalone application, before you can load an EMF model, you will need to put its metamodel ( EPackage ) in the global EMF EPackage registry, or in the local package registry of the model resource. The following snippet shows how you can parse an Ecore metamodel from a file ( my.ecore ) and put its root EPackage in the global EMF registry. // Parse the metamodel file into an EMF resource ResourceSet ecoreResourceSet = new ResourceSetImpl (); ecoreResourceSet . getResourceFactoryRegistry (). getExtensionToFactoryMap (). put ( \"ecore\" , new XMIResourceFactoryImpl ()); ecoreResourceSet . getPackageRegistry (). put ( EcorePackage . eINSTANCE . getNsURI (), EcorePackage . eINSTANCE ); Resource ecoreResource = ecoreResourceSet . createResource ( URI . createFileURI ( new File ( \"my.ecore\" ). getAbsolutePath ())); ecoreResource . load ( null ); // Ecore files usually contain one EPackage EPackage ePackage = ( EPackage ) ecoreResource . getContents (). get ( 0 ); // Put the EPackage in the global EMF EPackage registry EPackage . Registry . INSTANCE . put ( ePackage . getNsURI (), ePackage );","title":"Epsilon and EMF"},{"location":"doc/articles/epsilon-emf/#epsilon-and-emf","text":"Below are some frequently-asked questions related to querying and modifying EMF-based models with Epsilon.","title":"Epsilon and EMF"},{"location":"doc/articles/epsilon-emf/#what-is-the-difference-between-containment-and-non-containment-references-in-emf","text":"Briefly, a model element can belong to as most one containment reference at a time. Containment references also demonstrate a cascade-delete behaviour. For example, consider the following Ecore metamodel (captured in Emfatic). package cars; class Person { ref Person[*] friends; //non-containment reference val Car[*] cars; // containment reference } class Car { } Now consider the following EOL code which demonstrates the similarities/differences of containment and non-containment references. // Set up a few model elements to play with var c1 = new Car; var c2 = new Car; var p1 = new Person; var p2 = new Person; var p3 = new Person; // p1's car is c1 and p2's car is c2 p1.cars.add(c1); p2.cars.add(c2); // p3 is a friend of both p1 and p2 p1.friends.add(p3); p2.friends.add(p3); p1.friends.println(); // prints {p3} p2.friends.println(); // prints {p3} //add c2 to p1's cars p1.cars.add(c2); p1.cars.println(); // prints {c1, c2} // The following statement prints an empty set! // As discussed above, model elements can belong to at // most 1 containment reference. As such, by adding c2 to // the cars of p1, EMF removes it from the cars of p2 p2.cars.println(); // Delete p1 from the model delete p1; Person.all.println(); // prints {p2, p3} // The following statement prints an empty set! // As discussed above, containment references demonstrate // a cascade-delete behaviour. As such, when we deleted p1, // all the model elements contained in its cars containment reference // were also deleted from the model. Note how the friends of p1 (p2 and p3) // were not deleted from the model, since they were referenced through a // non-containment reference (friends) Car.all.println();","title":"What is the difference between containment and non-containment references in EMF?"},{"location":"doc/articles/epsilon-emf/#how-can-i-get-all-children-of-a-model-element","text":"Epsilon does not provide a built-in method for this but you can use EObject's eContents() method if you're working with EMF. To get all descendants of an element, something like the following should do the trick: o.asSequence().closure(x | x.eContents()) . See https://www.eclipse.org/forums/index.php/t/855628/ for more details.","title":"How can I get all children of a model element?"},{"location":"doc/articles/epsilon-emf/#how-can-i-get-the-container-of-a-model-element","text":"Epsilon does not provide a built-in method for this but you can use EObject's eContainer() method if you're working with EMF.","title":"How can I get the container of a model element?"},{"location":"doc/articles/epsilon-emf/#how-can-i-use-an-existing-emf-resource-in-epsilon","text":"To use an existing EMF Resource in your Epsilon program, you should wrap it as an InMemoryEmfModel first.","title":"How can I use an existing EMF Resource in Epsilon?"},{"location":"doc/articles/epsilon-emf/#how-can-i-access-the-emf-resource-that-underpins-an-emf-model","text":"You can use the getResource() method of AbstractEmfModel for this.","title":"How can I access the EMF Resource that underpins an EMF model?"},{"location":"doc/articles/epsilon-emf/#how-can-i-use-custom-loadsave-options-for-my-emf-model","text":"You need to un-tick the \"Read on load\"/\"Store on disposal\" options in your model configuration dialog and use the underlying EMF resource's load/save methods directly from your EOL code. For example, to turn off the OPTION_DEFER_IDREF_RESOLUTION option, which is on by default in Epsilon's EMF driver and has been reported to slow down loading of models that use \"id\" attributes , you can use the following EOL statement. M . resource . load ( Map { \"DEFER_IDREF_RESOLUTION\" = false });","title":"How can I use custom load/save options for my EMF model?"},{"location":"doc/articles/epsilon-emf/#how-do-i-load-an-ecore-metamodel","text":"If you're developing a standalone application, before you can load an EMF model, you will need to put its metamodel ( EPackage ) in the global EMF EPackage registry, or in the local package registry of the model resource. The following snippet shows how you can parse an Ecore metamodel from a file ( my.ecore ) and put its root EPackage in the global EMF registry. // Parse the metamodel file into an EMF resource ResourceSet ecoreResourceSet = new ResourceSetImpl (); ecoreResourceSet . getResourceFactoryRegistry (). getExtensionToFactoryMap (). put ( \"ecore\" , new XMIResourceFactoryImpl ()); ecoreResourceSet . getPackageRegistry (). put ( EcorePackage . eINSTANCE . getNsURI (), EcorePackage . eINSTANCE ); Resource ecoreResource = ecoreResourceSet . createResource ( URI . createFileURI ( new File ( \"my.ecore\" ). getAbsolutePath ())); ecoreResource . load ( null ); // Ecore files usually contain one EPackage EPackage ePackage = ( EPackage ) ecoreResource . getContents (). get ( 0 ); // Put the EPackage in the global EMF EPackage registry EPackage . Registry . INSTANCE . put ( ePackage . getNsURI (), ePackage );","title":"How do I load an Ecore metamodel?"},{"location":"doc/articles/eugenia-affixed-nodes/","text":"Eugenia: Affixed Nodes in GMF \u00b6 From the following annotated Ecore metamodel (in Emfatic) @namespace(uri=\"components\", prefix=\"components\") package components; @gmf.diagram class ComponentDiagram { val Component[*] components; val Connector[*] connectors; } abstract class NamedElement { attr String name; } @gmf.node(label=\"name\") class Component extends NamedElement { @gmf.affixed val Port[*] ports; } @gmf.node(figure=\"rectangle\", size=\"20,20\", label=\"name\", label.placement=\"external\", label.icon=\"false\") class Port extends NamedElement { } @gmf.link(source=\"source\", target=\"target\", label=\"name\", target.decoration=\"arrow\") class Connector extends NamedElement { ref Port source; ref Port target; } Eugenia can automatically generate this GMF editor:","title":"Eugenia: Affixed Nodes in GMF"},{"location":"doc/articles/eugenia-affixed-nodes/#eugenia-affixed-nodes-in-gmf","text":"From the following annotated Ecore metamodel (in Emfatic) @namespace(uri=\"components\", prefix=\"components\") package components; @gmf.diagram class ComponentDiagram { val Component[*] components; val Connector[*] connectors; } abstract class NamedElement { attr String name; } @gmf.node(label=\"name\") class Component extends NamedElement { @gmf.affixed val Port[*] ports; } @gmf.node(figure=\"rectangle\", size=\"20,20\", label=\"name\", label.placement=\"external\", label.icon=\"false\") class Port extends NamedElement { } @gmf.link(source=\"source\", target=\"target\", label=\"name\", target.decoration=\"arrow\") class Connector extends NamedElement { ref Port source; ref Port target; } Eugenia can automatically generate this GMF editor:","title":"Eugenia: Affixed Nodes in GMF"},{"location":"doc/articles/eugenia-ant/","text":"Eugenia: Automated Invocation with Ant \u00b6 Eugenia can be called from Ant, using the <epsilon.eugenia> Ant task. This way, the creation of the GMF editors can be easily automated by using a standard Ant Builder. Additionally, the Ant task has several features which are not currently available through the regular graphical user interface. In this article, we will show how to invoke the Eugenia Ant task and offer some recommendations on how to adopt it. Basic usage \u00b6 The Eugenia Ant task only requires specifying the source Emfatic description or Ecore model through the src attribute: <!-- Generate myfile.ecore from myfile.emf and then proceed --> <epsilon.eugenia src= \"myfile.emf\" /> <!-- Start directly from the Ecore model --> <epsilon.eugenia src= \"myfile.ecore\" /> Warning The Eugenia Ant task requires that the Ant buildfile is run from the same JRE as the workspace. Please check the Workflow documentation for instructions on how to do it. Limiting the steps to be run \u00b6 Normally, Eugenia runs all these steps: Clean the models from the previous run (the clean step) If src is an Emfatic source file (with the .emf extension), generate the Ecore model from it ( ecore ) Generate the EMF GenModel from the Ecore model and polish it with Ecore2GenModel.eol if available ( genmodel ) Generate the GmfGraph, GmfTool and GmfMap models and polish them with Ecore2GMF.eol if available ( gmf ) Generate the GmfGen model and polish it with FixGMFGen.eol if available ( gmfgen ) Generate the EMF code from the EMF GenModel model ( emfcode ) Generate the GMF code from the GMFGen model ( gmfcode ) Optionally, the Ant task can run only some of these steps. The firstStep attribute can be used to specify the first step to be run, and the lastStep can be used to specify the last step to be run. For example: <!-- Skips the clean, ecore and genmodel steps --> <epsilon.eugenia src= \"myfile.ecore\" firstStep= \"gmf\" /> <!-- Does not run the emfcode and gmfcode steps --> <epsilon.eugenia src= \"myfile.emf\" lastStep= \"gmfgen\" /> <!-- Only runs the gmf and gmfgen steps --> <epsilon.eugenia src= \"myfile.ecore\" firstStep= \"gmf\" lastStep= \"gmfgen\" /> Using extra models for polishing \u00b6 Additional models to be used in a polishing transformation can be specified through the <model> nested element. <model> has three attributes: ref (mandatory) is the name with which the model was loaded into the model repository of the Ant project, using the Epsilon model loading Ant tasks. as (optional) is the name to be used for the model inside the polishing transformation. step (mandatory) is the identifier of the Eugenia step to which we will add the model reference. As an example, consider the following fragment: <epsilon.emf.loadModel name= \"Labels\" modelfile= \"my.model\" metamodeluri= \"mymetamodelURI\" read= \"true\" store= \"false\" /> <epsilon.eugenia src= \"myfile.emf\" > <model ref= \"Labels\" step= \"gmf\" /> </epsilon.eugenia> This example will make the Labels model available to the Ecore2GMF.eol polishing transformation, which is part of the gmf step.","title":"Eugenia: Automated Invocation with Ant"},{"location":"doc/articles/eugenia-ant/#eugenia-automated-invocation-with-ant","text":"Eugenia can be called from Ant, using the <epsilon.eugenia> Ant task. This way, the creation of the GMF editors can be easily automated by using a standard Ant Builder. Additionally, the Ant task has several features which are not currently available through the regular graphical user interface. In this article, we will show how to invoke the Eugenia Ant task and offer some recommendations on how to adopt it.","title":"Eugenia: Automated Invocation with Ant"},{"location":"doc/articles/eugenia-ant/#basic-usage","text":"The Eugenia Ant task only requires specifying the source Emfatic description or Ecore model through the src attribute: <!-- Generate myfile.ecore from myfile.emf and then proceed --> <epsilon.eugenia src= \"myfile.emf\" /> <!-- Start directly from the Ecore model --> <epsilon.eugenia src= \"myfile.ecore\" /> Warning The Eugenia Ant task requires that the Ant buildfile is run from the same JRE as the workspace. Please check the Workflow documentation for instructions on how to do it.","title":"Basic usage"},{"location":"doc/articles/eugenia-ant/#limiting-the-steps-to-be-run","text":"Normally, Eugenia runs all these steps: Clean the models from the previous run (the clean step) If src is an Emfatic source file (with the .emf extension), generate the Ecore model from it ( ecore ) Generate the EMF GenModel from the Ecore model and polish it with Ecore2GenModel.eol if available ( genmodel ) Generate the GmfGraph, GmfTool and GmfMap models and polish them with Ecore2GMF.eol if available ( gmf ) Generate the GmfGen model and polish it with FixGMFGen.eol if available ( gmfgen ) Generate the EMF code from the EMF GenModel model ( emfcode ) Generate the GMF code from the GMFGen model ( gmfcode ) Optionally, the Ant task can run only some of these steps. The firstStep attribute can be used to specify the first step to be run, and the lastStep can be used to specify the last step to be run. For example: <!-- Skips the clean, ecore and genmodel steps --> <epsilon.eugenia src= \"myfile.ecore\" firstStep= \"gmf\" /> <!-- Does not run the emfcode and gmfcode steps --> <epsilon.eugenia src= \"myfile.emf\" lastStep= \"gmfgen\" /> <!-- Only runs the gmf and gmfgen steps --> <epsilon.eugenia src= \"myfile.ecore\" firstStep= \"gmf\" lastStep= \"gmfgen\" />","title":"Limiting the steps to be run"},{"location":"doc/articles/eugenia-ant/#using-extra-models-for-polishing","text":"Additional models to be used in a polishing transformation can be specified through the <model> nested element. <model> has three attributes: ref (mandatory) is the name with which the model was loaded into the model repository of the Ant project, using the Epsilon model loading Ant tasks. as (optional) is the name to be used for the model inside the polishing transformation. step (mandatory) is the identifier of the Eugenia step to which we will add the model reference. As an example, consider the following fragment: <epsilon.emf.loadModel name= \"Labels\" modelfile= \"my.model\" metamodeluri= \"mymetamodelURI\" read= \"true\" store= \"false\" /> <epsilon.eugenia src= \"myfile.emf\" > <model ref= \"Labels\" step= \"gmf\" /> </epsilon.eugenia> This example will make the Labels model available to the Ecore2GMF.eol polishing transformation, which is part of the gmf step.","title":"Using extra models for polishing"},{"location":"doc/articles/eugenia-nodes-with-centred-layout/","text":"Eugenia: Nodes with centred content \u00b6 This recipe shows how to create nodes in your GMF editor whose contents are centred both horizontally and vertically. The resulting editor will produce nodes like this: We'll start with the following metamodel and Eugenia annotations: @namespace(uri=\"www.eclipse.org/epsilon/examples/widgets\", prefix=\"w\") package widgets; @gmf.diagram class System { val Widget[*] widgets; } @gmf.node(label=\"name\", label.icon=\"false\") class Widget { attr String[1] name; } In this case, we only have one child node (the label for the node). We need to add a polishing transformation to our project (described in more detail in this article ) to use a grid layout and specify the appropriate layout data for the label. In a file named ECore2GMF.eol, place the following code: var shape = findShape('WidgetFigure'); shape.layout = new GmfGraph!GridLayout; var label = shape.children.first; label.layoutData = new GmfGraph!GridLayoutData; label.layoutData.grabExcessVerticalSpace = true; label.layoutData.grabExcessHorizontalSpace = true; operation findShape(name : String) { return GmfGraph!Shape.all.selectOne(s|s.name = name); } If we have multiple child nodes, we may want to use a custom layout manager instead to achieve the centring. The polishing transformation will have to add the custom layout to our widget figure, and the ECcore2GMF.eol file will now look like this: findShape('WidgetFigure').layout = createCentredLayout(); operation findShape(name : String) { return GmfGraph!Shape.all.selectOne(s|s.name = name); } operation createCentredLayout() : GmfGraph!CustomLayout { var layout = new GmfGraph!CustomLayout; layout.qualifiedClassName = 'widgets.custom.layouts.CentredLayout'; return layout; } Notice that the layout specifies a qualified class name of widgets.custom.layouts.CentredLayout . We must create a class with that name, which implements the LayoutManager of draw2d. We'll use this exemplar implementation of widgets.custom.layouts.CentredLayout and place it in a widgets.custom plug-in project. We must add a dependency for the widgets.custom plugin project to the widgets.diagram project generated by GMF. For more details, please check the org.eclipse.epsilon.eugenia.examples.centred example projects at the Epsilon Git repository.","title":"Eugenia: Nodes with centred content"},{"location":"doc/articles/eugenia-nodes-with-centred-layout/#eugenia-nodes-with-centred-content","text":"This recipe shows how to create nodes in your GMF editor whose contents are centred both horizontally and vertically. The resulting editor will produce nodes like this: We'll start with the following metamodel and Eugenia annotations: @namespace(uri=\"www.eclipse.org/epsilon/examples/widgets\", prefix=\"w\") package widgets; @gmf.diagram class System { val Widget[*] widgets; } @gmf.node(label=\"name\", label.icon=\"false\") class Widget { attr String[1] name; } In this case, we only have one child node (the label for the node). We need to add a polishing transformation to our project (described in more detail in this article ) to use a grid layout and specify the appropriate layout data for the label. In a file named ECore2GMF.eol, place the following code: var shape = findShape('WidgetFigure'); shape.layout = new GmfGraph!GridLayout; var label = shape.children.first; label.layoutData = new GmfGraph!GridLayoutData; label.layoutData.grabExcessVerticalSpace = true; label.layoutData.grabExcessHorizontalSpace = true; operation findShape(name : String) { return GmfGraph!Shape.all.selectOne(s|s.name = name); } If we have multiple child nodes, we may want to use a custom layout manager instead to achieve the centring. The polishing transformation will have to add the custom layout to our widget figure, and the ECcore2GMF.eol file will now look like this: findShape('WidgetFigure').layout = createCentredLayout(); operation findShape(name : String) { return GmfGraph!Shape.all.selectOne(s|s.name = name); } operation createCentredLayout() : GmfGraph!CustomLayout { var layout = new GmfGraph!CustomLayout; layout.qualifiedClassName = 'widgets.custom.layouts.CentredLayout'; return layout; } Notice that the layout specifies a qualified class name of widgets.custom.layouts.CentredLayout . We must create a class with that name, which implements the LayoutManager of draw2d. We'll use this exemplar implementation of widgets.custom.layouts.CentredLayout and place it in a widgets.custom plug-in project. We must add a dependency for the widgets.custom plugin project to the widgets.diagram project generated by GMF. For more details, please check the org.eclipse.epsilon.eugenia.examples.centred example projects at the Epsilon Git repository.","title":"Eugenia: Nodes with centred content"},{"location":"doc/articles/eugenia-nodes-with-images/","text":"Eugenia: Nodes with images instead of shapes \u00b6 This recipe shows how to create nodes in your GMF editor that are represented with images (png, jpg etc.) instead of the standard GMF shapes (rectangle, ellipse etc.). We'll use the simple friends metamodel as demonstration: @namespace(uri=\"friends\", prefix=\"\") package friends; @gmf.diagram class World { val Person[*] people; } @gmf.node(figure=\"figures.PersonFigure\", label.icon=\"false\", label=\"name\", label.placement=\"external\") class Person { attr String name; @gmf.link(width=\"2\", color=\"0,255,0\", source.decoration=\"arrow\", target.decoration=\"arrow\", style=\"dash\") ref Person[*] friendOf; @gmf.link(width=\"2\", color=\"255,0,0\", source.decoration=\"arrow\", target.decoration=\"arrow\", style=\"dash\") ref Person[*] enemyOf; } We define a custom figure for Person ( figure=\"figures.PersonFigure\" ) and also specify that the label should be placed externally to the node ( label.placement=\"external\" ). Once we have generated our diagram code we need to go and define the figure.PersonFigure class. An example of an png image-based implementation is available below: package figures ; import org.eclipse.draw2d.ImageFigure ; import activator.PluginActivator ; /** * @generated */ public class PersonFigure extends ImageFigure { public PersonFigure () { super ( PluginActivator . imageDescriptorFromPlugin ( PluginActivator . ID , \"images/Person.png\" ). createImage (), 0 ); } } The PluginActivator extends AbstractUIPlugin, which provides methods for loading images from within our plug-in: package activator ; import org.eclipse.core.runtime.Plugin ; import org.eclipse.ui.plugin.AbstractUIPlugin ; import org.osgi.framework.BundleContext ; public class PluginActivator extends AbstractUIPlugin { public static final String ID = \"friends.figures\" ; //$NON-NLS-1$ private static PluginActivator ourInstance ; public PluginActivator () {} public void start ( BundleContext context ) throws Exception { super . start ( context ); ourInstance = this ; } public void stop ( BundleContext context ) throws Exception { ourInstance = null ; super . stop ( context ); } public static PluginActivator getDefault () { return ourInstance ; } } The result looks like this: For more details, please check the full example .","title":"Eugenia: Nodes with images instead of shapes"},{"location":"doc/articles/eugenia-nodes-with-images/#eugenia-nodes-with-images-instead-of-shapes","text":"This recipe shows how to create nodes in your GMF editor that are represented with images (png, jpg etc.) instead of the standard GMF shapes (rectangle, ellipse etc.). We'll use the simple friends metamodel as demonstration: @namespace(uri=\"friends\", prefix=\"\") package friends; @gmf.diagram class World { val Person[*] people; } @gmf.node(figure=\"figures.PersonFigure\", label.icon=\"false\", label=\"name\", label.placement=\"external\") class Person { attr String name; @gmf.link(width=\"2\", color=\"0,255,0\", source.decoration=\"arrow\", target.decoration=\"arrow\", style=\"dash\") ref Person[*] friendOf; @gmf.link(width=\"2\", color=\"255,0,0\", source.decoration=\"arrow\", target.decoration=\"arrow\", style=\"dash\") ref Person[*] enemyOf; } We define a custom figure for Person ( figure=\"figures.PersonFigure\" ) and also specify that the label should be placed externally to the node ( label.placement=\"external\" ). Once we have generated our diagram code we need to go and define the figure.PersonFigure class. An example of an png image-based implementation is available below: package figures ; import org.eclipse.draw2d.ImageFigure ; import activator.PluginActivator ; /** * @generated */ public class PersonFigure extends ImageFigure { public PersonFigure () { super ( PluginActivator . imageDescriptorFromPlugin ( PluginActivator . ID , \"images/Person.png\" ). createImage (), 0 ); } } The PluginActivator extends AbstractUIPlugin, which provides methods for loading images from within our plug-in: package activator ; import org.eclipse.core.runtime.Plugin ; import org.eclipse.ui.plugin.AbstractUIPlugin ; import org.osgi.framework.BundleContext ; public class PluginActivator extends AbstractUIPlugin { public static final String ID = \"friends.figures\" ; //$NON-NLS-1$ private static PluginActivator ourInstance ; public PluginActivator () {} public void start ( BundleContext context ) throws Exception { super . start ( context ); ourInstance = this ; } public void stop ( BundleContext context ) throws Exception { ourInstance = null ; super . stop ( context ); } public static PluginActivator getDefault () { return ourInstance ; } } The result looks like this: For more details, please check the full example .","title":"Eugenia: Nodes with images instead of shapes"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/","text":"Eugenia: Nodes with images defined at run-time \u00b6 This recipe addresses the case where the end-user needs to set an image for each node at runtime (based on Thomas Beyer's solution presented in the GMF newsgroup). For our example, we'll use the Component class. Create an attribute to store the image path \u00b6 First we need to create an imagePath attribute that will store the path of the image for each component. Set the figure of Component to a custom ComponentFigure \u00b6 The next step is to set the figure of Component in Eugenia to a custom figure. After those two steps, our definition of Component looks like this: @gmf.node(label=\"name\", figure=\"ccdl.diagram.figures.ComponentFigure\", label.placement=\"external\") class Component { attr String name; attr String imagePath; } Once we generate the diagram code, we'll get an error because ComponentFigure has not been found. We need to create the ComponentFigure class and set its code to the following: import java.io.File ; import java.util.HashMap ; import org.eclipse.core.resources.IFile ; import org.eclipse.core.resources.ResourcesPlugin ; import org.eclipse.core.runtime.FileLocator ; import org.eclipse.core.runtime.Path ; import org.eclipse.core.runtime.Platform ; import org.eclipse.draw2d.ImageFigure ; import org.eclipse.jface.resource.ImageDescriptor ; import org.eclipse.swt.graphics.Image ; import ccdl.diagram.part.CcdlDiagramEditorPlugin ; public class ComponentFigure extends ImageFigure { static Image unspecified = null ; public ComponentFigure () { if ( unspecified == null ) { unspecified = ImageDescriptor . createFromURL ( FileLocator . find ( Platform . getBundle ( CcdlDiagramEditorPlugin . ID ), new Path ( \"icons/ComponentDefault.png\" ), new HashMap ())) . createImage (); } } public static Image createImage ( String imagePath ) { try { IFile res = ( IFile ) ResourcesPlugin . getWorkspace (). getRoot (). findMember ( new Path ( imagePath )); File file = new File ( res . getRawLocation (). toOSString ()); return ImageDescriptor . createFromURL ( file . toURI (). toURL ()). createImage (); } catch ( Exception ex ) { return unspecified ; } } public void setImagePath ( String imagePath ) { try { if ( getImage () != null && getImage () != unspecified ) { getImage (). dispose (); } this . setImage ( createImage ( imagePath )); } catch ( Exception ex ) { ex . printStackTrace (); } } } Create the image path property descriptor \u00b6 The next step is to create the property descriptor for the image path so that we can eventually get a nice browse button in the properties view. To do this we need to create a new class named ComponentImagePathPropertyDescriptor . import org.eclipse.emf.ecore.EAttribute ; import org.eclipse.emf.edit.provider.IItemPropertyDescriptor ; import org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor ; import org.eclipse.jface.viewers.CellEditor ; import org.eclipse.swt.widgets.Composite ; public class ComponentImagePathPropertyDescriptor extends EMFCompositeSourcePropertyDescriptor { public ComponentImagePathPropertyDescriptor ( Object object , IItemPropertyDescriptor itemPropertyDescriptor , String category ) { super ( object , itemPropertyDescriptor , category ); } protected CellEditor doCreateEditor ( Composite composite ) { try { if ((( EAttribute ) getFeature ()). getName (). equals ( \"imagePath\" )) { return new ComponentImagePathCellEditor ( composite ); } } catch ( Exception ex ){} return super . doCreateEditor ( composite ); } } Create the image path property cell editor \u00b6 import org.eclipse.core.resources.IFile ; import org.eclipse.core.resources.IResource ; import org.eclipse.core.resources.ResourcesPlugin ; import org.eclipse.jface.viewers.DialogCellEditor ; import org.eclipse.jface.window.Window ; import org.eclipse.swt.widgets.Composite ; import org.eclipse.swt.widgets.Control ; import org.eclipse.ui.dialogs.ResourceListSelectionDialog ; public class ComponentImagePathCellEditor extends DialogCellEditor { public ComponentImagePathCellEditor ( Composite parent ) { super ( parent ); } protected Object openDialogBox ( Control cellEditorWindow ) { ResourceListSelectionDialog elementSelector = new ResourceListSelectionDialog ( cellEditorWindow . getShell (), ResourcesPlugin . getWorkspace (). getRoot (), IResource . DEPTH_INFINITE | IResource . FILE ); elementSelector . setTitle ( \"Image\" ); elementSelector . setMessage ( \"Please select an image\" ); elementSelector . open (); if ( elementSelector . getReturnCode () == Window . OK ){ IFile f = ( IFile ) elementSelector . getResult () [ 0 ] ; return f . getFullPath (). toString (); } else { return null ; } } } Update the XXXPropertySection under xxx.diagram.sheet \u00b6 Update the getPropertySource method as follows: public IPropertySource getPropertySource ( Object object ) { if ( object instanceof IPropertySource ) { return ( IPropertySource ) object ; } AdapterFactory af = getAdapterFactory ( object ); if ( af != null ) { IItemPropertySource ips = ( IItemPropertySource ) af . adapt ( object , IItemPropertySource . class ); if ( ips != null ) { if ( object instanceof Component ) { return new PropertySource ( object , ips ) { protected IPropertyDescriptor createPropertyDescriptor ( IItemPropertyDescriptor itemPropertyDescriptor ) { EStructuralFeature feature = ( EStructuralFeature ) itemPropertyDescriptor . getFeature ( object ); if ( feature . getName (). equalsIgnoreCase ( \"imagePath\" )) { return new ComponentImagePathPropertyDescriptor ( object , itemPropertyDescriptor , \"Misc\" ); } else { return new EMFCompositeSourcePropertyDescriptor ( object , itemPropertyDescriptor , \"Misc\" ); } } }; } //return new PropertySource(object, ips); return new EMFCompositePropertySource ( object , ips , \"Misc\" ); } } if ( object instanceof IAdaptable ) { return ( IPropertySource ) (( IAdaptable ) object ) . getAdapter ( IPropertySource . class ); } return null ; } Modify the edit part \u00b6 Modify the handleNotificationEvent method so that the figure is updated every time the value of imagePath changes protected void handleNotificationEvent ( Notification event ) { if ( event . getNotifier () == getModel () && EcorePackage . eINSTANCE . getEModelElement_EAnnotations () . equals ( event . getFeature ())) { handleMajorSemanticChange (); } else { if ( event . getFeature () instanceof EAttribute ) { EAttribute eAttribute = ( EAttribute ) event . getFeature (); if ( eAttribute . getName (). equalsIgnoreCase ( \"imagePath\" )) { ComponentFigure figure = ( ComponentFigure ) this . getPrimaryShape (); figure . setImagePath ( event . getNewStringValue ()); } } super . handleNotificationEvent ( event ); } } Modify the createNodeShape method so that the figure is initialized from the existing imagePath the first time. protected IFigure createNodeShape () { primaryShape = new ComponentFigure (); Component component = ( Component ) (( Node ) getNotationView ()). getElement (); (( ComponentFigure ) primaryShape ). setImagePath ( component . getImagePath ()); return primaryShape ; }","title":"Eugenia: Nodes with images defined at run-time"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#eugenia-nodes-with-images-defined-at-run-time","text":"This recipe addresses the case where the end-user needs to set an image for each node at runtime (based on Thomas Beyer's solution presented in the GMF newsgroup). For our example, we'll use the Component class.","title":"Eugenia: Nodes with images defined at run-time"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#create-an-attribute-to-store-the-image-path","text":"First we need to create an imagePath attribute that will store the path of the image for each component.","title":"Create an attribute to store the image path"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#set-the-figure-of-component-to-a-custom-componentfigure","text":"The next step is to set the figure of Component in Eugenia to a custom figure. After those two steps, our definition of Component looks like this: @gmf.node(label=\"name\", figure=\"ccdl.diagram.figures.ComponentFigure\", label.placement=\"external\") class Component { attr String name; attr String imagePath; } Once we generate the diagram code, we'll get an error because ComponentFigure has not been found. We need to create the ComponentFigure class and set its code to the following: import java.io.File ; import java.util.HashMap ; import org.eclipse.core.resources.IFile ; import org.eclipse.core.resources.ResourcesPlugin ; import org.eclipse.core.runtime.FileLocator ; import org.eclipse.core.runtime.Path ; import org.eclipse.core.runtime.Platform ; import org.eclipse.draw2d.ImageFigure ; import org.eclipse.jface.resource.ImageDescriptor ; import org.eclipse.swt.graphics.Image ; import ccdl.diagram.part.CcdlDiagramEditorPlugin ; public class ComponentFigure extends ImageFigure { static Image unspecified = null ; public ComponentFigure () { if ( unspecified == null ) { unspecified = ImageDescriptor . createFromURL ( FileLocator . find ( Platform . getBundle ( CcdlDiagramEditorPlugin . ID ), new Path ( \"icons/ComponentDefault.png\" ), new HashMap ())) . createImage (); } } public static Image createImage ( String imagePath ) { try { IFile res = ( IFile ) ResourcesPlugin . getWorkspace (). getRoot (). findMember ( new Path ( imagePath )); File file = new File ( res . getRawLocation (). toOSString ()); return ImageDescriptor . createFromURL ( file . toURI (). toURL ()). createImage (); } catch ( Exception ex ) { return unspecified ; } } public void setImagePath ( String imagePath ) { try { if ( getImage () != null && getImage () != unspecified ) { getImage (). dispose (); } this . setImage ( createImage ( imagePath )); } catch ( Exception ex ) { ex . printStackTrace (); } } }","title":"Set the figure of Component to a custom ComponentFigure"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#create-the-image-path-property-descriptor","text":"The next step is to create the property descriptor for the image path so that we can eventually get a nice browse button in the properties view. To do this we need to create a new class named ComponentImagePathPropertyDescriptor . import org.eclipse.emf.ecore.EAttribute ; import org.eclipse.emf.edit.provider.IItemPropertyDescriptor ; import org.eclipse.gmf.runtime.emf.ui.properties.descriptors.EMFCompositeSourcePropertyDescriptor ; import org.eclipse.jface.viewers.CellEditor ; import org.eclipse.swt.widgets.Composite ; public class ComponentImagePathPropertyDescriptor extends EMFCompositeSourcePropertyDescriptor { public ComponentImagePathPropertyDescriptor ( Object object , IItemPropertyDescriptor itemPropertyDescriptor , String category ) { super ( object , itemPropertyDescriptor , category ); } protected CellEditor doCreateEditor ( Composite composite ) { try { if ((( EAttribute ) getFeature ()). getName (). equals ( \"imagePath\" )) { return new ComponentImagePathCellEditor ( composite ); } } catch ( Exception ex ){} return super . doCreateEditor ( composite ); } }","title":"Create the image path property descriptor"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#create-the-image-path-property-cell-editor","text":"import org.eclipse.core.resources.IFile ; import org.eclipse.core.resources.IResource ; import org.eclipse.core.resources.ResourcesPlugin ; import org.eclipse.jface.viewers.DialogCellEditor ; import org.eclipse.jface.window.Window ; import org.eclipse.swt.widgets.Composite ; import org.eclipse.swt.widgets.Control ; import org.eclipse.ui.dialogs.ResourceListSelectionDialog ; public class ComponentImagePathCellEditor extends DialogCellEditor { public ComponentImagePathCellEditor ( Composite parent ) { super ( parent ); } protected Object openDialogBox ( Control cellEditorWindow ) { ResourceListSelectionDialog elementSelector = new ResourceListSelectionDialog ( cellEditorWindow . getShell (), ResourcesPlugin . getWorkspace (). getRoot (), IResource . DEPTH_INFINITE | IResource . FILE ); elementSelector . setTitle ( \"Image\" ); elementSelector . setMessage ( \"Please select an image\" ); elementSelector . open (); if ( elementSelector . getReturnCode () == Window . OK ){ IFile f = ( IFile ) elementSelector . getResult () [ 0 ] ; return f . getFullPath (). toString (); } else { return null ; } } }","title":"Create the image path property cell editor"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#update-the-xxxpropertysection-under-xxxdiagramsheet","text":"Update the getPropertySource method as follows: public IPropertySource getPropertySource ( Object object ) { if ( object instanceof IPropertySource ) { return ( IPropertySource ) object ; } AdapterFactory af = getAdapterFactory ( object ); if ( af != null ) { IItemPropertySource ips = ( IItemPropertySource ) af . adapt ( object , IItemPropertySource . class ); if ( ips != null ) { if ( object instanceof Component ) { return new PropertySource ( object , ips ) { protected IPropertyDescriptor createPropertyDescriptor ( IItemPropertyDescriptor itemPropertyDescriptor ) { EStructuralFeature feature = ( EStructuralFeature ) itemPropertyDescriptor . getFeature ( object ); if ( feature . getName (). equalsIgnoreCase ( \"imagePath\" )) { return new ComponentImagePathPropertyDescriptor ( object , itemPropertyDescriptor , \"Misc\" ); } else { return new EMFCompositeSourcePropertyDescriptor ( object , itemPropertyDescriptor , \"Misc\" ); } } }; } //return new PropertySource(object, ips); return new EMFCompositePropertySource ( object , ips , \"Misc\" ); } } if ( object instanceof IAdaptable ) { return ( IPropertySource ) (( IAdaptable ) object ) . getAdapter ( IPropertySource . class ); } return null ; }","title":"Update the XXXPropertySection under xxx.diagram.sheet"},{"location":"doc/articles/eugenia-nodes-with-runtime-images/#modify-the-edit-part","text":"Modify the handleNotificationEvent method so that the figure is updated every time the value of imagePath changes protected void handleNotificationEvent ( Notification event ) { if ( event . getNotifier () == getModel () && EcorePackage . eINSTANCE . getEModelElement_EAnnotations () . equals ( event . getFeature ())) { handleMajorSemanticChange (); } else { if ( event . getFeature () instanceof EAttribute ) { EAttribute eAttribute = ( EAttribute ) event . getFeature (); if ( eAttribute . getName (). equalsIgnoreCase ( \"imagePath\" )) { ComponentFigure figure = ( ComponentFigure ) this . getPrimaryShape (); figure . setImagePath ( event . getNewStringValue ()); } } super . handleNotificationEvent ( event ); } } Modify the createNodeShape method so that the figure is initialized from the existing imagePath the first time. protected IFigure createNodeShape () { primaryShape = new ComponentFigure (); Component component = ( Component ) (( Node ) getNotationView ()). getElement (); (( ComponentFigure ) primaryShape ). setImagePath ( component . getImagePath ()); return primaryShape ; }","title":"Modify the edit part"},{"location":"doc/articles/eugenia-patching/","text":"Customizing the Java source code generated by Eugenia \u00b6 Occasionally, the Java source code generated by GMF to implement your graphical editor is not quite what you want, and it's not possible to polish the GMF models to incorporate your desired changes. Essentially, you'd like to change the code generation templates used by GMF. In this situation, you have two options. The first option is to use GMF dynamic templates , which requires some knowledge of Xpand (the code generation language used by GMF) and can often involve hunting around in the GMF code generator for the right place to make your changes. Alternatively, you can use Eugenia's patch generation and application functionality (described below). Running example \u00b6 The remainder of this article demonstrates how to customize the source code for a generated GMF editor to change the size of the margins used for external labels. As shown below, the patched version of the GMF editor positions labels closer to their nodes: Note that the models used by GMF to generate our editor don't provide a way to control the size of the margins, so we can't use a polishing transformation. Automatically patching the source code of a generated GMF editor \u00b6 After generating the GMF code for your editor, Eugenia will search for a patches directory in the same project as your Emfatic source. If the patches directory is found, Eugenia will apply to your workspace any .patch file found in that directory. Creating and applying patches with Eugenia \u00b6 Create .patch files using Eclipse's Team functionality: Make your desired changes to the generated Java source code by hand. Right-click the project containing your changes, and select Team\u2192Create Patch... Select Clipboard and click Finish Create a patches directory in the project containing your Emfatic source. Create a new file (e.g. patches/MyChanges.patch ), paste your patch into the new file and save it. The next time that you run EuGEnia, your .patch file will be automatically applied to the generated Java source code. You can also apply or remove all of your patches by right-clicking your patches directory and selecting Eugenia\u2192Apply patches or Eugenia\u2192Remove applied patches. In our running example, we devise the patch below to fix the margins of externally placed labels for the State model element type. We save the patch into patches/FixExternalLabelMarginsForState.patch diff --git org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java index d0684d6..f162365 100644 --- org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java +++ org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java @@ -143,7 +143,7 @@ if (borderItemEditPart instanceof StateNameEditPart) { BorderItemLocator locator = new BorderItemLocator(getMainFigure(), PositionConstants.SOUTH); - locator.setBorderItemOffset(new Dimension(-20, -20)); + locator.setBorderItemOffset(new Dimension(-5, -5)); borderItemContainer.add(borderItemEditPart.getFigure(), locator); } else { super.addBorderItem(borderItemContainer, borderItemEditPart); Generating patches with Eugenia \u00b6 It is possible to generate .patch files as part of the Eugenia code generation process. This allows you to include in .patch files information from your source metamodel, or from the GMF models generated by Eugenia. Generating .patch files is particularly useful when you want to apply the same type of change in several places in the Java source code for your GMF editor: Create a file named GeneratePatches.egx in the same directory as your Emfatic source code. In the GeneratePages.egx file, write a transformation rule for each element of the ECore or GMF models for which you want to generate a .patch file: Create one or more EGL templates for use by your GeneratePages.egx file. Each EGL template is essentially a parameterised .patch file. The next time that you run EuGEnia, your GeneratePatches.egx file will be automatically invoked to generate one or more .patch files, which will then be automatically applied to the generated Java source code. You can also test your GeneratePatches.egx file, by right-clicking it and selecting Eugenia\u2192Generate patches. In our running example, we can generalise our State patch (above) such that it is applied to any element in our metamodel that has an external label. First, we create a GeneratePatches.egx file that produces a .patch file for every EClass in our ECore file that is annotated with label.placement set to external : // Imports the EClass#getLabelPlacement() operation from Eugenia import \"platform:/plugin/org.eclipse.epsilon.eugenia/transformations/ECoreUtil.eol\"; rule FixExternalLabelMargins // apply this rule to all EClasses where... transform c : ECore!EClass { // ... the EClass is annotated with @gmf.node(label.placement=\"external\") guard: c.getLabelPlacement() == \"external\" // invoke the following EGL template on the EClass template : \"FixExternalLabelMargin.egl\" // make the source directory and name of the node available to the template parameters : Map{ \"srcDir\" = getSourceDirectory(), \"node\" = c.name } // and save the generated text to the following .patch file target : \"FixExternalLabelMarginsFor\" + c.name + \".patch\" } // Determine source directory from GMF Gen model @cache operation getSourceDirectory() { var genEditor = GmfGen!GenEditorGenerator.all.first; return genEditor.pluginDirectory.substring(1) + \"/\" + genEditor.packageNamePrefix.replace(\"\\\\.\", \"/\"); } We'll also need to provide a parameterised version of our State patch, saving it as an EGL template at FixExternalLabelMargin.egl : diff --git [%=srcDir%]/edit/parts/[%=node%]EditPart.java [%=srcDir%]/edit/parts/[%=node%]EditPart.java index d0684d6..f162365 100644 --- [%=srcDir%]/edit/parts/[%=node%]EditPart.java +++ [%=srcDir%]/edit/parts/[%=node%]EditPart.java @@ -143,7 +143,7 @@ if (borderItemEditPart instanceof [%=node%]NameEditPart) { BorderItemLocator locator = new BorderItemLocator(getMainFigure(), PositionConstants.SOUTH); - locator.setBorderItemOffset(new Dimension(-20, -20)); + locator.setBorderItemOffset(new Dimension(-5, -5)); borderItemContainer.add(borderItemEditPart.getFigure(), locator); } else { super.addBorderItem(borderItemContainer, borderItemEditPart); Note that the above template uses the srcDir and node variables made available by our EGX transformation rule. The next time that Eugenia is invoked, a .patch file is generated and applied for every EClass in our ECore file that has an externally-placed label: FAQ \u00b6 Should my patches produce @generated NOT annotations? \u00b6 No, because this can cause subsequent invocations of Eugenia and the GMF code generator to fail -- the GMF code generator will attempt to preserve code marked as @generated NOT and your .patch files will likely not apply cleanly to the code that has been preserved. The code that is applied via .patch files is generated code and should be treated as such. One or more of my patches couldn't be applied. What should I do? \u00b6 Firstly, check to ensure that Eclipse can apply your patch via the Team\u2192Apply patch... menu item. If not, you'll need to fix your .patch file. Secondly, ensure that the order in which your patches are being applied is not causing problems. By default Eugenia orders patches alphabetically by filename: a.patch will be applied before z.patch I'm using git-svn and my patch files can't be applied by Eugenia or by Eclipse's Team\u2192Apply patch... menu item. What should I do? \u00b6 You should edit the headers of any patch file generated by git-svn and remove the dummy a and b folders. For example:* diff --git a/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java b/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java index 65e2685..109b568 100644 --- a/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java +++ b/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java @@ -152,6 +152,8 @@ ... becomes: diff --git org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java index 65e2685..109b568 100644 --- org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java +++ org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java @@ -152,6 +152,8 @@ ...","title":"Customizing the Java source code generated by Eugenia"},{"location":"doc/articles/eugenia-patching/#customizing-the-java-source-code-generated-by-eugenia","text":"Occasionally, the Java source code generated by GMF to implement your graphical editor is not quite what you want, and it's not possible to polish the GMF models to incorporate your desired changes. Essentially, you'd like to change the code generation templates used by GMF. In this situation, you have two options. The first option is to use GMF dynamic templates , which requires some knowledge of Xpand (the code generation language used by GMF) and can often involve hunting around in the GMF code generator for the right place to make your changes. Alternatively, you can use Eugenia's patch generation and application functionality (described below).","title":"Customizing the Java source code generated by Eugenia"},{"location":"doc/articles/eugenia-patching/#running-example","text":"The remainder of this article demonstrates how to customize the source code for a generated GMF editor to change the size of the margins used for external labels. As shown below, the patched version of the GMF editor positions labels closer to their nodes: Note that the models used by GMF to generate our editor don't provide a way to control the size of the margins, so we can't use a polishing transformation.","title":"Running example"},{"location":"doc/articles/eugenia-patching/#automatically-patching-the-source-code-of-a-generated-gmf-editor","text":"After generating the GMF code for your editor, Eugenia will search for a patches directory in the same project as your Emfatic source. If the patches directory is found, Eugenia will apply to your workspace any .patch file found in that directory.","title":"Automatically patching the source code of a generated GMF editor"},{"location":"doc/articles/eugenia-patching/#creating-and-applying-patches-with-eugenia","text":"Create .patch files using Eclipse's Team functionality: Make your desired changes to the generated Java source code by hand. Right-click the project containing your changes, and select Team\u2192Create Patch... Select Clipboard and click Finish Create a patches directory in the project containing your Emfatic source. Create a new file (e.g. patches/MyChanges.patch ), paste your patch into the new file and save it. The next time that you run EuGEnia, your .patch file will be automatically applied to the generated Java source code. You can also apply or remove all of your patches by right-clicking your patches directory and selecting Eugenia\u2192Apply patches or Eugenia\u2192Remove applied patches. In our running example, we devise the patch below to fix the margins of externally placed labels for the State model element type. We save the patch into patches/FixExternalLabelMarginsForState.patch diff --git org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java index d0684d6..f162365 100644 --- org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java +++ org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/StateEditPart.java @@ -143,7 +143,7 @@ if (borderItemEditPart instanceof StateNameEditPart) { BorderItemLocator locator = new BorderItemLocator(getMainFigure(), PositionConstants.SOUTH); - locator.setBorderItemOffset(new Dimension(-20, -20)); + locator.setBorderItemOffset(new Dimension(-5, -5)); borderItemContainer.add(borderItemEditPart.getFigure(), locator); } else { super.addBorderItem(borderItemContainer, borderItemEditPart);","title":"Creating and applying patches with Eugenia"},{"location":"doc/articles/eugenia-patching/#generating-patches-with-eugenia","text":"It is possible to generate .patch files as part of the Eugenia code generation process. This allows you to include in .patch files information from your source metamodel, or from the GMF models generated by Eugenia. Generating .patch files is particularly useful when you want to apply the same type of change in several places in the Java source code for your GMF editor: Create a file named GeneratePatches.egx in the same directory as your Emfatic source code. In the GeneratePages.egx file, write a transformation rule for each element of the ECore or GMF models for which you want to generate a .patch file: Create one or more EGL templates for use by your GeneratePages.egx file. Each EGL template is essentially a parameterised .patch file. The next time that you run EuGEnia, your GeneratePatches.egx file will be automatically invoked to generate one or more .patch files, which will then be automatically applied to the generated Java source code. You can also test your GeneratePatches.egx file, by right-clicking it and selecting Eugenia\u2192Generate patches. In our running example, we can generalise our State patch (above) such that it is applied to any element in our metamodel that has an external label. First, we create a GeneratePatches.egx file that produces a .patch file for every EClass in our ECore file that is annotated with label.placement set to external : // Imports the EClass#getLabelPlacement() operation from Eugenia import \"platform:/plugin/org.eclipse.epsilon.eugenia/transformations/ECoreUtil.eol\"; rule FixExternalLabelMargins // apply this rule to all EClasses where... transform c : ECore!EClass { // ... the EClass is annotated with @gmf.node(label.placement=\"external\") guard: c.getLabelPlacement() == \"external\" // invoke the following EGL template on the EClass template : \"FixExternalLabelMargin.egl\" // make the source directory and name of the node available to the template parameters : Map{ \"srcDir\" = getSourceDirectory(), \"node\" = c.name } // and save the generated text to the following .patch file target : \"FixExternalLabelMarginsFor\" + c.name + \".patch\" } // Determine source directory from GMF Gen model @cache operation getSourceDirectory() { var genEditor = GmfGen!GenEditorGenerator.all.first; return genEditor.pluginDirectory.substring(1) + \"/\" + genEditor.packageNamePrefix.replace(\"\\\\.\", \"/\"); } We'll also need to provide a parameterised version of our State patch, saving it as an EGL template at FixExternalLabelMargin.egl : diff --git [%=srcDir%]/edit/parts/[%=node%]EditPart.java [%=srcDir%]/edit/parts/[%=node%]EditPart.java index d0684d6..f162365 100644 --- [%=srcDir%]/edit/parts/[%=node%]EditPart.java +++ [%=srcDir%]/edit/parts/[%=node%]EditPart.java @@ -143,7 +143,7 @@ if (borderItemEditPart instanceof [%=node%]NameEditPart) { BorderItemLocator locator = new BorderItemLocator(getMainFigure(), PositionConstants.SOUTH); - locator.setBorderItemOffset(new Dimension(-20, -20)); + locator.setBorderItemOffset(new Dimension(-5, -5)); borderItemContainer.add(borderItemEditPart.getFigure(), locator); } else { super.addBorderItem(borderItemContainer, borderItemEditPart); Note that the above template uses the srcDir and node variables made available by our EGX transformation rule. The next time that Eugenia is invoked, a .patch file is generated and applied for every EClass in our ECore file that has an externally-placed label:","title":"Generating patches with Eugenia"},{"location":"doc/articles/eugenia-patching/#faq","text":"","title":"FAQ"},{"location":"doc/articles/eugenia-patching/#should-my-patches-produce-generated-not-annotations","text":"No, because this can cause subsequent invocations of Eugenia and the GMF code generator to fail -- the GMF code generator will attempt to preserve code marked as @generated NOT and your .patch files will likely not apply cleanly to the code that has been preserved. The code that is applied via .patch files is generated code and should be treated as such.","title":"Should my patches produce @generated NOT annotations?"},{"location":"doc/articles/eugenia-patching/#one-or-more-of-my-patches-couldnt-be-applied-what-should-i-do","text":"Firstly, check to ensure that Eclipse can apply your patch via the Team\u2192Apply patch... menu item. If not, you'll need to fix your .patch file. Secondly, ensure that the order in which your patches are being applied is not causing problems. By default Eugenia orders patches alphabetically by filename: a.patch will be applied before z.patch","title":"One or more of my patches couldn't be applied. What should I do?"},{"location":"doc/articles/eugenia-patching/#im-using-git-svn-and-my-patch-files-cant-be-applied-by-eugenia-or-by-eclipses-teamapply-patch-menu-item-what-should-i-do","text":"You should edit the headers of any patch file generated by git-svn and remove the dummy a and b folders. For example:* diff --git a/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java b/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java index 65e2685..109b568 100644 --- a/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java +++ b/org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java @@ -152,6 +152,8 @@ ... becomes: diff --git org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java index 65e2685..109b568 100644 --- org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java +++ org.eclipse.epsilon.eugenia.examples.executablestatemachine.graphical.diagram/src/esm/diagram/edit/parts/EndStateEditPart.java @@ -152,6 +152,8 @@ ...","title":"I'm using git-svn and my patch files can't be applied by Eugenia or by Eclipse's Team\u2192Apply patch... menu item. What should I do?"},{"location":"doc/articles/eugenia-phantom-nodes/","text":"Eugenia: Phantom nodes in GMF editors \u00b6 Containment references in Ecore metamodels are usually depicted in GMF as spatial containment (e.g. in the sense that a class is contained inside the figure of a package). However, it is sometimes needed to represent containment references using links instead. To achieve this, GMF provides the notion of phantom nodes. Eugenia provides first-class support for phantom nodes in GMF using the phantom annotation detail. The following listing provides such an example: @namespace(uri=\"phantom\", prefix=\"phantom\") package phantom; @gmf.diagram class Model extends NamedElement { val Group[*] groups; } class NamedElement { attr String name; } @gmf.node(label=\"name\") class Group extends NamedElement { @gmf.link(label=\"member\") val Member[*] members; } @gmf.node(label=\"name\", phantom=\"true\") class Member extends NamedElement { } In this example, a Model contains many groups and a Group contains many members. To represent the Group.members containment reference as a normal link, we set the phantom detail of the gmf.node annotation of Member to true and add a gmf.link anotation to Group.members. The result looks like this:","title":"Eugenia: Phantom nodes in GMF editors"},{"location":"doc/articles/eugenia-phantom-nodes/#eugenia-phantom-nodes-in-gmf-editors","text":"Containment references in Ecore metamodels are usually depicted in GMF as spatial containment (e.g. in the sense that a class is contained inside the figure of a package). However, it is sometimes needed to represent containment references using links instead. To achieve this, GMF provides the notion of phantom nodes. Eugenia provides first-class support for phantom nodes in GMF using the phantom annotation detail. The following listing provides such an example: @namespace(uri=\"phantom\", prefix=\"phantom\") package phantom; @gmf.diagram class Model extends NamedElement { val Group[*] groups; } class NamedElement { attr String name; } @gmf.node(label=\"name\") class Group extends NamedElement { @gmf.link(label=\"member\") val Member[*] members; } @gmf.node(label=\"name\", phantom=\"true\") class Member extends NamedElement { } In this example, a Model contains many groups and a Group contains many members. To represent the Group.members containment reference as a normal link, we set the phantom detail of the gmf.node annotation of Member to true and add a gmf.link anotation to Group.members. The result looks like this:","title":"Eugenia: Phantom nodes in GMF editors"},{"location":"doc/articles/eugenia-polishing/","text":"Customizing a GMF editor generated by Eugenia \u00b6 So now you have created the first version of your GMF editor with Eugenia and it looks almost like what you want - just a few tweaks and you are there. As Eugenia doesn't support all the features of GMF (otherwise it would be just as complex) you are finding that the tweaks you want to do are not supported by the annotations provided by Eugenia and therefore you need to go change one or more of the generated .gmfgraph, .gmfmap and .gmftool models manually. If you decide to do this, you won't be able to use Eugenia any more for your editor because it will overwrite your changes. We've come across this situation many times and decided to do something about it. Since merging such complex models sensibly is virtually impossible, we've implemented support for user-defined transformations that complement the built-in transformations provided by Eugenia. Let's go straight to an example. We have the following classdiagram metamodel: @namespace(uri=\"classdiagram\", prefix=\"classdiagram\") package classdiagram; @gmf.diagram class Model { val Clazz[*] classes; } @gmf.node(label=\"name\", figure=\"rectangle\") class Clazz { attr String name; @gmf.compartment(layout=\"list\", collapsible=\"false\") val Attribute[*] attributes; } @gmf.node(label=\"name,type\", figure=\"rectangle\", label.icon=\"false\", label.pattern=\"{0}:{1}\") class Attribute { attr String name; attr String type; } and we follow the standard Eugenia procedure to generate a GMF editor from it. The editor looks like this: which is almost what we want. What we really want is something like this: To get this, we need to customize the classdiagram.gmfgraph model like this so that we can get this: To perform these changes automatically every time Eugenia is executed on classdiagram.ecore , we can create a new EOL transformation called ECore2GMF.eol and place it in the same folder with classdiagram.ecore . Eugenia will then pick it up and execute it after the built-in transformation every time we invoke Generate GMF tool, graph and map models action. In our case, the ECore2GMF.eol customization transformation looks like this: // Find the compartment figure var clazzAttributesCompartmentFigure = GmfGraph!Rectangle.all. selectOne(r|r.name = 'ClazzAttributesCompartmentFigure'); // ... and add a stack layout to it clazzAttributesCompartmentFigure.layout = new GmfGraph!StackLayout; // Find the attribute figure var attributeFigure = GmfGraph!Rectangle.all. selectOne(r|r.name = 'AttributeFigure'); // ... delete its border delete attributeFigure.border; // ... set its outline to false attributeFigure.outline = false; // ... and add a preferred size to it var preferredSize = new GmfGraph!Dimension; preferredSize.dx = 100; preferredSize.dy = 16; attributeFigure.preferredSize = preferredSize; Similarly, if we needed to customize the logic behind the Synchronize GMF Gen model action, we'd need to define a FixGMFGen.eol transformation next to classdiagram.ecore . What models can I access from the ECore2GMF.eol and FixGMFGen.eol transformations? \u00b6 In the Ecore2GenModel.eol transformation and the later FixGenModel.eol transformation you can access the ECore metamodel (named Ecore ) and the EMF GenModel model (named GenModel ). You can run Ecore2GenModel.eol or FixGenModel.eol manually by right-clicking on the .ecore file and selecting \"Generate EMF GenModel\" or \"Synchronize EMF GenModel\", respectively. In the ECore2GMF.eol transformation you can access the ECore metamodel (named ECore ), the tool model (named GmfTool ), the graph model (named GmfGraph ) and the map model (named GmfMap ). You can regenerate the GMF models and run ECore2GMF.eol manually by right-clicking on the .ecore file and selecting \"Generate GMF tool, graph and map models\". In the FixGMFGen.eol transformation you can access the ECore metamodel (named ECore ), and the generator model (named GmfGen ). You can run FixGMFGen.eol manually by right-clicking on the .gmfgen model (which should have been created previously from the .gmfmap using standard GMF tools) and selecting \"Synchronize GMFGen\". How do I customize the generated code? \u00b6 GMF generates code in two steps: During the GmfMap \u2192 GmfGen transformation: small fragments are embedded into the GmfGen model, using GMF figure templates. From the GmfGen model: the embedded bits are dumped to certain files, and additional code is generated using the rest of the GMF templates. To use your own GMF figure templates, you need to place them under a folder called templates-gmfgraph , which should be a sibling of the folder where your .emf or .ecore files are stored. If it exists, Eugenia will use its templates for the GmfMap \u2192 GmfGen transformation. To customize the code generated from the GmfGen model, you will need to use Eugenia's patch generation and application functionality or GMF dynamic templates . Getting assistance in writing these transformations \u00b6 You'll most probably find Exeed and the EPackage Registry view to be useful for writing such transformations.","title":"Customizing a GMF editor generated by Eugenia"},{"location":"doc/articles/eugenia-polishing/#customizing-a-gmf-editor-generated-by-eugenia","text":"So now you have created the first version of your GMF editor with Eugenia and it looks almost like what you want - just a few tweaks and you are there. As Eugenia doesn't support all the features of GMF (otherwise it would be just as complex) you are finding that the tweaks you want to do are not supported by the annotations provided by Eugenia and therefore you need to go change one or more of the generated .gmfgraph, .gmfmap and .gmftool models manually. If you decide to do this, you won't be able to use Eugenia any more for your editor because it will overwrite your changes. We've come across this situation many times and decided to do something about it. Since merging such complex models sensibly is virtually impossible, we've implemented support for user-defined transformations that complement the built-in transformations provided by Eugenia. Let's go straight to an example. We have the following classdiagram metamodel: @namespace(uri=\"classdiagram\", prefix=\"classdiagram\") package classdiagram; @gmf.diagram class Model { val Clazz[*] classes; } @gmf.node(label=\"name\", figure=\"rectangle\") class Clazz { attr String name; @gmf.compartment(layout=\"list\", collapsible=\"false\") val Attribute[*] attributes; } @gmf.node(label=\"name,type\", figure=\"rectangle\", label.icon=\"false\", label.pattern=\"{0}:{1}\") class Attribute { attr String name; attr String type; } and we follow the standard Eugenia procedure to generate a GMF editor from it. The editor looks like this: which is almost what we want. What we really want is something like this: To get this, we need to customize the classdiagram.gmfgraph model like this so that we can get this: To perform these changes automatically every time Eugenia is executed on classdiagram.ecore , we can create a new EOL transformation called ECore2GMF.eol and place it in the same folder with classdiagram.ecore . Eugenia will then pick it up and execute it after the built-in transformation every time we invoke Generate GMF tool, graph and map models action. In our case, the ECore2GMF.eol customization transformation looks like this: // Find the compartment figure var clazzAttributesCompartmentFigure = GmfGraph!Rectangle.all. selectOne(r|r.name = 'ClazzAttributesCompartmentFigure'); // ... and add a stack layout to it clazzAttributesCompartmentFigure.layout = new GmfGraph!StackLayout; // Find the attribute figure var attributeFigure = GmfGraph!Rectangle.all. selectOne(r|r.name = 'AttributeFigure'); // ... delete its border delete attributeFigure.border; // ... set its outline to false attributeFigure.outline = false; // ... and add a preferred size to it var preferredSize = new GmfGraph!Dimension; preferredSize.dx = 100; preferredSize.dy = 16; attributeFigure.preferredSize = preferredSize; Similarly, if we needed to customize the logic behind the Synchronize GMF Gen model action, we'd need to define a FixGMFGen.eol transformation next to classdiagram.ecore .","title":"Customizing a GMF editor generated by Eugenia"},{"location":"doc/articles/eugenia-polishing/#what-models-can-i-access-from-the-ecore2gmfeol-and-fixgmfgeneol-transformations","text":"In the Ecore2GenModel.eol transformation and the later FixGenModel.eol transformation you can access the ECore metamodel (named Ecore ) and the EMF GenModel model (named GenModel ). You can run Ecore2GenModel.eol or FixGenModel.eol manually by right-clicking on the .ecore file and selecting \"Generate EMF GenModel\" or \"Synchronize EMF GenModel\", respectively. In the ECore2GMF.eol transformation you can access the ECore metamodel (named ECore ), the tool model (named GmfTool ), the graph model (named GmfGraph ) and the map model (named GmfMap ). You can regenerate the GMF models and run ECore2GMF.eol manually by right-clicking on the .ecore file and selecting \"Generate GMF tool, graph and map models\". In the FixGMFGen.eol transformation you can access the ECore metamodel (named ECore ), and the generator model (named GmfGen ). You can run FixGMFGen.eol manually by right-clicking on the .gmfgen model (which should have been created previously from the .gmfmap using standard GMF tools) and selecting \"Synchronize GMFGen\".","title":"What models can I access from the ECore2GMF.eol and FixGMFGen.eol transformations?"},{"location":"doc/articles/eugenia-polishing/#how-do-i-customize-the-generated-code","text":"GMF generates code in two steps: During the GmfMap \u2192 GmfGen transformation: small fragments are embedded into the GmfGen model, using GMF figure templates. From the GmfGen model: the embedded bits are dumped to certain files, and additional code is generated using the rest of the GMF templates. To use your own GMF figure templates, you need to place them under a folder called templates-gmfgraph , which should be a sibling of the folder where your .emf or .ecore files are stored. If it exists, Eugenia will use its templates for the GmfMap \u2192 GmfGen transformation. To customize the code generated from the GmfGen model, you will need to use Eugenia's patch generation and application functionality or GMF dynamic templates .","title":"How do I customize the generated code?"},{"location":"doc/articles/eugenia-polishing/#getting-assistance-in-writing-these-transformations","text":"You'll most probably find Exeed and the EPackage Registry view to be useful for writing such transformations.","title":"Getting assistance in writing these transformations"},{"location":"doc/articles/evl-gmf-integration/","text":"Live validation and quick-fixes in GMF-based editors with EVL \u00b6 In this tutorial , we demonstrated how Eugenia can be used to easily implement a GMF-based editor for a small FileSystem DSL. Now, we demonstrate how the Epsilon Validation Language can be used to easily contribute validation/quick fixes to our GMF editor. Info This applies to any GMF-based editor - not only to editors constructed with Eugenia. Warning If you have not implemented your editor using Eugenia, before you start please make sure that you have turned on validation in your .gmfgen model. The flags you need to set to true are the Validation Enabled and Validation Decorators in the Gen Diagram . Step 1: Create the integration plugin \u00b6 In the first step we create the integration plugin that will host our constraints and extensions. We name it org.eclipse.epsilon.eugenia.examples.filesystem.validation Step 2: Set the dependencies \u00b6 We switch to the dependencies tab of MANIFEST.MF and add org.eclipse.ui.ide and org.eclipse.epsilon.evl.emf.validation to the list of dependencies. Step 3: Write the constraints \u00b6 We create a new .evl file in the plugin. In our case we've created it under validation/filesystem.evl (make sure you switch to the Build tab to verify that the .evl file is included in your binary build). In our example we define the following constraints: context File { constraint HasName { check : self.name.isDefined() message : 'Unnamed ' + self.eClass().name + ' not allowed' } } context Folder { critique NameStartsWithCapital { guard : self.satisfies('HasName') check : self.name.firstToUpperCase() = self.name message : 'Folder ' + self.name + ' should start with an upper-case letter' fix { title : 'Rename to ' + self.name.firstToUpperCase() do { self.name := self.name.firstToUpperCase(); } } } } context Sync { constraint MustLinkSame { check : self.source.eClass() = self.target.eClass() message : 'Cannot synchronize a ' + self.source.eClass().name + ' with a ' + self.target.eClass().name fix { title : 'Synchronize with another ' + self.source.eClass().name do { var target := UserInput.choose('Select target', _Model.getAllOfType(self.source.eClass().name)); if (target.isDefined()) self.target := target; } } } } We have defined three constraints: The first ( HasName ) requires that each file has a non-empty name. The second one ( NameStartsWithCapital ) requires that every folder starts with a capital letter. Unlike the HasName , this is declared as a critique which means that if it is not satisfied by an element, this will be shown as a warning (instead of an error) on the editor. In the guard of this constraint we first check that the element satisfies the HasName constraint first (it wouldn't make sense to check this for an empty-named file). If the critique is not satisfied, a warning is generated and the user is presented with the option to invoke the fix which automatically renames the folder. The third one ( MustLinkSame ) requires that a sync synchronizes two things of the same type: i.e. a folder with a folder, a file with a file etc. If this fails, it generates an error and the user can invoke the fix to repair it. In the fix, the user is prompted to select one of the elements of the same type as the source of the sync to serve as the target. Step 4: Bind the constraints to the editor \u00b6 Having written the constraints, the next step is to bind them to the GMF editor. To do this, we switch to the Extensions tab of MANIFEST.MF and add the org.eclipse.epsilon.evl.emf.validation extension. Then we right-click it and add a new constraintBinding . In the namespaceURI field of the extension we set the value to filesystem and in the constraints field we select the validation/filesystem.evl EVL file we created in Step 3. Next, we add the org.eclipse.ui.ide.markerResolution extension and below it we create two markerResolutionGenerator with the following details class : org.eclipse.epsilon.evl.emf.validation.EvlMarkerResolutionGenerator markerType : org.eclipse.epsilon.eugenia.examples.filesystem.diagram.diagnostic and class : org.eclipse.epsilon.evl.emf.validation.EvlMarkerResolutionGenerator markerType : org.eclipse.emf.ecore.diagnostic Step 5: Ready to go! \u00b6 The next step is to run a new Eclipse instance and create a new filesystem diagram that looks like this: To validate this we go to the Diagram menu and select Validate (depending on your version of Eclipse, the Validate option may be located under the Edit menu instead). The editor now looks like this: There are two problems with our model: The sync between picture.bmp and backup is invalid as it syncs a file with a folder. As a result the MustLinkSame constraint has failed and the sync has been visually annotated with a red circle that shows this. Similarly, the NameStartsWithCapital constraints has failed for the backup folder (it should start with an upper-case letter) and this is indicated with a red triangle on the folder. The generated errors/warnings also appear in the Problems view: Double-clicking on an error/warning in this view brings us to the respective editor and highlights the failing element. What is more important however is that for constraints for which we have defined fixes (e.g. the MustLinkSame and NameStartsWithCapital ) constraints, we can also apply the fixes using this view. To do this we need to right-click a problem that has quick fixes (indicated by a small lamp on the bottom right) and select Quick Fix . Doing this for the \"Folder backup should start with an upper-case letter\" warning, brings up the following dialog: Clicking Finish invokes the behaviour of the fix which renames the folder from backup to Backup (and resolves the problem). The change is also reflected to the diagram automatically due to the GMF MVC architecture. It is worth mentioning that any changes done during a quick fix can be undone/redone using the respective options from the Edit menu (or simply using Ctrl-Z , Ctrl-Y ). Also, if an error occurs in the middle of a fix block, all changes to the model done in the block are automatically rolled back. Troubleshooting/Known issues \u00b6 While errors/warnings are persisted across sessions, quick-fixes are not. Therefore, if you run validation and re-start Eclipse, in the new Eclipse instance the problems will still appear in the editor/problems view but quick-fixes will not be available until you run validation again. We are currently working on a fix for this. Recipes \u00b6 If you need validation to be performed whenever your diagram is saved add the following line in the doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) method of your XXXDocumentProvider class (located in the .diagram.part package) in your diagram plugin. ValidateAction . runValidation (( View ) document . getContent ());","title":"Live validation and quick-fixes in GMF-based editors with EVL"},{"location":"doc/articles/evl-gmf-integration/#live-validation-and-quick-fixes-in-gmf-based-editors-with-evl","text":"In this tutorial , we demonstrated how Eugenia can be used to easily implement a GMF-based editor for a small FileSystem DSL. Now, we demonstrate how the Epsilon Validation Language can be used to easily contribute validation/quick fixes to our GMF editor. Info This applies to any GMF-based editor - not only to editors constructed with Eugenia. Warning If you have not implemented your editor using Eugenia, before you start please make sure that you have turned on validation in your .gmfgen model. The flags you need to set to true are the Validation Enabled and Validation Decorators in the Gen Diagram .","title":"Live validation and quick-fixes in GMF-based editors with EVL"},{"location":"doc/articles/evl-gmf-integration/#step-1-create-the-integration-plugin","text":"In the first step we create the integration plugin that will host our constraints and extensions. We name it org.eclipse.epsilon.eugenia.examples.filesystem.validation","title":"Step 1: Create the integration plugin"},{"location":"doc/articles/evl-gmf-integration/#step-2-set-the-dependencies","text":"We switch to the dependencies tab of MANIFEST.MF and add org.eclipse.ui.ide and org.eclipse.epsilon.evl.emf.validation to the list of dependencies.","title":"Step 2: Set the dependencies"},{"location":"doc/articles/evl-gmf-integration/#step-3-write-the-constraints","text":"We create a new .evl file in the plugin. In our case we've created it under validation/filesystem.evl (make sure you switch to the Build tab to verify that the .evl file is included in your binary build). In our example we define the following constraints: context File { constraint HasName { check : self.name.isDefined() message : 'Unnamed ' + self.eClass().name + ' not allowed' } } context Folder { critique NameStartsWithCapital { guard : self.satisfies('HasName') check : self.name.firstToUpperCase() = self.name message : 'Folder ' + self.name + ' should start with an upper-case letter' fix { title : 'Rename to ' + self.name.firstToUpperCase() do { self.name := self.name.firstToUpperCase(); } } } } context Sync { constraint MustLinkSame { check : self.source.eClass() = self.target.eClass() message : 'Cannot synchronize a ' + self.source.eClass().name + ' with a ' + self.target.eClass().name fix { title : 'Synchronize with another ' + self.source.eClass().name do { var target := UserInput.choose('Select target', _Model.getAllOfType(self.source.eClass().name)); if (target.isDefined()) self.target := target; } } } } We have defined three constraints: The first ( HasName ) requires that each file has a non-empty name. The second one ( NameStartsWithCapital ) requires that every folder starts with a capital letter. Unlike the HasName , this is declared as a critique which means that if it is not satisfied by an element, this will be shown as a warning (instead of an error) on the editor. In the guard of this constraint we first check that the element satisfies the HasName constraint first (it wouldn't make sense to check this for an empty-named file). If the critique is not satisfied, a warning is generated and the user is presented with the option to invoke the fix which automatically renames the folder. The third one ( MustLinkSame ) requires that a sync synchronizes two things of the same type: i.e. a folder with a folder, a file with a file etc. If this fails, it generates an error and the user can invoke the fix to repair it. In the fix, the user is prompted to select one of the elements of the same type as the source of the sync to serve as the target.","title":"Step 3: Write the constraints"},{"location":"doc/articles/evl-gmf-integration/#step-4-bind-the-constraints-to-the-editor","text":"Having written the constraints, the next step is to bind them to the GMF editor. To do this, we switch to the Extensions tab of MANIFEST.MF and add the org.eclipse.epsilon.evl.emf.validation extension. Then we right-click it and add a new constraintBinding . In the namespaceURI field of the extension we set the value to filesystem and in the constraints field we select the validation/filesystem.evl EVL file we created in Step 3. Next, we add the org.eclipse.ui.ide.markerResolution extension and below it we create two markerResolutionGenerator with the following details class : org.eclipse.epsilon.evl.emf.validation.EvlMarkerResolutionGenerator markerType : org.eclipse.epsilon.eugenia.examples.filesystem.diagram.diagnostic and class : org.eclipse.epsilon.evl.emf.validation.EvlMarkerResolutionGenerator markerType : org.eclipse.emf.ecore.diagnostic","title":"Step 4: Bind the constraints to the editor"},{"location":"doc/articles/evl-gmf-integration/#step-5-ready-to-go","text":"The next step is to run a new Eclipse instance and create a new filesystem diagram that looks like this: To validate this we go to the Diagram menu and select Validate (depending on your version of Eclipse, the Validate option may be located under the Edit menu instead). The editor now looks like this: There are two problems with our model: The sync between picture.bmp and backup is invalid as it syncs a file with a folder. As a result the MustLinkSame constraint has failed and the sync has been visually annotated with a red circle that shows this. Similarly, the NameStartsWithCapital constraints has failed for the backup folder (it should start with an upper-case letter) and this is indicated with a red triangle on the folder. The generated errors/warnings also appear in the Problems view: Double-clicking on an error/warning in this view brings us to the respective editor and highlights the failing element. What is more important however is that for constraints for which we have defined fixes (e.g. the MustLinkSame and NameStartsWithCapital ) constraints, we can also apply the fixes using this view. To do this we need to right-click a problem that has quick fixes (indicated by a small lamp on the bottom right) and select Quick Fix . Doing this for the \"Folder backup should start with an upper-case letter\" warning, brings up the following dialog: Clicking Finish invokes the behaviour of the fix which renames the folder from backup to Backup (and resolves the problem). The change is also reflected to the diagram automatically due to the GMF MVC architecture. It is worth mentioning that any changes done during a quick fix can be undone/redone using the respective options from the Edit menu (or simply using Ctrl-Z , Ctrl-Y ). Also, if an error occurs in the middle of a fix block, all changes to the model done in the block are automatically rolled back.","title":"Step 5: Ready to go!"},{"location":"doc/articles/evl-gmf-integration/#troubleshootingknown-issues","text":"While errors/warnings are persisted across sessions, quick-fixes are not. Therefore, if you run validation and re-start Eclipse, in the new Eclipse instance the problems will still appear in the editor/problems view but quick-fixes will not be available until you run validation again. We are currently working on a fix for this.","title":"Troubleshooting/Known issues"},{"location":"doc/articles/evl-gmf-integration/#recipes","text":"If you need validation to be performed whenever your diagram is saved add the following line in the doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) method of your XXXDocumentProvider class (located in the .diagram.part package) in your diagram plugin. ValidateAction . runValidation (( View ) document . getContent ());","title":"Recipes"},{"location":"doc/articles/excel/","text":"Scripting Excel Spreadsheets using Epsilon \u00b6 Spreadsheets are commonly used in software and systems engineering processes to capture and analyse structured data, and can be sources of valuable information for model-based software engineering activities. Epsilon provides built-in support for querying and transforming Excel spreadsheets through an Apache POI -based EMC driver. This article discusses how you can configure an Epsilon program to query and modify an Excel spreadsheet, and the video below demonstrates the driver in action. Citing the Excel EMC driver in a publication? If you are referring to Epsilon's Excel EMC driver in a publication, please cite this paper instead of the website URL. Regression in Epsilon 2.2 Due to a regression, the Excel driver is broken in Epsilon 2.2. The driver works well in previous versions (e.g. 2.1) as well as in 2.3. Support for column datatypes and for writing to Excel spreadsheets has improved substantially in 2.3. Worksheets, Columns and Rows \u00b6 Essentially, in the Excel driver, by default, worksheets are treated as model element types (e.g. Student , Staff , Module and Mark in the spreadsheet below), columns as their properties (e.g. Mark has student , module and mark properties), and rows are treated as model elements (i.e. there are two students, two members of staff, three modules and two marks in the spreadsheet below). .h { text-align: center; background-color: #EBEBEB; } Student A B C D E F 1 id firstname lastname age supervisor modules 2 jt501 Joe Thompson 23 mt506 MSD,RQE 3 js502 Jane Smith 22 mt506 MSD,HCI Staff A B C D E F 1 id firstname lastname teaches 2 mt506 Matthew Thomas MSD,RQE 3 dj503 Daniel Jackson HCI Module A B C D E F 1 id title term 2 MSD Modelling and System Design Autumn 3 HCI Human Computer Interaction Spring 4 RQE Requirements Engineering Spring Mark A B C D E F 1 student module mark 2 jt501 MSD 62 3 js502 HCI 74 References and Column Types \u00b6 The driver supports specifying additional configuration information (e.g. column data types, references between columns) about a spreadsheet in the form of an external XML document, that can be attached to the spreadsheet in Epsilon's run configuration dialog. For our example spreadsheet, above, the configuration file below specifies the types of the age and mark columns of the spreadsheet, the multiplicity of the teaches column, as well as references between the Student.supervisor and Staff.id , and the Staff.teaches and Module.id columns. <spreadsheet> <worksheet name= \"Student\" > <column name= \"age\" datatype= \"integer\" /> <column name= \"modules\" many= \"true\" /> </worksheet> <worksheet name= \"Mark\" > <column name= \"mark\" datatype= \"integer\" /> </worksheet> <worksheet name= \"Staff\" > <column name= \"teaches\" many= \"true\" delimiter= \",\" /> </worksheet> <reference source= \"Student->supervisor\" target= \"Staff->id\" /> <reference source= \"Student->modules\" target= \"Module->id\" /> <reference source= \"Staff->teaches\" target= \"Module->id\" /> <reference source= \"Mark->module\" target= \"Module->id\" /> <reference source= \"Mark->student\" target= \"Student->id\" /> </spreadsheet> The format of the XML configuration document is as follows: Worksheet \u00b6 Each worksheet can have an optional name (if a name is not provided, the name of the worksheet on the spreadsheet is used) and acts as a container for column elements. Column \u00b6 Each column needs to specify its index in the context of the worksheet it belongs to, and optionally, a name (if a name is not provided, the one specified in its first cell is used as discussed above), an alias , a datatype , a cardinality , and in case of columns with unbounded cardinality, the delimiter that should be used to separate the values stored in a single cell (comma is used as the default delimiter). Reference \u00b6 In a configuration document we can also specify ID-based references to capture relationships between columns belonging to potentially different worksheets. Each reference has a source and a target column, an optional name (if a name is not specified, the name of the source column is used to navigate the reference), a cardinality ( many attribute), and specifies whether updates to cells of the target column should be propagated automatically ( cascadeUpdates attribute) to the respective cells in the source column to preserve referential integrity. Querying and Modifying Spreadsheets \u00b6 Having specified the configuration document above, we can now query the spreadsheet with EOL as follows. // Returns all students supervised by Matthew Thomas Student.all.select(s|s.supervisor?.lastname = \"Thomas\"); // Returns the modules taught by Daniel Jackson Module.all.select(m| Staff.all.exists(s| s.firstname=\"Daniel\" and s.teaches.includes(m))); Creating Rows \u00b6 As discussed above, worksheets are treated as types and rows as their instances. As such, to create a new row in the Student worksheet, EOL's new operation can be used. var student : new Student; Deleting Rows \u00b6 To delete a row from a worksheet, EOL's delete operator can be used. When a row is deleted, all the rows that contain cells referring to it through cascade-update references also need to be recursively deleted. var student = Student.all.selectOne(s|s.id = \"js502\"); // deletes row 2 of the Student worksheet // also deletes row 3 of the Mark worksheet delete student; Modifying Cell Values \u00b6 If a cell is single-valued, a type-conforming assignment can be used to edit its value. For example, the following listing demonstrates modifying the age and the supervisor of a particular student. var student : Student = ...; var supervisor : Staff = ...; student.age = 24; student.supervisor = supervisor; If on the other hand the cell is multi-valued, then its values should be handled as a collection. Adding/removing values from property collections has no effect on the spreadsheet; you need to re-assign values instead. // Moves a module between two members of staff var from : Staff = ...; var to : Staff = ...; var module : Module = ...; // Neither of these will work // from.teaches.remove(module); // to.teaches.add(module); // ... but these will from.teaches = from.teaches.excluding(module); to.teaches = to.teaches.including(module); Updating the value of a cell can have side effects to other cells that are linked to it through cascade-update references to preserve referential integrity. For example, updating the value of cell A3 in the Module worksheet, should trigger appropriate updates in cells D2 and F2 of the Staff and Student worksheets respectively. Validating and Transforming Spreadsheets \u00b6 Of course, we can also validate spreadsheets using EVL , transform them into other models using ETL , and into text using EGL , generate graphical views using Picto etc. context Staff { constraint NotOverloaded { check: self.teaches.size() <= 4 message: \"Member of staff\" + self.firstname + \" \" + self.lastname + \" is overloaded\" } } Creating Spreadsheets \u00b6 To create a spreadsheet from scratch (e.g. when it is produced by an ETL transformation), we also need to specify an index for each column in the XML mapping file. Below is an EOL program that creates the spreadsheet above from scratch, and the mapping file for it. The complete example is in Epsilon's Git repo . create-spreadsheet.eol // Create the modules var MSD = new Module(id=\"MSD\", title=\"Modelling and System Design\", term=\"Autumn\"); var HCI = new Module(id=\"HCI\", title=\"Human Computer Interaction\", term=\"Spring\"); var RQE = new Module(id=\"RQE\", title=\"Requirements Engineering\", term=\"Spring\"); // Create the staff var matthew = new Staff(id=\"mt506\", firstname=\"Matthew\", lastname=\"Thomas\", teaches=Sequence{MSD, RQE}); var matthew = new Staff(id=\"dj503\", firstname=\"Daniel\", lastname=\"Jackson\", teaches=Sequence{HCI}); // Create the students var joe = new Student(id=\"jt501\", firstname=\"Joe\", lastname=\"Thompson\", age=\"23\", supervisor=matthew, modules=Sequence{MSD, RQE}); var jane = new Student(id=\"js502\", firstname=\"Jane\", lastname=\"Smith\", age=\"22\", supervisor=matthew, modules=Sequence{MSD, HCI}); // Create the marks new Mark(student=joe, module=MSD, mark=62); new Mark(student=jane, module=HCI, mark=74); mapping.xml <spreadsheet> <worksheet name= \"Student\" > <column index= \"0\" name= \"id\" /> <column index= \"1\" name= \"firstname\" /> <column index= \"2\" name= \"lastname\" /> <column index= \"3\" name= \"age\" datatype= \"integer\" /> <column index= \"4\" name= \"supervisor\" /> <column index= \"5\" name= \"modules\" many= \"true\" /> </worksheet> <worksheet name= \"Mark\" > <column index= \"0\" name= \"student\" /> <column index= \"1\" name= \"module\" /> <column index= \"2\" name= \"mark\" datatype= \"integer\" /> </worksheet> <worksheet name= \"Staff\" > <column index= \"0\" name= \"id\" /> <column index= \"1\" name= \"firstname\" /> <column index= \"2\" name= \"lastname\" /> <column index= \"3\" name= \"teaches\" many= \"true\" delimiter= \",\" /> </worksheet> <worksheet name= \"Module\" > <column index= \"0\" name= \"id\" /> <column index= \"1\" name= \"title\" /> <column index= \"2\" name= \"term\" /> </worksheet> <reference source= \"Student->supervisor\" target= \"Staff->id\" /> <reference source= \"Student->modules\" target= \"Module->id\" /> <reference source= \"Staff->teaches\" target= \"Module->id\" /> <reference source= \"Mark->module\" target= \"Module->id\" /> <reference source= \"Mark->student\" target= \"Student->id\" /> </spreadsheet> Working with Formulas \u00b6 To set the value of a cell to a formula, start its value with = as shown below. The complete example is in Epsilon's Git repo . create-spreadsheet-with-formulas.eol var calc : new Calc; calc.a = 1; calc.b = 2; calc.sum = \"=A2+B2\"; calc.sum.println(); // Prints 3 mapping.xml <spreadsheet> <worksheet name= \"Calc\" > <column index= \"0\" name= \"a\" datatype= \"integer\" /> <column index= \"1\" name= \"b\" datatype= \"integer\" /> <column index= \"2\" name= \"sum\" datatype= \"integer\" /> </worksheet> </spreadsheet> Reflective Access \u00b6 To iterate over all the worksheets, columns and rows of a speadsheet without referring to them by name, we can use the following statements (assuming that our Excel spreadsheet is named M in the run configuration). Additional methods of interest for this mode of access can be found in the Javadoc of the underlying ExcelModel and SpreadsheetModel classes. // Iterate over all worksheets for (w in M.worksheets) { w.name.println(); // Iterate over all columns // of the worksheet for (c in w.header.columns) { c.name.println(\"\\t\"); } // Iterate over all rows // of the worksheet for (r in w.rows) { r.println(\"\\t\"); } } Resources \u00b6 This article shows how to use Excel spreadsheets in ANT/Gradle/Maven builds.","title":"Scripting Excel Spreadsheets using Epsilon"},{"location":"doc/articles/excel/#scripting-excel-spreadsheets-using-epsilon","text":"Spreadsheets are commonly used in software and systems engineering processes to capture and analyse structured data, and can be sources of valuable information for model-based software engineering activities. Epsilon provides built-in support for querying and transforming Excel spreadsheets through an Apache POI -based EMC driver. This article discusses how you can configure an Epsilon program to query and modify an Excel spreadsheet, and the video below demonstrates the driver in action. Citing the Excel EMC driver in a publication? If you are referring to Epsilon's Excel EMC driver in a publication, please cite this paper instead of the website URL. Regression in Epsilon 2.2 Due to a regression, the Excel driver is broken in Epsilon 2.2. The driver works well in previous versions (e.g. 2.1) as well as in 2.3. Support for column datatypes and for writing to Excel spreadsheets has improved substantially in 2.3.","title":"Scripting Excel Spreadsheets using Epsilon"},{"location":"doc/articles/excel/#worksheets-columns-and-rows","text":"Essentially, in the Excel driver, by default, worksheets are treated as model element types (e.g. Student , Staff , Module and Mark in the spreadsheet below), columns as their properties (e.g. Mark has student , module and mark properties), and rows are treated as model elements (i.e. there are two students, two members of staff, three modules and two marks in the spreadsheet below). .h { text-align: center; background-color: #EBEBEB; } Student A B C D E F 1 id firstname lastname age supervisor modules 2 jt501 Joe Thompson 23 mt506 MSD,RQE 3 js502 Jane Smith 22 mt506 MSD,HCI Staff A B C D E F 1 id firstname lastname teaches 2 mt506 Matthew Thomas MSD,RQE 3 dj503 Daniel Jackson HCI Module A B C D E F 1 id title term 2 MSD Modelling and System Design Autumn 3 HCI Human Computer Interaction Spring 4 RQE Requirements Engineering Spring Mark A B C D E F 1 student module mark 2 jt501 MSD 62 3 js502 HCI 74","title":"Worksheets, Columns and Rows"},{"location":"doc/articles/excel/#references-and-column-types","text":"The driver supports specifying additional configuration information (e.g. column data types, references between columns) about a spreadsheet in the form of an external XML document, that can be attached to the spreadsheet in Epsilon's run configuration dialog. For our example spreadsheet, above, the configuration file below specifies the types of the age and mark columns of the spreadsheet, the multiplicity of the teaches column, as well as references between the Student.supervisor and Staff.id , and the Staff.teaches and Module.id columns. <spreadsheet> <worksheet name= \"Student\" > <column name= \"age\" datatype= \"integer\" /> <column name= \"modules\" many= \"true\" /> </worksheet> <worksheet name= \"Mark\" > <column name= \"mark\" datatype= \"integer\" /> </worksheet> <worksheet name= \"Staff\" > <column name= \"teaches\" many= \"true\" delimiter= \",\" /> </worksheet> <reference source= \"Student->supervisor\" target= \"Staff->id\" /> <reference source= \"Student->modules\" target= \"Module->id\" /> <reference source= \"Staff->teaches\" target= \"Module->id\" /> <reference source= \"Mark->module\" target= \"Module->id\" /> <reference source= \"Mark->student\" target= \"Student->id\" /> </spreadsheet> The format of the XML configuration document is as follows:","title":"References and Column Types"},{"location":"doc/articles/excel/#worksheet","text":"Each worksheet can have an optional name (if a name is not provided, the name of the worksheet on the spreadsheet is used) and acts as a container for column elements.","title":"Worksheet"},{"location":"doc/articles/excel/#column","text":"Each column needs to specify its index in the context of the worksheet it belongs to, and optionally, a name (if a name is not provided, the one specified in its first cell is used as discussed above), an alias , a datatype , a cardinality , and in case of columns with unbounded cardinality, the delimiter that should be used to separate the values stored in a single cell (comma is used as the default delimiter).","title":"Column"},{"location":"doc/articles/excel/#reference","text":"In a configuration document we can also specify ID-based references to capture relationships between columns belonging to potentially different worksheets. Each reference has a source and a target column, an optional name (if a name is not specified, the name of the source column is used to navigate the reference), a cardinality ( many attribute), and specifies whether updates to cells of the target column should be propagated automatically ( cascadeUpdates attribute) to the respective cells in the source column to preserve referential integrity.","title":"Reference"},{"location":"doc/articles/excel/#querying-and-modifying-spreadsheets","text":"Having specified the configuration document above, we can now query the spreadsheet with EOL as follows. // Returns all students supervised by Matthew Thomas Student.all.select(s|s.supervisor?.lastname = \"Thomas\"); // Returns the modules taught by Daniel Jackson Module.all.select(m| Staff.all.exists(s| s.firstname=\"Daniel\" and s.teaches.includes(m)));","title":"Querying and Modifying Spreadsheets"},{"location":"doc/articles/excel/#creating-rows","text":"As discussed above, worksheets are treated as types and rows as their instances. As such, to create a new row in the Student worksheet, EOL's new operation can be used. var student : new Student;","title":"Creating Rows"},{"location":"doc/articles/excel/#deleting-rows","text":"To delete a row from a worksheet, EOL's delete operator can be used. When a row is deleted, all the rows that contain cells referring to it through cascade-update references also need to be recursively deleted. var student = Student.all.selectOne(s|s.id = \"js502\"); // deletes row 2 of the Student worksheet // also deletes row 3 of the Mark worksheet delete student;","title":"Deleting Rows"},{"location":"doc/articles/excel/#modifying-cell-values","text":"If a cell is single-valued, a type-conforming assignment can be used to edit its value. For example, the following listing demonstrates modifying the age and the supervisor of a particular student. var student : Student = ...; var supervisor : Staff = ...; student.age = 24; student.supervisor = supervisor; If on the other hand the cell is multi-valued, then its values should be handled as a collection. Adding/removing values from property collections has no effect on the spreadsheet; you need to re-assign values instead. // Moves a module between two members of staff var from : Staff = ...; var to : Staff = ...; var module : Module = ...; // Neither of these will work // from.teaches.remove(module); // to.teaches.add(module); // ... but these will from.teaches = from.teaches.excluding(module); to.teaches = to.teaches.including(module); Updating the value of a cell can have side effects to other cells that are linked to it through cascade-update references to preserve referential integrity. For example, updating the value of cell A3 in the Module worksheet, should trigger appropriate updates in cells D2 and F2 of the Staff and Student worksheets respectively.","title":"Modifying Cell Values"},{"location":"doc/articles/excel/#validating-and-transforming-spreadsheets","text":"Of course, we can also validate spreadsheets using EVL , transform them into other models using ETL , and into text using EGL , generate graphical views using Picto etc. context Staff { constraint NotOverloaded { check: self.teaches.size() <= 4 message: \"Member of staff\" + self.firstname + \" \" + self.lastname + \" is overloaded\" } }","title":"Validating and Transforming Spreadsheets"},{"location":"doc/articles/excel/#creating-spreadsheets","text":"To create a spreadsheet from scratch (e.g. when it is produced by an ETL transformation), we also need to specify an index for each column in the XML mapping file. Below is an EOL program that creates the spreadsheet above from scratch, and the mapping file for it. The complete example is in Epsilon's Git repo . create-spreadsheet.eol // Create the modules var MSD = new Module(id=\"MSD\", title=\"Modelling and System Design\", term=\"Autumn\"); var HCI = new Module(id=\"HCI\", title=\"Human Computer Interaction\", term=\"Spring\"); var RQE = new Module(id=\"RQE\", title=\"Requirements Engineering\", term=\"Spring\"); // Create the staff var matthew = new Staff(id=\"mt506\", firstname=\"Matthew\", lastname=\"Thomas\", teaches=Sequence{MSD, RQE}); var matthew = new Staff(id=\"dj503\", firstname=\"Daniel\", lastname=\"Jackson\", teaches=Sequence{HCI}); // Create the students var joe = new Student(id=\"jt501\", firstname=\"Joe\", lastname=\"Thompson\", age=\"23\", supervisor=matthew, modules=Sequence{MSD, RQE}); var jane = new Student(id=\"js502\", firstname=\"Jane\", lastname=\"Smith\", age=\"22\", supervisor=matthew, modules=Sequence{MSD, HCI}); // Create the marks new Mark(student=joe, module=MSD, mark=62); new Mark(student=jane, module=HCI, mark=74); mapping.xml <spreadsheet> <worksheet name= \"Student\" > <column index= \"0\" name= \"id\" /> <column index= \"1\" name= \"firstname\" /> <column index= \"2\" name= \"lastname\" /> <column index= \"3\" name= \"age\" datatype= \"integer\" /> <column index= \"4\" name= \"supervisor\" /> <column index= \"5\" name= \"modules\" many= \"true\" /> </worksheet> <worksheet name= \"Mark\" > <column index= \"0\" name= \"student\" /> <column index= \"1\" name= \"module\" /> <column index= \"2\" name= \"mark\" datatype= \"integer\" /> </worksheet> <worksheet name= \"Staff\" > <column index= \"0\" name= \"id\" /> <column index= \"1\" name= \"firstname\" /> <column index= \"2\" name= \"lastname\" /> <column index= \"3\" name= \"teaches\" many= \"true\" delimiter= \",\" /> </worksheet> <worksheet name= \"Module\" > <column index= \"0\" name= \"id\" /> <column index= \"1\" name= \"title\" /> <column index= \"2\" name= \"term\" /> </worksheet> <reference source= \"Student->supervisor\" target= \"Staff->id\" /> <reference source= \"Student->modules\" target= \"Module->id\" /> <reference source= \"Staff->teaches\" target= \"Module->id\" /> <reference source= \"Mark->module\" target= \"Module->id\" /> <reference source= \"Mark->student\" target= \"Student->id\" /> </spreadsheet>","title":"Creating Spreadsheets"},{"location":"doc/articles/excel/#working-with-formulas","text":"To set the value of a cell to a formula, start its value with = as shown below. The complete example is in Epsilon's Git repo . create-spreadsheet-with-formulas.eol var calc : new Calc; calc.a = 1; calc.b = 2; calc.sum = \"=A2+B2\"; calc.sum.println(); // Prints 3 mapping.xml <spreadsheet> <worksheet name= \"Calc\" > <column index= \"0\" name= \"a\" datatype= \"integer\" /> <column index= \"1\" name= \"b\" datatype= \"integer\" /> <column index= \"2\" name= \"sum\" datatype= \"integer\" /> </worksheet> </spreadsheet>","title":"Working with Formulas"},{"location":"doc/articles/excel/#reflective-access","text":"To iterate over all the worksheets, columns and rows of a speadsheet without referring to them by name, we can use the following statements (assuming that our Excel spreadsheet is named M in the run configuration). Additional methods of interest for this mode of access can be found in the Javadoc of the underlying ExcelModel and SpreadsheetModel classes. // Iterate over all worksheets for (w in M.worksheets) { w.name.println(); // Iterate over all columns // of the worksheet for (c in w.header.columns) { c.name.println(\"\\t\"); } // Iterate over all rows // of the worksheet for (r in w.rows) { r.println(\"\\t\"); } }","title":"Reflective Access"},{"location":"doc/articles/excel/#resources","text":"This article shows how to use Excel spreadsheets in ANT/Gradle/Maven builds.","title":"Resources"},{"location":"doc/articles/exercises/","text":"MDE Exercises \u00b6 This article provides a number of exercises you can use to test your knowledge on MDE, EMF and Epsilon. Exercise 1: Metamodelling with Ecore \u00b6 Write Ecore metamodels (using Emfatic or the graphical Ecore editor) for the following scenarios, and create instances of these metamodels using the reflective EMF tree editor : All school rooms have a buzzer triggered by a central clock to signal the end of the school day. Political parties, such as the Labour Party, the Conservative party, and the Liberal Democrat party, have both voters and supporters. An undirected graph consists of a set of vertices and a set of edges. Edges connect pairs of vertices. A football league has a set of teams, where each team has a manager and a set of players. A player is a forward, defender, or goalkeeper. The manager cannot be a player. A student is awarded a prize. Each prize is donated by at least one sponsor, e.g., IBM. A prize may be jointly awarded. Each student must write a letter thanking the sponsors of their prize Exercise 2: Constructing models programmatically using EOL \u00b6 In the previous exercise, you created sample models conforming to your metamodels using the reflective EMF tree editor. In this exercise, you should create the same models, but this time programmatically using EOL . Exercise 3: Introducing EOL operations \u00b6 The Office Management System (OMS) is used to manage the rooms available to a company. It keeps track of who is assigned to occupy a room, along with their position in the company. It facilitates providing newly hired employees with offices, and assists employees who are to move from one office to another. Employees have positions, an office (offices are never shared), and know when they started work at the company and when they ended their employment. The OMS keeps track of all employees and rooms. Rooms are either occupied or unoccupied.\\ With the OMS, it is possible to: hire a new employee and assign them to a room fire an employee and remove them from their office move an employee from one room to another, unoccupied room calculate the set of rooms that are unoccupied (useful for planning) With this scenario in mind you need to do the following: Write an Ecore metamodel for the system above Write the body of the following EOL operations that implement 1-4 above operation Employee hire() { ... } operation Employee fire() { ... } operation Employee move(to:Room) { ... } operation Company getFreeRooms() : Sequence(Room) { ... } Exercise 4: Model validation with EVL \u00b6 Construct the Ecore metamodel above and create a sample model that conforms to it using the reflective EMF tree editor. Write the following EVL constraints and evaluate them on your sample model In the context of class Student, write a constraint stating that a student takes up to 6 modules In the context of class Grade, write a constraint stating that the mark must always be non-negative. In the context of Module, write a constraint stating that every student must have a unique name. In the context of Student, write a constraint that states that the grades for the modules taken by a student must be identical to the grades that the student knows about directly Exercise 5: Model transformation with ETL \u00b6 Write an ETL transformation that transforms models conforming to the metamodel of Exercise 4 to models conforming to the metamodel below. Exercise 6: Text generation with EGL \u00b6 Write an EGL transformation that reads a model conforming to the metamodel of exercise 4 and produces a text file containing the names of all students and the total marks each student has obtained so far. Exercise 7: Multiple file generation with EGL \u00b6 Write an EGL transformation that reads a model conforming to the metamodel of exercise 5 and generates one file per transcript. Each output file should be named after the student with a .txt suffix (e.g. John Doe.txt) and it should contain a list of all the modules and marks of the student. Exercise 8: Using ANT to implement an ETL-EGL workflow \u00b6 Use the ANT tasks provided by Epsilon to create an ANT workflow that invokes the ETL transformation of Exercise 5 and then passes the produced model to the EGL transformation of Exercise 7, which in turn generates a set of transcript files. Exercise 9: Constructing graphical editors \u00b6 Create GMF editors for the metamodels you have written in the exercises above using Eugenia.","title":"MDE Exercises"},{"location":"doc/articles/exercises/#mde-exercises","text":"This article provides a number of exercises you can use to test your knowledge on MDE, EMF and Epsilon.","title":"MDE Exercises"},{"location":"doc/articles/exercises/#exercise-1-metamodelling-with-ecore","text":"Write Ecore metamodels (using Emfatic or the graphical Ecore editor) for the following scenarios, and create instances of these metamodels using the reflective EMF tree editor : All school rooms have a buzzer triggered by a central clock to signal the end of the school day. Political parties, such as the Labour Party, the Conservative party, and the Liberal Democrat party, have both voters and supporters. An undirected graph consists of a set of vertices and a set of edges. Edges connect pairs of vertices. A football league has a set of teams, where each team has a manager and a set of players. A player is a forward, defender, or goalkeeper. The manager cannot be a player. A student is awarded a prize. Each prize is donated by at least one sponsor, e.g., IBM. A prize may be jointly awarded. Each student must write a letter thanking the sponsors of their prize","title":"Exercise 1: Metamodelling with Ecore"},{"location":"doc/articles/exercises/#exercise-2-constructing-models-programmatically-using-eol","text":"In the previous exercise, you created sample models conforming to your metamodels using the reflective EMF tree editor. In this exercise, you should create the same models, but this time programmatically using EOL .","title":"Exercise 2: Constructing models programmatically using EOL"},{"location":"doc/articles/exercises/#exercise-3-introducing-eol-operations","text":"The Office Management System (OMS) is used to manage the rooms available to a company. It keeps track of who is assigned to occupy a room, along with their position in the company. It facilitates providing newly hired employees with offices, and assists employees who are to move from one office to another. Employees have positions, an office (offices are never shared), and know when they started work at the company and when they ended their employment. The OMS keeps track of all employees and rooms. Rooms are either occupied or unoccupied.\\ With the OMS, it is possible to: hire a new employee and assign them to a room fire an employee and remove them from their office move an employee from one room to another, unoccupied room calculate the set of rooms that are unoccupied (useful for planning) With this scenario in mind you need to do the following: Write an Ecore metamodel for the system above Write the body of the following EOL operations that implement 1-4 above operation Employee hire() { ... } operation Employee fire() { ... } operation Employee move(to:Room) { ... } operation Company getFreeRooms() : Sequence(Room) { ... }","title":"Exercise 3: Introducing EOL operations"},{"location":"doc/articles/exercises/#exercise-4-model-validation-with-evl","text":"Construct the Ecore metamodel above and create a sample model that conforms to it using the reflective EMF tree editor. Write the following EVL constraints and evaluate them on your sample model In the context of class Student, write a constraint stating that a student takes up to 6 modules In the context of class Grade, write a constraint stating that the mark must always be non-negative. In the context of Module, write a constraint stating that every student must have a unique name. In the context of Student, write a constraint that states that the grades for the modules taken by a student must be identical to the grades that the student knows about directly","title":"Exercise 4: Model validation with EVL"},{"location":"doc/articles/exercises/#exercise-5-model-transformation-with-etl","text":"Write an ETL transformation that transforms models conforming to the metamodel of Exercise 4 to models conforming to the metamodel below.","title":"Exercise 5: Model transformation with ETL"},{"location":"doc/articles/exercises/#exercise-6-text-generation-with-egl","text":"Write an EGL transformation that reads a model conforming to the metamodel of exercise 4 and produces a text file containing the names of all students and the total marks each student has obtained so far.","title":"Exercise 6: Text generation with EGL"},{"location":"doc/articles/exercises/#exercise-7-multiple-file-generation-with-egl","text":"Write an EGL transformation that reads a model conforming to the metamodel of exercise 5 and generates one file per transcript. Each output file should be named after the student with a .txt suffix (e.g. John Doe.txt) and it should contain a list of all the modules and marks of the student.","title":"Exercise 7: Multiple file generation with EGL"},{"location":"doc/articles/exercises/#exercise-8-using-ant-to-implement-an-etl-egl-workflow","text":"Use the ANT tasks provided by Epsilon to create an ANT workflow that invokes the ETL transformation of Exercise 5 and then passes the produced model to the EGL transformation of Exercise 7, which in turn generates a set of transcript files.","title":"Exercise 8: Using ANT to implement an ETL-EGL workflow"},{"location":"doc/articles/exercises/#exercise-9-constructing-graphical-editors","text":"Create GMF editors for the metamodels you have written in the exercises above using Eugenia.","title":"Exercise 9: Constructing graphical editors"},{"location":"doc/articles/extended-properties/","text":"Extended Properties \u00b6 This article demonstrates the extended properties mechanism in EOL (and by inheritance, in all languages in Epsilon). We present the rationale and semantics of extended properties using the following simple metamodel (in Emfatic): package SimpleTree; class Tree { attr String name; ref Tree#children parent; val Tree[*]#parent children; } Now, what we want to do is to traverse a model that conforms to this metamodel and calculate and print the depth of each Tree in it. We can do this using this simple EOL program: var depths = new Map; for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + depths.get(n)).println(); } operation Tree setDepth(depth : Integer) { depths.put(self,depth); for (c in self.children) { c.setDepth(depth + 1); } } Because the Tree EClass doesn't have a depth property, we have to use the depths Map to store the calculated depth of each Tree . Another solution would be to add a depth property to the Tree EClass so that its instances can store such information; but following this approach will soon pollute our metamodel with information of secondary importance. We've often come across similar situations where we needed to attach some kind of information (that is not supported by the metamodel) to particular model elements during model management operations (validation, transformation etc.). Until now, we've been using Maps to achieve this (similarly to what we've done above). However, now, EOL (and all languages built atop it) support non-invasive extended properties which provide a more elegant solution to this recurring problem. An extended property is a property that starts with the ~ character. Its semantics are quite straightforward: the first time a value is assigned to an extended property of an object (e.g. x.~a := b; ), the property is created and associated to the object and the value is assigned to it. Similarly, x.~a returns the value of the property or undefined if the property has not been set on the particular object yet. Using extended properties, we can rewrite the above code (without needing to use a Map ) as follows: for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + n.~depth).println(); } operation Tree setDepth(depth : Integer) { self.~depth = depth; for (c in self.children) { c.setDepth(depth + 1); } }","title":"Extended Properties"},{"location":"doc/articles/extended-properties/#extended-properties","text":"This article demonstrates the extended properties mechanism in EOL (and by inheritance, in all languages in Epsilon). We present the rationale and semantics of extended properties using the following simple metamodel (in Emfatic): package SimpleTree; class Tree { attr String name; ref Tree#children parent; val Tree[*]#parent children; } Now, what we want to do is to traverse a model that conforms to this metamodel and calculate and print the depth of each Tree in it. We can do this using this simple EOL program: var depths = new Map; for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + depths.get(n)).println(); } operation Tree setDepth(depth : Integer) { depths.put(self,depth); for (c in self.children) { c.setDepth(depth + 1); } } Because the Tree EClass doesn't have a depth property, we have to use the depths Map to store the calculated depth of each Tree . Another solution would be to add a depth property to the Tree EClass so that its instances can store such information; but following this approach will soon pollute our metamodel with information of secondary importance. We've often come across similar situations where we needed to attach some kind of information (that is not supported by the metamodel) to particular model elements during model management operations (validation, transformation etc.). Until now, we've been using Maps to achieve this (similarly to what we've done above). However, now, EOL (and all languages built atop it) support non-invasive extended properties which provide a more elegant solution to this recurring problem. An extended property is a property that starts with the ~ character. Its semantics are quite straightforward: the first time a value is assigned to an extended property of an object (e.g. x.~a := b; ), the property is created and associated to the object and the value is assigned to it. Similarly, x.~a returns the value of the property or undefined if the property has not been set on the particular object yet. Using extended properties, we can rewrite the above code (without needing to use a Map ) as follows: for (n in Tree.allInstances.select(t|not t.parent.isDefined())) { n.setDepth(0); } for (n in Tree.allInstances) { (n.name + \" \" + n.~depth).println(); } operation Tree setDepth(depth : Integer) { self.~depth = depth; for (c in self.children) { c.setDepth(depth + 1); } }","title":"Extended Properties"},{"location":"doc/articles/html/","text":"Scripting HTML Documents using Epsilon \u00b6 In this article we demonstrate how you can create, query and modify HTML documents in Epsilon programs using the HTML driver. All the examples in this article demonstrate using EOL to script HTML documents. However, it's worth stressing that HTML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models or to text), compare and merge your HTML documents. Querying a HTML document \u00b6 We use the following sales.html as a base for demonstrating the EOL syntax for querying HTML documents. < html > < body > < table border = \"1\" > < thead > < tr > < th > Product id </ th > < th > Unit price </ th > < th > Quantity </ th > </ tr > </ thead > < tbody > < tr > < td > P1 </ td > < td > 10 </ td > < td > 15 </ td > </ tr > < tr > < td > P2 </ td > < td > 8 </ td > < td > 12 </ td > </ tr > </ tbody > </ table > </ body > </ html > Querying/modifying HTML documents in EOL \u00b6 The HTML driver uses predefined naming conventions to allow developers to programmatically access and modify HTML documents in a concise way. This section outlines the supported conventions in the form of questions and answers followed by relevant examples. How can I access elements by tag name? \u00b6 The t_ prefix in front of the name of the tag is used to represent a type, instances of which are all the elements with that tag. For instance, t_td.all can be used to get all elements tagged as <td> (table cells) in the document, t_tr.all to retrieve all <tr> elements (table rows) etc. Also, if cell is an element with a <td> tag, then cell.isTypeOf(t_td) shall return true. // Get all <td> elements var cells = t_td.all; // Get a random table cell var cell = cells.random(); // Check if cell is a td // Prints 'true' cell.isTypeOf(t_td).println(); // Check if cell is a tr // Prints 'false' cell.isTypeOf(t_tr).println(); How can I get the tag name of an element? \u00b6 You can use the .tagName property for this purpose. For instance, if cell is an element tagged as <td> , cell.tagName shall return td . The tagName property is read-only. // Get a random <td> element var cell = t_td.all.random(); // Print its tag // Prints 'td' cell.tagName.println(); How can I get/set the attributes of an element? \u00b6 You can use the attribute name as a property of the element object, prefixed by a_ . For example, if t is the first table of sales.html , t.a_border will return 1 . Attribute properties are read/write. In this example, t.a_border will return 1 as a string. For 1 to be returned as an integer instead, the i_ prefix should be used instead (i.e. t.i_border . The driver also supports the following preffixes: b_ for boolean, s_ for string (alias of a_ ) and r_ for real values. // Get the one and only table in the document var table = t_table.all.first(); // Prints 11 (the border attribute is retrieved as string) (table.a_border + 1).println(); // Prints 2 (the border attribute is retrieved as integer) (table.i_border + 1).println(); How can I get/set the text of an element? \u00b6 You can use the .text read-write property for this. for (cell in t_td.all) { cell.text.println(); } How do I get the parent of an element? \u00b6 You can use the .parentNode read-only property to retrieve the element's immediate parent and the .parents. read-only property to retrieve all the ancestors of the element. // Get a random cell var cell = t_td.all.random(); // Print the tag of its parent node // Prints 'tr' cell.parentNode.tagName.println(); // Print the tags of all its ancestors // Prints 'Sequence {tr, tbody, table, body, html}' cell.parents.tagName.println(); How do I get the children of an element? \u00b6 You can use the .children read-only property for this. // Get the <tbody> element var tbody = t_tbody.all.first(); // Iterate through its children for (tr in tbody.children) { // Print the tag of each child tr.tagName.println(); } How do I get child elements with a specific tag name? \u00b6 Using what you've learned so far, you can do this using a combination of the .children property and the select/selectOne() operations. However, the driver also supports e_ and c_ -prefixed shorthand properties for accessing one or a collection of elements with the specified name respectively. e_ and c_ properties are read-only. // Get a random tr var row = t_tr.all.random(); // Get its <td> children using the // .children property var cells = row.children.select(a|a.tagName = \"td\"); // Do the same using the shorthand cells = row.c_td; // Get the first td child of the row row.e_td.text.println(); How do I create an element? \u00b6 You can use the new operator for this. // Check how many <tr> are in the document // Prints '3' t_tr.all.size().println(); // Creates a new tr element var row = new t_tr; // Check again // Prints '4' t_tr.all.size().println(); How can I add a child to an existing element? \u00b6 You can use the .appendChild(child) operation for this. // Create a new row var row = new t_tr; // Get the tbody element var tbody = t_tbody.all.first(); // Add the book to the library tbody.appendChild(row); Bringing it all together \u00b6 The following snippet computes and prints the total sales revenue. var table = t_table.all.first(); var sum : Real; // Iterate only through the rows under tbody for (tr in table.e_tbody.c_tr) { sum = sum + tr.c_td.at(1).getRealValue() * tr.c_td.at(2).getRealValue(); } // Prints 246.0 sum.println(); operation t_td getRealValue() { return self.text.asReal(); } Adding a HTML document to your launch configuration \u00b6 To add a HTML document to your Epsilon launch configuration, you need to select \"HTML document\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load a HTML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full uri for your document (e.g. http://www.google.com or file:/c:/myhtml.html ). Loading a HTML document in your ANT buildfile \u00b6 The following ANT build file demonstrates how you can use ANT to load/store and process HTML documents with Epsilon. <project default= \"main\" > <target name= \"main\" > <epsilon.loadModel name= \"M\" type= \"HTML\" > <parameter name= \"readOnLoad\" value= \"true\" /> <parameter name= \"storeOnDisposal\" value= \"false\" /> <parameter name= \"file\" file= \"sales.html\" /> </epsilon.loadModel> <epsilon.eol src= \"sales.eol\" > <model ref= \"M\" /> </epsilon.eol> </target> </project> Loading a HTML document through Java code \u00b6 The following excerpt demonstrates using HTML models using Epsilon's Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); HtmlModel model = new HtmlModel (); model . setName ( \"M\" ); model . setFile ( new File ( \"...\" )); model . load (); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute (); Loading a remote HTML document in Gradle \u00b6 The example below shows a standalone Gradle file ( build.gradle ) that runs a set of EOL queries ( queries.eol ) against the HTML behind the Epsilon homepage. build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.3.0-SNAPSHOT' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.emc.html:2.3.0-SNAPSHOT' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the eclipse.org/epsilon webpage as a HTML model ant . 'epsilon.loadModel' ( name: 'HTML' , type: 'HTML' , impl: 'org.eclipse.epsilon.emc.html.HtmlModel' ,) { parameter ( name: 'uri' , value: 'https://www.eclipse.org/epsilon/' ) } // Run query.eol against it ant . 'epsilon.eol' ( src: 'queries.eol' ){ model ( ref: 'HTML' ) } } queries.eol // Print the text of all <strong> elements for (s in t_strong.all) { s.text().println(); } // Print all links that point to external websites for (link in t_a.all) { if (link.a_href.startsWith(\"http\")) { link.a_href.println(); } } // Print the text of all <li> elements which are // children of the <ul> that's the first sibling // of the \"Why Epsilon?\" <h2> var whyEpsilon = t_h2.all.selectOne(h2|h2.text.startsWith(\"Why Epsilon\")); var ul = whyEpsilon.nextElementSibling(); for (li in ul.c_li) { li.text.println(); } Additional resources \u00b6 The Epsilon HTML driver leverages the excellent Jsoup HTML parser. In fact, all elements returned via EOL queries are instances of the org.jsoup.nodes.Element class and as such, all methods of the class can be invoked on them through EOL.","title":"Scripting HTML Documents using Epsilon"},{"location":"doc/articles/html/#scripting-html-documents-using-epsilon","text":"In this article we demonstrate how you can create, query and modify HTML documents in Epsilon programs using the HTML driver. All the examples in this article demonstrate using EOL to script HTML documents. However, it's worth stressing that HTML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models or to text), compare and merge your HTML documents.","title":"Scripting HTML Documents using Epsilon"},{"location":"doc/articles/html/#querying-a-html-document","text":"We use the following sales.html as a base for demonstrating the EOL syntax for querying HTML documents. < html > < body > < table border = \"1\" > < thead > < tr > < th > Product id </ th > < th > Unit price </ th > < th > Quantity </ th > </ tr > </ thead > < tbody > < tr > < td > P1 </ td > < td > 10 </ td > < td > 15 </ td > </ tr > < tr > < td > P2 </ td > < td > 8 </ td > < td > 12 </ td > </ tr > </ tbody > </ table > </ body > </ html >","title":"Querying a HTML document"},{"location":"doc/articles/html/#queryingmodifying-html-documents-in-eol","text":"The HTML driver uses predefined naming conventions to allow developers to programmatically access and modify HTML documents in a concise way. This section outlines the supported conventions in the form of questions and answers followed by relevant examples.","title":"Querying/modifying HTML documents in EOL"},{"location":"doc/articles/html/#how-can-i-access-elements-by-tag-name","text":"The t_ prefix in front of the name of the tag is used to represent a type, instances of which are all the elements with that tag. For instance, t_td.all can be used to get all elements tagged as <td> (table cells) in the document, t_tr.all to retrieve all <tr> elements (table rows) etc. Also, if cell is an element with a <td> tag, then cell.isTypeOf(t_td) shall return true. // Get all <td> elements var cells = t_td.all; // Get a random table cell var cell = cells.random(); // Check if cell is a td // Prints 'true' cell.isTypeOf(t_td).println(); // Check if cell is a tr // Prints 'false' cell.isTypeOf(t_tr).println();","title":"How can I access elements by tag name?"},{"location":"doc/articles/html/#how-can-i-get-the-tag-name-of-an-element","text":"You can use the .tagName property for this purpose. For instance, if cell is an element tagged as <td> , cell.tagName shall return td . The tagName property is read-only. // Get a random <td> element var cell = t_td.all.random(); // Print its tag // Prints 'td' cell.tagName.println();","title":"How can I get the tag name of an element?"},{"location":"doc/articles/html/#how-can-i-getset-the-attributes-of-an-element","text":"You can use the attribute name as a property of the element object, prefixed by a_ . For example, if t is the first table of sales.html , t.a_border will return 1 . Attribute properties are read/write. In this example, t.a_border will return 1 as a string. For 1 to be returned as an integer instead, the i_ prefix should be used instead (i.e. t.i_border . The driver also supports the following preffixes: b_ for boolean, s_ for string (alias of a_ ) and r_ for real values. // Get the one and only table in the document var table = t_table.all.first(); // Prints 11 (the border attribute is retrieved as string) (table.a_border + 1).println(); // Prints 2 (the border attribute is retrieved as integer) (table.i_border + 1).println();","title":"How can I get/set the attributes of an element?"},{"location":"doc/articles/html/#how-can-i-getset-the-text-of-an-element","text":"You can use the .text read-write property for this. for (cell in t_td.all) { cell.text.println(); }","title":"How can I get/set the text of an element?"},{"location":"doc/articles/html/#how-do-i-get-the-parent-of-an-element","text":"You can use the .parentNode read-only property to retrieve the element's immediate parent and the .parents. read-only property to retrieve all the ancestors of the element. // Get a random cell var cell = t_td.all.random(); // Print the tag of its parent node // Prints 'tr' cell.parentNode.tagName.println(); // Print the tags of all its ancestors // Prints 'Sequence {tr, tbody, table, body, html}' cell.parents.tagName.println();","title":"How do I get the parent of an element?"},{"location":"doc/articles/html/#how-do-i-get-the-children-of-an-element","text":"You can use the .children read-only property for this. // Get the <tbody> element var tbody = t_tbody.all.first(); // Iterate through its children for (tr in tbody.children) { // Print the tag of each child tr.tagName.println(); }","title":"How do I get the children of an element?"},{"location":"doc/articles/html/#how-do-i-get-child-elements-with-a-specific-tag-name","text":"Using what you've learned so far, you can do this using a combination of the .children property and the select/selectOne() operations. However, the driver also supports e_ and c_ -prefixed shorthand properties for accessing one or a collection of elements with the specified name respectively. e_ and c_ properties are read-only. // Get a random tr var row = t_tr.all.random(); // Get its <td> children using the // .children property var cells = row.children.select(a|a.tagName = \"td\"); // Do the same using the shorthand cells = row.c_td; // Get the first td child of the row row.e_td.text.println();","title":"How do I get child elements with a specific tag name?"},{"location":"doc/articles/html/#how-do-i-create-an-element","text":"You can use the new operator for this. // Check how many <tr> are in the document // Prints '3' t_tr.all.size().println(); // Creates a new tr element var row = new t_tr; // Check again // Prints '4' t_tr.all.size().println();","title":"How do I create an element?"},{"location":"doc/articles/html/#how-can-i-add-a-child-to-an-existing-element","text":"You can use the .appendChild(child) operation for this. // Create a new row var row = new t_tr; // Get the tbody element var tbody = t_tbody.all.first(); // Add the book to the library tbody.appendChild(row);","title":"How can I add a child to an existing element?"},{"location":"doc/articles/html/#bringing-it-all-together","text":"The following snippet computes and prints the total sales revenue. var table = t_table.all.first(); var sum : Real; // Iterate only through the rows under tbody for (tr in table.e_tbody.c_tr) { sum = sum + tr.c_td.at(1).getRealValue() * tr.c_td.at(2).getRealValue(); } // Prints 246.0 sum.println(); operation t_td getRealValue() { return self.text.asReal(); }","title":"Bringing it all together"},{"location":"doc/articles/html/#adding-a-html-document-to-your-launch-configuration","text":"To add a HTML document to your Epsilon launch configuration, you need to select \"HTML document\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load a HTML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full uri for your document (e.g. http://www.google.com or file:/c:/myhtml.html ).","title":"Adding a HTML document to your launch configuration"},{"location":"doc/articles/html/#loading-a-html-document-in-your-ant-buildfile","text":"The following ANT build file demonstrates how you can use ANT to load/store and process HTML documents with Epsilon. <project default= \"main\" > <target name= \"main\" > <epsilon.loadModel name= \"M\" type= \"HTML\" > <parameter name= \"readOnLoad\" value= \"true\" /> <parameter name= \"storeOnDisposal\" value= \"false\" /> <parameter name= \"file\" file= \"sales.html\" /> </epsilon.loadModel> <epsilon.eol src= \"sales.eol\" > <model ref= \"M\" /> </epsilon.eol> </target> </project>","title":"Loading a HTML document in your ANT buildfile"},{"location":"doc/articles/html/#loading-a-html-document-through-java-code","text":"The following excerpt demonstrates using HTML models using Epsilon's Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); HtmlModel model = new HtmlModel (); model . setName ( \"M\" ); model . setFile ( new File ( \"...\" )); model . load (); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute ();","title":"Loading a HTML document through Java code"},{"location":"doc/articles/html/#loading-a-remote-html-document-in-gradle","text":"The example below shows a standalone Gradle file ( build.gradle ) that runs a set of EOL queries ( queries.eol ) against the HTML behind the Epsilon homepage. build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.3.0-SNAPSHOT' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.emc.html:2.3.0-SNAPSHOT' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the eclipse.org/epsilon webpage as a HTML model ant . 'epsilon.loadModel' ( name: 'HTML' , type: 'HTML' , impl: 'org.eclipse.epsilon.emc.html.HtmlModel' ,) { parameter ( name: 'uri' , value: 'https://www.eclipse.org/epsilon/' ) } // Run query.eol against it ant . 'epsilon.eol' ( src: 'queries.eol' ){ model ( ref: 'HTML' ) } } queries.eol // Print the text of all <strong> elements for (s in t_strong.all) { s.text().println(); } // Print all links that point to external websites for (link in t_a.all) { if (link.a_href.startsWith(\"http\")) { link.a_href.println(); } } // Print the text of all <li> elements which are // children of the <ul> that's the first sibling // of the \"Why Epsilon?\" <h2> var whyEpsilon = t_h2.all.selectOne(h2|h2.text.startsWith(\"Why Epsilon\")); var ul = whyEpsilon.nextElementSibling(); for (li in ul.c_li) { li.text.println(); }","title":"Loading a remote HTML document in Gradle"},{"location":"doc/articles/html/#additional-resources","text":"The Epsilon HTML driver leverages the excellent Jsoup HTML parser. In fact, all elements returned via EOL queries are instances of the org.jsoup.nodes.Element class and as such, all methods of the class can be invoked on them through EOL.","title":"Additional resources"},{"location":"doc/articles/hutn-basic/","text":"Using the Human-Usable Textual Notation (HUTN) in Epsilon \u00b6 In this article we demonstrate how you can use a textual notation to create models using the Human-Usable Textual Notation (HUTN) implementation provided by Epsilon. Please note that, currently, HUTN works only with EMF, and cannot be used to create models for other modelling technologies, such as MDR or plain XML. Getting started \u00b6 To create a model with HUTN, we first need to define our metamodel. In this example, we'll use the Families metamodel shown below: Once we have created your metamodel and registered it with Epsilon, we create a new HUTN document by clicking File\u2192New\u2192Other... and selecting HUTN File . The metamodel nsuri field should contain the namespace URI of our metamodel: families Epsilon will initialise a HUTN file for our metamodel (as shown below). We can now specify and then generate our model. @Spec { metamodel \"families\" { nsUri: \"families\" } } families { // Place your model element specifications here } HUTN Syntax \u00b6 We now briefly describe the HUTN syntax. We can specify an instance of Family using the following HUTN: Family { name: \"The Smiths\" lotteryNumbers: 10, 24, 26, 32, 45, 49 } Note that multi-valued features can be specified using a comma separated list. Containment references \u00b6 Containment references are specified by nesting model element definitions. For example, the following HUTN specifies two members, John and Jane of the Smiths: Family { name: \"The Smiths\" lotteryNumbers: 10, 24, 26, 32, 45, 49 members: Person { name: \"John Smith\" }, Person { name: \"Jane Smith\" } } Non-containment references \u00b6 Non-containment references are specified using a HUTN identifier, which is the string appearing in double-quotes as part of an object\\'s declaraton. Below, the second Family has the identifier \"bloggs.\" In the following HUTN, The first family references the second family, using the familyFriends reference: Family { familyFriends: Family \"bloggs\" } Family \"bloggs\" {} Cross-model references \u00b6 References to model elements stored in another file are using a URI fragment: Family { familyFriends: Family \"../families/AnotherNeighbourhood.model#/1/\" familyFriends: Family \"../families/AnotherNeighbourhood.model#_swAAYJX5Ed2TbbKclPHPaA\" } URI fragments can have either a relative (XPath-like) syntax, or use a unique identifier. For example, the first reference above uses a relative syntax to refer to the second (index of 1) Family in the AnotherNeighbourhood.model file. For more information on URI fragments, see section 13.2.1 of the EMF book . Shortcuts \u00b6 There are some syntactic shortcuts in HUTN, which we now demonstrate. Objects do not have to specify a body, and can instead be terminated with a semi-colon: Family {} // is equivalent to: Family; Although boolean-valued attributes can be specified using true or false values, they can also be specified as a prefix on the model element definition: Family { nuclear: false migrant: true } // is equivalent to: ~nuclear migrant Family; Non-containment references can be specified using association blocks or even with an infix notation: Family { familyFriends: Family \"bloggs\" } Family \"bloggs\"; // is equivalent to the following association block Family \"smiths\"; Family \"bloggs\"; familyFriends { \"smiths\" \"bloggs\" // More familyFriends can be specified here } // is equivalent to the following infix notation: Family \"smiths\"; Family \"bloggs\"; Family \"smiths\" familyFriends Family \"bloggs\"; Generating a model from HUTN \u00b6 When we have finished specifying our HUTN, we can generate a corresponding model. Right-click the HUTN document and select HUTN\u2192Generate Model , as shown below Epsilon can automatically generate a model whenever you change your HUTN file. Right-click your project and select HUTN\u2192Enable HUTN Project Nature . This is illustrated in the following screenshot: Additional resources \u00b6 http://www.omg.org/spec/HUTN/ : The OMG HUTN specification. http://dx.doi.org/10.1007/978-3-540-87875-9_18 : Our MoDELS/UML 2008 paper on the HUTN implementation provided by Epsilon.","title":"Using the Human-Usable Textual Notation (HUTN) in Epsilon"},{"location":"doc/articles/hutn-basic/#using-the-human-usable-textual-notation-hutn-in-epsilon","text":"In this article we demonstrate how you can use a textual notation to create models using the Human-Usable Textual Notation (HUTN) implementation provided by Epsilon. Please note that, currently, HUTN works only with EMF, and cannot be used to create models for other modelling technologies, such as MDR or plain XML.","title":"Using the Human-Usable Textual Notation (HUTN) in Epsilon"},{"location":"doc/articles/hutn-basic/#getting-started","text":"To create a model with HUTN, we first need to define our metamodel. In this example, we'll use the Families metamodel shown below: Once we have created your metamodel and registered it with Epsilon, we create a new HUTN document by clicking File\u2192New\u2192Other... and selecting HUTN File . The metamodel nsuri field should contain the namespace URI of our metamodel: families Epsilon will initialise a HUTN file for our metamodel (as shown below). We can now specify and then generate our model. @Spec { metamodel \"families\" { nsUri: \"families\" } } families { // Place your model element specifications here }","title":"Getting started"},{"location":"doc/articles/hutn-basic/#hutn-syntax","text":"We now briefly describe the HUTN syntax. We can specify an instance of Family using the following HUTN: Family { name: \"The Smiths\" lotteryNumbers: 10, 24, 26, 32, 45, 49 } Note that multi-valued features can be specified using a comma separated list.","title":"HUTN Syntax"},{"location":"doc/articles/hutn-basic/#containment-references","text":"Containment references are specified by nesting model element definitions. For example, the following HUTN specifies two members, John and Jane of the Smiths: Family { name: \"The Smiths\" lotteryNumbers: 10, 24, 26, 32, 45, 49 members: Person { name: \"John Smith\" }, Person { name: \"Jane Smith\" } }","title":"Containment references"},{"location":"doc/articles/hutn-basic/#non-containment-references","text":"Non-containment references are specified using a HUTN identifier, which is the string appearing in double-quotes as part of an object\\'s declaraton. Below, the second Family has the identifier \"bloggs.\" In the following HUTN, The first family references the second family, using the familyFriends reference: Family { familyFriends: Family \"bloggs\" } Family \"bloggs\" {}","title":"Non-containment references"},{"location":"doc/articles/hutn-basic/#cross-model-references","text":"References to model elements stored in another file are using a URI fragment: Family { familyFriends: Family \"../families/AnotherNeighbourhood.model#/1/\" familyFriends: Family \"../families/AnotherNeighbourhood.model#_swAAYJX5Ed2TbbKclPHPaA\" } URI fragments can have either a relative (XPath-like) syntax, or use a unique identifier. For example, the first reference above uses a relative syntax to refer to the second (index of 1) Family in the AnotherNeighbourhood.model file. For more information on URI fragments, see section 13.2.1 of the EMF book .","title":"Cross-model references"},{"location":"doc/articles/hutn-basic/#shortcuts","text":"There are some syntactic shortcuts in HUTN, which we now demonstrate. Objects do not have to specify a body, and can instead be terminated with a semi-colon: Family {} // is equivalent to: Family; Although boolean-valued attributes can be specified using true or false values, they can also be specified as a prefix on the model element definition: Family { nuclear: false migrant: true } // is equivalent to: ~nuclear migrant Family; Non-containment references can be specified using association blocks or even with an infix notation: Family { familyFriends: Family \"bloggs\" } Family \"bloggs\"; // is equivalent to the following association block Family \"smiths\"; Family \"bloggs\"; familyFriends { \"smiths\" \"bloggs\" // More familyFriends can be specified here } // is equivalent to the following infix notation: Family \"smiths\"; Family \"bloggs\"; Family \"smiths\" familyFriends Family \"bloggs\";","title":"Shortcuts"},{"location":"doc/articles/hutn-basic/#generating-a-model-from-hutn","text":"When we have finished specifying our HUTN, we can generate a corresponding model. Right-click the HUTN document and select HUTN\u2192Generate Model , as shown below Epsilon can automatically generate a model whenever you change your HUTN file. Right-click your project and select HUTN\u2192Enable HUTN Project Nature . This is illustrated in the following screenshot:","title":"Generating a model from HUTN"},{"location":"doc/articles/hutn-basic/#additional-resources","text":"http://www.omg.org/spec/HUTN/ : The OMG HUTN specification. http://dx.doi.org/10.1007/978-3-540-87875-9_18 : Our MoDELS/UML 2008 paper on the HUTN implementation provided by Epsilon.","title":"Additional resources"},{"location":"doc/articles/hutn-compliance/","text":"Compliance of Epsilon HUTN to the OMG Standard \u00b6 Epsilon HUTN is an implementation of the OMG HUTN standard . Epsilon HUTN implements most of the OMG standard, but there are some differences between the two. This article summaries the similarities and differences between Epsilon HUTN and the OMG HUTN standard. Feature Section of the OMG HUTN Standard Supported in Epsilon HUTN? Details of support in Epsilon HUTN Packages Section 6.2 Yes Classes Section 6.3 Partial Epsilon HUTN provides an extra syntactic shortcut. Not yet supported: parametric attributes and enumeration adjectives. Attributes Section 6.4 Yes Epsilon HUTN corrects a mistake in the HUTN standard. References Sections 6.5 and 6.8 Yes Limitation: Epsilon HUTN only allows absolute references for non-containment features. Classifier-Level Attributes Section 6.6 Yes Data values Section 6.7 Yes Epsilon HUTN supports Ecore (EMF) types, rather than MOF types. Inline configuration Section 6.9 No A configuration model is used instead. Configuration rules Section 5 Partial Currently supported: IdentifierConfig and DefaultValueConfig rules. Extra Object Shorthand \u00b6 Epsilon HUTN allows classes with no body to be terminated with a semi-colon rather than with a pair of empty brackets, for example the following are equivalent in Epsilon HUTN: Family \"The Smiths\" {} Family \"The Smiths\"; This form appears in Figure 6.5 of the HUTN specification, but oddly is not supported in the grammar provided by the HUTN specification. Parametric Attributes \u00b6 The HUTN specification allows classes to be instantiated with arguments, for example: Coordinate (3.5, 7.3) {} The above code assumes that configuration rules have been specified for the parameters of Coordinate. Epsilon HUTN does not currently support this form. Instead, the following code can be used: Coordinate { x: 3.5 y: 7.3 } Enumeration Adjectives \u00b6 The HUTN specification allows objects to be prefixed with enumeration values as adjectives, for example: poodle Dog {} The above code assumes that configuration rules have been specified to configure Dog to accept a feature, \"breed,\" as an enumeration adjective. Epsilon HUTN does not currently support this form. Instead, the following code can be used: Dog { breed: poodle } Potential error in the OMG HUTN Specification \u00b6 Section 6.4 of the OMG HUTN specification appears to contain an error. Grammar rule [20] implies that AttributeName is optional in specifying a KeywordAttribute. However, the semantics of an empty KeywordAttribute or a single tilde as a KeywordAttribute are not defined. Epsilon HUTN ensures that an AttributeName is specified for every KeywordAttribute. Absolute References \u00b6 The HUTN specification allows relative referencing for non-containment references. For example: ShapePackage \"triangles\" { Polygon \"my_triangle\" { Coordinate (3.6, 7.3) {} Coordinate (5.2, 7.6) {} Coordinate (9.4, 13) {} } } ShapePackage \"lines\" { Polygon \"my_line\" { Coordinate (4.6, 78.3) {} Coordinate (10.4, 1.5) {} } Diagram \"my_diagram\" { shapes: \"//triangles/my_triangle\", \"/my_line\" } } The Diagram object references two Polygons: \"my_triangle\" and \"my line\". The first is referenced with respect to the root of the document (\"//\"), while the second is referenced with respect to the current package (\"/\"). Epsilon HUTN does not support relative referencing, and all references are resolved with respect to the diagram root. The \"//\" prefix is omitted: Diagram \"my_diagram\" { shapes: \"my_triangle\", \"my_line\" }","title":"Compliance of Epsilon HUTN to the OMG Standard"},{"location":"doc/articles/hutn-compliance/#compliance-of-epsilon-hutn-to-the-omg-standard","text":"Epsilon HUTN is an implementation of the OMG HUTN standard . Epsilon HUTN implements most of the OMG standard, but there are some differences between the two. This article summaries the similarities and differences between Epsilon HUTN and the OMG HUTN standard. Feature Section of the OMG HUTN Standard Supported in Epsilon HUTN? Details of support in Epsilon HUTN Packages Section 6.2 Yes Classes Section 6.3 Partial Epsilon HUTN provides an extra syntactic shortcut. Not yet supported: parametric attributes and enumeration adjectives. Attributes Section 6.4 Yes Epsilon HUTN corrects a mistake in the HUTN standard. References Sections 6.5 and 6.8 Yes Limitation: Epsilon HUTN only allows absolute references for non-containment features. Classifier-Level Attributes Section 6.6 Yes Data values Section 6.7 Yes Epsilon HUTN supports Ecore (EMF) types, rather than MOF types. Inline configuration Section 6.9 No A configuration model is used instead. Configuration rules Section 5 Partial Currently supported: IdentifierConfig and DefaultValueConfig rules.","title":"Compliance of Epsilon HUTN to the OMG Standard"},{"location":"doc/articles/hutn-compliance/#extra-object-shorthand","text":"Epsilon HUTN allows classes with no body to be terminated with a semi-colon rather than with a pair of empty brackets, for example the following are equivalent in Epsilon HUTN: Family \"The Smiths\" {} Family \"The Smiths\"; This form appears in Figure 6.5 of the HUTN specification, but oddly is not supported in the grammar provided by the HUTN specification.","title":"Extra Object Shorthand"},{"location":"doc/articles/hutn-compliance/#parametric-attributes","text":"The HUTN specification allows classes to be instantiated with arguments, for example: Coordinate (3.5, 7.3) {} The above code assumes that configuration rules have been specified for the parameters of Coordinate. Epsilon HUTN does not currently support this form. Instead, the following code can be used: Coordinate { x: 3.5 y: 7.3 }","title":"Parametric Attributes"},{"location":"doc/articles/hutn-compliance/#enumeration-adjectives","text":"The HUTN specification allows objects to be prefixed with enumeration values as adjectives, for example: poodle Dog {} The above code assumes that configuration rules have been specified to configure Dog to accept a feature, \"breed,\" as an enumeration adjective. Epsilon HUTN does not currently support this form. Instead, the following code can be used: Dog { breed: poodle }","title":"Enumeration Adjectives"},{"location":"doc/articles/hutn-compliance/#potential-error-in-the-omg-hutn-specification","text":"Section 6.4 of the OMG HUTN specification appears to contain an error. Grammar rule [20] implies that AttributeName is optional in specifying a KeywordAttribute. However, the semantics of an empty KeywordAttribute or a single tilde as a KeywordAttribute are not defined. Epsilon HUTN ensures that an AttributeName is specified for every KeywordAttribute.","title":"Potential error in the OMG HUTN Specification"},{"location":"doc/articles/hutn-compliance/#absolute-references","text":"The HUTN specification allows relative referencing for non-containment references. For example: ShapePackage \"triangles\" { Polygon \"my_triangle\" { Coordinate (3.6, 7.3) {} Coordinate (5.2, 7.6) {} Coordinate (9.4, 13) {} } } ShapePackage \"lines\" { Polygon \"my_line\" { Coordinate (4.6, 78.3) {} Coordinate (10.4, 1.5) {} } Diagram \"my_diagram\" { shapes: \"//triangles/my_triangle\", \"/my_line\" } } The Diagram object references two Polygons: \"my_triangle\" and \"my line\". The first is referenced with respect to the root of the document (\"//\"), while the second is referenced with respect to the current package (\"/\"). Epsilon HUTN does not support relative referencing, and all references are resolved with respect to the diagram root. The \"//\" prefix is omitted: Diagram \"my_diagram\" { shapes: \"my_triangle\", \"my_line\" }","title":"Absolute References"},{"location":"doc/articles/hutn-configuration/","text":"Customising Epsilon HUTN documents with configuration \u00b6 In this article we demonstrate how you can use the configuration features of Epsilon HUTN to customise your HUTN documents. For an introduction to modelling with HUTN, please refer to this article . Getting started \u00b6 Throughout this article, we'll use the following metamodel: Suppose we've already constructed a Families model using the following HUTN source: @Spec { metamodel \"families\" { nsUri: \"families\" } } families { Family { name: \"The Smiths\" familyFriends: Family \"does\", Family \"bloggs\" } Family \"does\" { name: \"The Does\" migrant: true } Family \"bloggs\" { name: \"The Bloggs\" migrant: true } } There is some duplication in the HUTN document above. Firstly, the identifiers used to reference Family objects are very similar to the families' names. Secondly, the migrant property is set to true in two of the three Families. A HUTN configuration model can be used to customise the document and reduce the duplication. A HUTN configuration model comprises rules, which customise the HUTN document. The remainder of this article describes how to create and use a configuration model to specify default values for properties and inferred values for identifiers. Creating a HUTN configuration model \u00b6 To create a HUTN configuration model, select File\u2192New\u2192Other\u2192Epsilon\u2192EMF Model . Specify a filename ending in .model, select the HUTN config metamodel URI and select Configuration as the root element. The dialogue should then look like this: After opening the resulting configuration model, new rules can be added. Right-click the configuration element, select New Child\u2192Rules Default Value Rule and New Child\u2192Rules Identifier Rule to create two rules: Default value rules are used to specify a value that will be used when the HUTN source document does not specify a value for a feature. Right-click the newly created default value rule and select Show Properties View . Specify Family as the classifier, migrant as the attribute and true as the value: Identifier rules are used to specify an attribute that will be used to identify model elements in the HUTN source document. Right-click the identifier rule and select Show Properties View . Specify Family as the classifier, and name as the attribute: Using a HUTN configuration model \u00b6 To make use of the configuration model, the preamble of the HUTN document must be changed to the following: @Spec { metamodel \"families\" { nsUri: \"families\" configFile: \"FamiliesConfig.model\" } } Note the extra line that references the configuration model. The value of the configFile attribute is a path relative to the HUTN document. The body of the HUTN document shown at the start of the article can now be rewritten as follows: families { Family { name: \"The Smiths\" familyFriends: Family \"The Does\", Family \"The Bloggs\" migrant: false } Family \"The Does\" {} Family \"The Bloggs\" {} } The identifiers specified for the last two families also specify the value of their name attribute, and so there's no need to explicitly set the name attribute in the body of the Family element. Conversely, the first Family specifies a name (The Smiths), and no identifier. A reference to the first family can use The Smiths as an identifier. Notice also that the migrant attribute values have been removed from the The Does and The Bloggs, as the default value is now true. However, The Smiths must now explicitly state that its migrant value should be false. Additional resources \u00b6 Article: Using HUTN in Epsilon","title":"Customising Epsilon HUTN documents with configuration"},{"location":"doc/articles/hutn-configuration/#customising-epsilon-hutn-documents-with-configuration","text":"In this article we demonstrate how you can use the configuration features of Epsilon HUTN to customise your HUTN documents. For an introduction to modelling with HUTN, please refer to this article .","title":"Customising Epsilon HUTN documents with configuration"},{"location":"doc/articles/hutn-configuration/#getting-started","text":"Throughout this article, we'll use the following metamodel: Suppose we've already constructed a Families model using the following HUTN source: @Spec { metamodel \"families\" { nsUri: \"families\" } } families { Family { name: \"The Smiths\" familyFriends: Family \"does\", Family \"bloggs\" } Family \"does\" { name: \"The Does\" migrant: true } Family \"bloggs\" { name: \"The Bloggs\" migrant: true } } There is some duplication in the HUTN document above. Firstly, the identifiers used to reference Family objects are very similar to the families' names. Secondly, the migrant property is set to true in two of the three Families. A HUTN configuration model can be used to customise the document and reduce the duplication. A HUTN configuration model comprises rules, which customise the HUTN document. The remainder of this article describes how to create and use a configuration model to specify default values for properties and inferred values for identifiers.","title":"Getting started"},{"location":"doc/articles/hutn-configuration/#creating-a-hutn-configuration-model","text":"To create a HUTN configuration model, select File\u2192New\u2192Other\u2192Epsilon\u2192EMF Model . Specify a filename ending in .model, select the HUTN config metamodel URI and select Configuration as the root element. The dialogue should then look like this: After opening the resulting configuration model, new rules can be added. Right-click the configuration element, select New Child\u2192Rules Default Value Rule and New Child\u2192Rules Identifier Rule to create two rules: Default value rules are used to specify a value that will be used when the HUTN source document does not specify a value for a feature. Right-click the newly created default value rule and select Show Properties View . Specify Family as the classifier, migrant as the attribute and true as the value: Identifier rules are used to specify an attribute that will be used to identify model elements in the HUTN source document. Right-click the identifier rule and select Show Properties View . Specify Family as the classifier, and name as the attribute:","title":"Creating a HUTN configuration model"},{"location":"doc/articles/hutn-configuration/#using-a-hutn-configuration-model","text":"To make use of the configuration model, the preamble of the HUTN document must be changed to the following: @Spec { metamodel \"families\" { nsUri: \"families\" configFile: \"FamiliesConfig.model\" } } Note the extra line that references the configuration model. The value of the configFile attribute is a path relative to the HUTN document. The body of the HUTN document shown at the start of the article can now be rewritten as follows: families { Family { name: \"The Smiths\" familyFriends: Family \"The Does\", Family \"The Bloggs\" migrant: false } Family \"The Does\" {} Family \"The Bloggs\" {} } The identifiers specified for the last two families also specify the value of their name attribute, and so there's no need to explicitly set the name attribute in the body of the Family element. Conversely, the first Family specifies a name (The Smiths), and no identifier. A reference to the first family can use The Smiths as an identifier. Notice also that the migrant attribute values have been removed from the The Does and The Bloggs, as the default value is now true. However, The Smiths must now explicitly state that its migrant value should be false.","title":"Using a HUTN configuration model"},{"location":"doc/articles/hutn-configuration/#additional-resources","text":"Article: Using HUTN in Epsilon","title":"Additional resources"},{"location":"doc/articles/in-memory-emf-model/","text":"Working with custom EMF resources \u00b6 Epsilon's default EMF driver ( EmfModel ), provides little support for customising the underlying EMF resource loading/persistence process (e.g. using custom resource factories, passing parameters to the resources's load/save methods etc.). If you're invoking an Epsilon program from Java and you need more flexibility in this respect, you can use InMemoryEmfModel instead, which is essentially a wrapper for a pre-loaded EMF resource. A skeleton example follows. Resource resource = ...; InMemoryEmfModel model = new InMemoryEmfModel ( resource ); model . setName ( \"M\" ); EolModule module = new EolModule (); module . parse (...); module . getContext (). getModelRepository (). addModel ( model ); module . execute (); resource . save (...);","title":"Working with custom EMF resources"},{"location":"doc/articles/in-memory-emf-model/#working-with-custom-emf-resources","text":"Epsilon's default EMF driver ( EmfModel ), provides little support for customising the underlying EMF resource loading/persistence process (e.g. using custom resource factories, passing parameters to the resources's load/save methods etc.). If you're invoking an Epsilon program from Java and you need more flexibility in this respect, you can use InMemoryEmfModel instead, which is essentially a wrapper for a pre-loaded EMF resource. A skeleton example follows. Resource resource = ...; InMemoryEmfModel model = new InMemoryEmfModel ( resource ); model . setName ( \"M\" ); EolModule module = new EolModule (); module . parse (...); module . getContext (). getModelRepository (). addModel ( model ); module . execute (); resource . save (...);","title":"Working with custom EMF resources"},{"location":"doc/articles/inspect-models-exeed/","text":"Inspecting EMF models with Exeed \u00b6 Exeed is an extended version of the built-in EMF reflective editor that enables customisation of labels and icons by adding annotations to ECore metamodels. Another feature it provides is the ability to display structural information about the elements of an EMF model. To see the types of all elements in the editor tree as well as the feature in which each element is contained, open your EMF model with Exeed and click Exeed \u2192 Show Structural Info . By doing this, the structural information of each element appears next to its label. For example, selecting this option for a GMF .gmfgraph model will make it look like this: The red-underlined text shows the type of the element (FigureGallery), the blue-underlined text shows the feature in which it is contained (figures), and the green-underlined text shows the EClass that owns the containing feature (Canvas). So next time you need to open an EMF model with a text editor to inspect its structure by reading the underlying XMI, you may want to consider giving Exeed a try instead.","title":"Inspecting EMF models with Exeed"},{"location":"doc/articles/inspect-models-exeed/#inspecting-emf-models-with-exeed","text":"Exeed is an extended version of the built-in EMF reflective editor that enables customisation of labels and icons by adding annotations to ECore metamodels. Another feature it provides is the ability to display structural information about the elements of an EMF model. To see the types of all elements in the editor tree as well as the feature in which each element is contained, open your EMF model with Exeed and click Exeed \u2192 Show Structural Info . By doing this, the structural information of each element appears next to its label. For example, selecting this option for a GMF .gmfgraph model will make it look like this: The red-underlined text shows the type of the element (FigureGallery), the blue-underlined text shows the feature in which it is contained (figures), and the green-underlined text shows the EClass that owns the containing feature (Canvas). So next time you need to open an EMF model with a text editor to inspect its structure by reading the underlying XMI, you may want to consider giving Exeed a try instead.","title":"Inspecting EMF models with Exeed"},{"location":"doc/articles/jdt/","text":"Treating Java code as a model in Epsilon \u00b6 In version 2.4 of Epsilon we introduced a driver that allows Epsilon languages to query Java code as if it were a model , using the internal representations of the Eclipse Java Development Tools . But, wait a second, why should I want to do this? \u00b6 There are many cases in which you may want to check things about your code. In many cases, a simple text-based search or the code navigation facilities in your IDE might be enough. For instance, finding a class by name or listing its inherited methods is something we do all the time. However, what if you want to check something very particular which is not supported by your IDE, and which involves \u201cunderstanding\u201d Java? As an example, suppose that you want to find all the places in your code where a new programmer may have used == to compare floating-point numbers. This is a very common mistake that novices make. Text search won\u2019t help you : floating-point expressions and variables can be arbitrarily complex. You will need to parse the Java code, find these == comparisons and reimplement the bits of the Java Language Specification needed to find if one of the two sides is a floating-point expression. Too much work for a quick check you wanted to run on your code! A simpler approach would be to have a tool give you a representation of the code that is close to how the compiler thinks about it, and that you can go through easily. This is what we mean with having a model . In particular, this example would be solved with our tool by writing this snippet of EOL code: for ( expr in InfixExpression . all ) { if ( expr . operator . toString () == \"==\" ) { var typeLExpr = expr . leftOperand . resolveTypeBinding (). qualifiedName ; var typeRExpr = expr . rightOperand . resolveTypeBinding (). qualifiedName ; if ( typeLExpr == \"float\" or typeRExpr == \"float\" ) { var cUnit = expr . root . javaElement . elementName ; ( \"WARNING: in \" + cUnit + \", tried to use == with a float: \" + expr ). println (); } } } This query finds the == expressions in your code, reuses the Eclipse Java Developer Tools to find if one of the two sides is a float (we\u2019re ignoring double to simplify things), and then reports any problems. It can handle non-trivial cases like method invocations, array accesses and so on. And all in 12 lines of code. How does it differ from other tools? \u00b6 The usual approach when exposing code as a model is to parse the code, dump it as a model (e.g in XMI) and then treat it as usual. This approach is followed by popular tools such as MoDisco , and it works well in \u201csoftware modernization\u201d situations in which you have a \u201cfrozen\u201d legacy code base. This is the bottom path shown on this figure, starting from \u201cJava code\u201d and going to the cyan nodes: However, if you have an active codebase, having to extract a full model every time you make a change is tedious and slows you down . Instead, it\u2019d be better to just have something running in the background keeping such a model up to date. The good news is that many IDEs already do this for their code navigation facilities, so we can piggyback on it without adding yet another background process to the user experience. Our EMC JDT driver is exactly that \u2013 we don\u2019t do any big extraction work in advance, so the query starts running almost immediately. The driver exposes the indices maintained by the Eclipse Java Development Tools, so you can quickly find a class and go through its methods, for instance. If at some point you need more information than the indices provide, we\u2019ll transparently use the JDT parser (based on the Java compiler) to fetch things for you. This is represented as the top path in the above figure, starting at \u201cJava code\u201d and going through the orange nodes. How is it used? \u00b6 With Epsilon and the EMC JDT driver installed, we create a new \u201cquery.eol\u201d file with our query. For instance, this one-liner prints how many types we have in our program: TypeDeclaration.all.size.println(\"number of types: \"); To run it, we create a standard EOL launch configuration and then select the new \u201cJava\u201d model type: We then select a set of Eclipse Java projects to expose as a model: You can select multiple projects through Ctrl+click \u2013 these will all be exposed as a single model. Here I have code for various versions of the JFreeChart library , and I have selected the code for the 1.0.19 version in particular. Click on OK , then Run , and you\u2019ll get your answer: number of types: 1041 What other things can I do? \u00b6 While the previous example was very simple, EOL is a fully-featured language, with support for loops, user-defined operations, built-in data structures and full access to any Java library. In this paper we showed how to use it to validate your real Java code against a UML diagram, checking if perhaps your UML diagram had gone \u201cstale\u201d . We found that using the EMC JDT driver would be faster than using MoDisco if you just wanted to do this check repeatedly across multiple releases. Essentially, we expose the JDT document object model (DOM) directly through Epsilon, so if you want to access all instances of the JDT DOM TypeDeclaration class , you write TypeDeclaration.all as we did above. We also provide a few convenient shorthands. For a TypeDeclaration t, you can use these: t.public , t.protected , t.private , t.static , t.abstract , t.final : these are true/false depending on whether the underlying type has this modifier. t.name : this exposes the name of the underlying type (which usually requires going through multiple fields). We also expose the JDT index so you can quickly find a type by name: in fact, it\u2019s the same index you use when pressing CTRL+SHIFT+T on Eclipse. To do so, you can use one of these: TypeDeclaration.all.select(td|td.name=\"someClass\") finds a type by name and returns it as a collection of TypeDeclarations with access to every detail within those types. TypeDeclaration.all.search(td|td.name=\"someClass\") does the same, but it only returns the raw index entry (an instance of IType ), which is much faster but has less information. Applications \u00b6 In this example , we use the JDT driver and Picto to generate PlantUML diagrams from existing Java code on the fly. jcd.flexmi <?nsuri jcd?> <_> <diagram name= \"Kitchen Sink\" > <include name= \"Employee\" /> <include name= \"Product\" /> <include name= \"Order\" /> <include name= \"OrderItem\" /> <include name= \"Person\" /> <include name= \"Shippable\" /> <include name= \"Address\" /> <include name= \"Customer\" /> <constraint below= \"Order\" above= \"Employee\" /> <constraint below= \"OrderItem\" above= \"Product\" /> <constraint above= \"Customer\" below= \"Order\" /> <constraint right= \"Customer\" left= \"Address\" /> </diagram> <diagram name= \"Employee and Person\" > <preamble> skinparam monochrome true skinparam handwritten true </preamble> <postamble> note left of Employee: People working for our company note right of Person::\"lastName : String\" The person's last name end note </postamble> <include name= \"Employee\" /> <include name= \"Person\" /> </diagram> <diagram name= \"Employee but not Person\" > <include name= \"Employee\" /> </diagram> <diagram name= \"Order and Shippable\" > <include name= \"Order\" /> <include name= \"Shippable\" /> <constraint right= \"Order\" left= \"Shippable\" /> </diagram> <diagram name= \"Order but not Shippable\" > <include name= \"Order\" /> </diagram> </_> jcd.picto <?nsuri picto?> <picto format= \"egx\" transformation= \"jcd.egx\" standalone= \"true\" > <model type= \"EMF\" > <parameter name= \"name\" value= \"JCD\" /> <parameter name= \"metamodelUri\" value= \"jcd\" /> <parameter name= \"modelFile\" file= \"jcd.flexmi\" /> </model> <model type= \"JDT\" > <parameter name= \"name\" value= \"JDT\" /> <parameter name= \"projects\" value= \"org.eclipse.epsilon.examples.jdt.picto\" /> </model> </picto> jcd.egx rule Diagram2PlantUML transform diagram : JCD!Diagram { template : \"cd.egl\" parameters : Map{ \"path\" = Sequence{diagram.name}, \"format\" = \"puml\" } } cd.egl @startuml hide circle [%diagram.populate();%] [%=diagram.preamble%] [%for (class in diagram.types.select(t|t.isTypeOf(Class))){%] class [%=class.name%] { [%for (attribute in class.attributes){%] [%=attribute.name%] : [%=attribute.type%] [%}%] [%for (method in class.methods) { %] [%=method.getLabel()%] [%}%] } [%for (reference in class.references){%] [%=reference.getEdge()%] [%}%] [%for (superType in class.superTypes){%] [%=getEdge(class, superType)%] [%}%] [%}%] [%=diagram.postamble%] @enduml [% operation JCD!Diagram populate() { // Resolve type declaration from includes and create types for (include in self.includes) { var typeDeclaration = JDT!TypeDeclaration.all.select(td|td.name = include.name).first(); if (typeDeclaration.isDefined()) { var class = new JCD!Class; class.name = typeDeclaration.name.identifier; self.types.add(class); class.~typeDeclaration = typeDeclaration; } } // Populate supertypes for (class in self.types.select(t|t.isTypeOf(JCD!Class) and t.~typeDeclaration.isDefined())) { if (class.~typeDeclaration.getSuperclassType().isDefined()) { class.superTypes.addAll(self.types.select(c:JCD!Class|c.name = class.~typeDeclaration.getSuperclassType().toString()/*name.identifier*/)); } for (interface in class.~typeDeclaration.superInterfaceTypes()) { class.superTypes.addAll(self.types.select(c:JCD!Class|c.name = interface.name.identifier)); } } // Populate class attributes, references and methods for (class in self.types.select(t|t.isTypeOf(JCD!Class) and t.~typeDeclaration.isDefined())) { for (field in class.~typeDeclaration.fields) { if (not field.getType().isVisible(diagram)) { var attribute = new JCD!Attribute; attribute.name = field.getName(); attribute.type = field.getType().getLabel(); attribute.many = field.isCollection(); class.attributes.add(attribute); } else { var reference = new JCD!Reference; reference.name = field.getName(); reference.type = diagram.types.selectOne(c|c.name = field.getType().name.identifier); reference.many = field.isCollection(); class.references.add(reference); } } // Populate class methods for (methodDeclaration in class.~typeDeclaration.methods) { var method = new JCD!Method; method.name = methodDeclaration.name.identifier; for (formalParameter in methodDeclaration.parameters()) { var parameter : new JCD!Parameter; parameter.name = formalParameter.name.identifier; parameter.type = formalParameter.type.getLabel(); method.parameters.add(parameter); } //method.type = methodDeclaration.returnType2.getLabel(); class.methods.add(method); } } } /** * Produces a generalization edge, taking into account contstraints */ operation getEdge(class:JCD!Class, superClass:JCD!Class) { var diagram = class.eContainer(); if (diagram.constraints.exists(c|c.above = class.name and c.below = superClass.name)) { return class.name + \" --|> \" + superClass.name; } else if (diagram.constraints.exists(c|c.left = class.name and c.right = superClass.name)) { return class.name + \" -|> \" + superClass.name; } else if (diagram.constraints.exists(c|c.left = superClass.name and c.right = class.name)) { return superClass.name + \" <|- \" + class.name; } else { return superClass.name + \" <|-- \" + class.name; } } /* * Prdoduces a reference edge, taking into account constraints */ operation JCD!Reference getEdge() { var diagram = self.eContainer().eContainer(); var label = \" \\\" \" + self.name + (self.many ? \"*\" : \"\") + \"\\\" \"; if (diagram.constraints.exists(c|c.above = self.eContainer().name and c.below = self.type.name)) { return self.eContainer().name + \" -down-> \" + self.type.name + \" : \" + label; } else if (diagram.constraints.exists(c|c.below = self.eContainer().name and c.above = self.type.name)) { return self.eContainer().name + \" -up-> \" + self.type.name + \" : \" + label; } else if (diagram.constraints.exists(c|c.right = self.eContainer().name and c.left = self.type.name)) { return self.eContainer().name + \" -left-> \" + self.type.name + \" : \" + label; } else { return self.eContainer().name + \" -right-> \" + self.type.name + \" : \" + label; } } operation JDT!FieldDeclaration getName() { return self.fragments.at(0)/*VariableDeclarationFragment*/.name.identifier; } operation JDT!ParameterizedType getLabel() { return self.type.name + \"<\" + self.typeArguments.collect(ta|ta.getLabel()).concat(\", \") + \">\"; } operation JDT!WildcardType getLabel() { return self.toString(); } operation JDT!SimpleType getLabel() { return self.name.identifier; } operation JDT!PrimitiveType getLabel() { return self.toString(); } operation JDT!FieldDeclaration getType() { if (self.isCollection()) { return self.type.typeArguments.first(); } else { return self.type; } } operation JDT!FieldDeclaration isCollection() { return self.type.isTypeOf(JDT!ParameterizedType) and self.type.typeArguments.size() == 1 and self.type.type.name.identifier = \"List\"; /*FIXME*/ } operation JDT!Type isVisible(diagram : JCD!Diagram) { if (not self.isTypeOf(JDT!SimpleType)) return false; return diagram.types.name.includes(self.name.identifier); } operation JCD!Method getLabel() { var label = self.name + \"(\" + self.parameters.collect(p|p.name + \":\" + p.type).concat(\", \") + \")\"; if (self.type.isDefined() and self.type != \"void\") label += \" : \" + self.type; return label; } %]","title":"Treating Java code as a model in Epsilon"},{"location":"doc/articles/jdt/#treating-java-code-as-a-model-in-epsilon","text":"In version 2.4 of Epsilon we introduced a driver that allows Epsilon languages to query Java code as if it were a model , using the internal representations of the Eclipse Java Development Tools .","title":"Treating Java code as a model in Epsilon"},{"location":"doc/articles/jdt/#but-wait-a-second-why-should-i-want-to-do-this","text":"There are many cases in which you may want to check things about your code. In many cases, a simple text-based search or the code navigation facilities in your IDE might be enough. For instance, finding a class by name or listing its inherited methods is something we do all the time. However, what if you want to check something very particular which is not supported by your IDE, and which involves \u201cunderstanding\u201d Java? As an example, suppose that you want to find all the places in your code where a new programmer may have used == to compare floating-point numbers. This is a very common mistake that novices make. Text search won\u2019t help you : floating-point expressions and variables can be arbitrarily complex. You will need to parse the Java code, find these == comparisons and reimplement the bits of the Java Language Specification needed to find if one of the two sides is a floating-point expression. Too much work for a quick check you wanted to run on your code! A simpler approach would be to have a tool give you a representation of the code that is close to how the compiler thinks about it, and that you can go through easily. This is what we mean with having a model . In particular, this example would be solved with our tool by writing this snippet of EOL code: for ( expr in InfixExpression . all ) { if ( expr . operator . toString () == \"==\" ) { var typeLExpr = expr . leftOperand . resolveTypeBinding (). qualifiedName ; var typeRExpr = expr . rightOperand . resolveTypeBinding (). qualifiedName ; if ( typeLExpr == \"float\" or typeRExpr == \"float\" ) { var cUnit = expr . root . javaElement . elementName ; ( \"WARNING: in \" + cUnit + \", tried to use == with a float: \" + expr ). println (); } } } This query finds the == expressions in your code, reuses the Eclipse Java Developer Tools to find if one of the two sides is a float (we\u2019re ignoring double to simplify things), and then reports any problems. It can handle non-trivial cases like method invocations, array accesses and so on. And all in 12 lines of code.","title":"But, wait a second, why should I want to do this?"},{"location":"doc/articles/jdt/#how-does-it-differ-from-other-tools","text":"The usual approach when exposing code as a model is to parse the code, dump it as a model (e.g in XMI) and then treat it as usual. This approach is followed by popular tools such as MoDisco , and it works well in \u201csoftware modernization\u201d situations in which you have a \u201cfrozen\u201d legacy code base. This is the bottom path shown on this figure, starting from \u201cJava code\u201d and going to the cyan nodes: However, if you have an active codebase, having to extract a full model every time you make a change is tedious and slows you down . Instead, it\u2019d be better to just have something running in the background keeping such a model up to date. The good news is that many IDEs already do this for their code navigation facilities, so we can piggyback on it without adding yet another background process to the user experience. Our EMC JDT driver is exactly that \u2013 we don\u2019t do any big extraction work in advance, so the query starts running almost immediately. The driver exposes the indices maintained by the Eclipse Java Development Tools, so you can quickly find a class and go through its methods, for instance. If at some point you need more information than the indices provide, we\u2019ll transparently use the JDT parser (based on the Java compiler) to fetch things for you. This is represented as the top path in the above figure, starting at \u201cJava code\u201d and going through the orange nodes.","title":"How does it differ from other tools?"},{"location":"doc/articles/jdt/#how-is-it-used","text":"With Epsilon and the EMC JDT driver installed, we create a new \u201cquery.eol\u201d file with our query. For instance, this one-liner prints how many types we have in our program: TypeDeclaration.all.size.println(\"number of types: \"); To run it, we create a standard EOL launch configuration and then select the new \u201cJava\u201d model type: We then select a set of Eclipse Java projects to expose as a model: You can select multiple projects through Ctrl+click \u2013 these will all be exposed as a single model. Here I have code for various versions of the JFreeChart library , and I have selected the code for the 1.0.19 version in particular. Click on OK , then Run , and you\u2019ll get your answer: number of types: 1041","title":"How is it used?"},{"location":"doc/articles/jdt/#what-other-things-can-i-do","text":"While the previous example was very simple, EOL is a fully-featured language, with support for loops, user-defined operations, built-in data structures and full access to any Java library. In this paper we showed how to use it to validate your real Java code against a UML diagram, checking if perhaps your UML diagram had gone \u201cstale\u201d . We found that using the EMC JDT driver would be faster than using MoDisco if you just wanted to do this check repeatedly across multiple releases. Essentially, we expose the JDT document object model (DOM) directly through Epsilon, so if you want to access all instances of the JDT DOM TypeDeclaration class , you write TypeDeclaration.all as we did above. We also provide a few convenient shorthands. For a TypeDeclaration t, you can use these: t.public , t.protected , t.private , t.static , t.abstract , t.final : these are true/false depending on whether the underlying type has this modifier. t.name : this exposes the name of the underlying type (which usually requires going through multiple fields). We also expose the JDT index so you can quickly find a type by name: in fact, it\u2019s the same index you use when pressing CTRL+SHIFT+T on Eclipse. To do so, you can use one of these: TypeDeclaration.all.select(td|td.name=\"someClass\") finds a type by name and returns it as a collection of TypeDeclarations with access to every detail within those types. TypeDeclaration.all.search(td|td.name=\"someClass\") does the same, but it only returns the raw index entry (an instance of IType ), which is much faster but has less information.","title":"What other things can I do?"},{"location":"doc/articles/jdt/#applications","text":"In this example , we use the JDT driver and Picto to generate PlantUML diagrams from existing Java code on the fly. jcd.flexmi <?nsuri jcd?> <_> <diagram name= \"Kitchen Sink\" > <include name= \"Employee\" /> <include name= \"Product\" /> <include name= \"Order\" /> <include name= \"OrderItem\" /> <include name= \"Person\" /> <include name= \"Shippable\" /> <include name= \"Address\" /> <include name= \"Customer\" /> <constraint below= \"Order\" above= \"Employee\" /> <constraint below= \"OrderItem\" above= \"Product\" /> <constraint above= \"Customer\" below= \"Order\" /> <constraint right= \"Customer\" left= \"Address\" /> </diagram> <diagram name= \"Employee and Person\" > <preamble> skinparam monochrome true skinparam handwritten true </preamble> <postamble> note left of Employee: People working for our company note right of Person::\"lastName : String\" The person's last name end note </postamble> <include name= \"Employee\" /> <include name= \"Person\" /> </diagram> <diagram name= \"Employee but not Person\" > <include name= \"Employee\" /> </diagram> <diagram name= \"Order and Shippable\" > <include name= \"Order\" /> <include name= \"Shippable\" /> <constraint right= \"Order\" left= \"Shippable\" /> </diagram> <diagram name= \"Order but not Shippable\" > <include name= \"Order\" /> </diagram> </_> jcd.picto <?nsuri picto?> <picto format= \"egx\" transformation= \"jcd.egx\" standalone= \"true\" > <model type= \"EMF\" > <parameter name= \"name\" value= \"JCD\" /> <parameter name= \"metamodelUri\" value= \"jcd\" /> <parameter name= \"modelFile\" file= \"jcd.flexmi\" /> </model> <model type= \"JDT\" > <parameter name= \"name\" value= \"JDT\" /> <parameter name= \"projects\" value= \"org.eclipse.epsilon.examples.jdt.picto\" /> </model> </picto> jcd.egx rule Diagram2PlantUML transform diagram : JCD!Diagram { template : \"cd.egl\" parameters : Map{ \"path\" = Sequence{diagram.name}, \"format\" = \"puml\" } } cd.egl @startuml hide circle [%diagram.populate();%] [%=diagram.preamble%] [%for (class in diagram.types.select(t|t.isTypeOf(Class))){%] class [%=class.name%] { [%for (attribute in class.attributes){%] [%=attribute.name%] : [%=attribute.type%] [%}%] [%for (method in class.methods) { %] [%=method.getLabel()%] [%}%] } [%for (reference in class.references){%] [%=reference.getEdge()%] [%}%] [%for (superType in class.superTypes){%] [%=getEdge(class, superType)%] [%}%] [%}%] [%=diagram.postamble%] @enduml [% operation JCD!Diagram populate() { // Resolve type declaration from includes and create types for (include in self.includes) { var typeDeclaration = JDT!TypeDeclaration.all.select(td|td.name = include.name).first(); if (typeDeclaration.isDefined()) { var class = new JCD!Class; class.name = typeDeclaration.name.identifier; self.types.add(class); class.~typeDeclaration = typeDeclaration; } } // Populate supertypes for (class in self.types.select(t|t.isTypeOf(JCD!Class) and t.~typeDeclaration.isDefined())) { if (class.~typeDeclaration.getSuperclassType().isDefined()) { class.superTypes.addAll(self.types.select(c:JCD!Class|c.name = class.~typeDeclaration.getSuperclassType().toString()/*name.identifier*/)); } for (interface in class.~typeDeclaration.superInterfaceTypes()) { class.superTypes.addAll(self.types.select(c:JCD!Class|c.name = interface.name.identifier)); } } // Populate class attributes, references and methods for (class in self.types.select(t|t.isTypeOf(JCD!Class) and t.~typeDeclaration.isDefined())) { for (field in class.~typeDeclaration.fields) { if (not field.getType().isVisible(diagram)) { var attribute = new JCD!Attribute; attribute.name = field.getName(); attribute.type = field.getType().getLabel(); attribute.many = field.isCollection(); class.attributes.add(attribute); } else { var reference = new JCD!Reference; reference.name = field.getName(); reference.type = diagram.types.selectOne(c|c.name = field.getType().name.identifier); reference.many = field.isCollection(); class.references.add(reference); } } // Populate class methods for (methodDeclaration in class.~typeDeclaration.methods) { var method = new JCD!Method; method.name = methodDeclaration.name.identifier; for (formalParameter in methodDeclaration.parameters()) { var parameter : new JCD!Parameter; parameter.name = formalParameter.name.identifier; parameter.type = formalParameter.type.getLabel(); method.parameters.add(parameter); } //method.type = methodDeclaration.returnType2.getLabel(); class.methods.add(method); } } } /** * Produces a generalization edge, taking into account contstraints */ operation getEdge(class:JCD!Class, superClass:JCD!Class) { var diagram = class.eContainer(); if (diagram.constraints.exists(c|c.above = class.name and c.below = superClass.name)) { return class.name + \" --|> \" + superClass.name; } else if (diagram.constraints.exists(c|c.left = class.name and c.right = superClass.name)) { return class.name + \" -|> \" + superClass.name; } else if (diagram.constraints.exists(c|c.left = superClass.name and c.right = class.name)) { return superClass.name + \" <|- \" + class.name; } else { return superClass.name + \" <|-- \" + class.name; } } /* * Prdoduces a reference edge, taking into account constraints */ operation JCD!Reference getEdge() { var diagram = self.eContainer().eContainer(); var label = \" \\\" \" + self.name + (self.many ? \"*\" : \"\") + \"\\\" \"; if (diagram.constraints.exists(c|c.above = self.eContainer().name and c.below = self.type.name)) { return self.eContainer().name + \" -down-> \" + self.type.name + \" : \" + label; } else if (diagram.constraints.exists(c|c.below = self.eContainer().name and c.above = self.type.name)) { return self.eContainer().name + \" -up-> \" + self.type.name + \" : \" + label; } else if (diagram.constraints.exists(c|c.right = self.eContainer().name and c.left = self.type.name)) { return self.eContainer().name + \" -left-> \" + self.type.name + \" : \" + label; } else { return self.eContainer().name + \" -right-> \" + self.type.name + \" : \" + label; } } operation JDT!FieldDeclaration getName() { return self.fragments.at(0)/*VariableDeclarationFragment*/.name.identifier; } operation JDT!ParameterizedType getLabel() { return self.type.name + \"<\" + self.typeArguments.collect(ta|ta.getLabel()).concat(\", \") + \">\"; } operation JDT!WildcardType getLabel() { return self.toString(); } operation JDT!SimpleType getLabel() { return self.name.identifier; } operation JDT!PrimitiveType getLabel() { return self.toString(); } operation JDT!FieldDeclaration getType() { if (self.isCollection()) { return self.type.typeArguments.first(); } else { return self.type; } } operation JDT!FieldDeclaration isCollection() { return self.type.isTypeOf(JDT!ParameterizedType) and self.type.typeArguments.size() == 1 and self.type.type.name.identifier = \"List\"; /*FIXME*/ } operation JDT!Type isVisible(diagram : JCD!Diagram) { if (not self.isTypeOf(JDT!SimpleType)) return false; return diagram.types.name.includes(self.name.identifier); } operation JCD!Method getLabel() { var label = self.name + \"(\" + self.parameters.collect(p|p.name + \":\" + p.type).concat(\", \") + \")\"; if (self.type.isDefined() and self.type != \"void\") label += \" : \" + self.type; return label; } %]","title":"Applications"},{"location":"doc/articles/labsupdatesite/","text":"Publishing your project to the Epsilon Labs Update Site \u00b6 In this article we explain the steps required to publish your Epsilon related project in the Epsilon Labs update site. General Recommendations \u00b6 As part of the process you will configure your project to be under continuous integration (CI) which is automatically triggered when you push changes to the main branch of your project's git repository. For this reason it is recommended that you create a develop branch in which you make frequent commits/pushes and only merge changes to the main branch when you want to release a new version (you might be interested in GitFlow ) Creating Feature Plugins \u00b6 In the Eclipse world, a feature is a group of one or more plugins that offer a specific functionality within Eclipse. For example, the Epsilon Core feature groups all the plugins that provide support for the core Epsilon languages (EOL, ETL, EGL, etc.) and drivers (CSV, XML, Bibtext, etc.). In order to publish your project you need to create feature plugins. As a minimum you would need to provide two features: one for the base functionality and other for the developer tools. The developer tools are the plugins that provide UI contributions (menus, launchers, etc.). For example, the JDBC project provides these two features (developer tools plugins and features should use the dt suffix): org.eclipse.epsilon.emc.jdbc.mysql.feature org.eclipse.epsilon.emc.jdbc.mysql.feature.dt Feature Information \u00b6 NOTE : Correctly fill the feature information. This information is displayed within the Install New Software tool and therefore the first point of contact between your project and the user. Feature Description Optional URL: Leave blank Text: Meaningful information about the plugins Copyright Notice Optional URL: Leave blank Text: Copyright \u00a9 2008 The University of York. All rights reserved. Contributors: License Agreement Use the appropriate license agreement. This depends on the libraries you are using. Sites to visit Any important sites of interest (e.g. Epsilon's website) Group your project's plugins \u00b6 Add each of your project plugins to the relevant feature. Remember that your dt plugins should go in your dt (development tools) feature. Create a site.xml \u00b6 An update site contains information about the features and plugins that can be installed from it. In order to the EpsilonLabs Updatesite to know what features/plugins you provide you must add this information to a site.xml file. You can find a template here or in the EpsilonLabs update site repository (template folder). In a nutshell, site.xml lists the features of your project and provides a category (a logical grouping of features) for your project. Set up CI \u00b6 Go to CircleCi and log in using your Github credentials (for simple configuration of the project). Add your project to CircleCI \u00b6 In the top left corner select the epsilonlabs organization. Click on Add Project Click on Setup Project In Language select Maven(Java) Skip the circli configuration (we will show you this next) Click on Start Building Set up EpsilonLabs build Trigger \u00b6 Open the epsilonlabs CircleCI project Go to settings Go to API Permisssions Copy the token value of the TRIGGER_TOKEN Go to your project Go to settings Go to Environment Variables Add variable: Name : TRIGGER_BUILD, Value : Paste the TRIGGER_TOKEN value Configure CircleCI for your project \u00b6 Create a .circleci folder in the root of your project Create a new config.yml file Use the template provided ( here or in the EpsilonLabs updatesite repository ) and make sure you add an store_artifacts entry for each plugin and feature JAR. Note : The path information points to the target folder which will be populated by maven (see next). Use Maven + Tycho to build your project \u00b6 We will use a pom-less configuration to build your project with maven and Tycho. Create a POM for your project. If you divide your projects into plugins, features, tests folders (btw, you should) you need to create a parent pom, and then a pom for each folder. A pom-less build avoids having a pom for each project, but still needs the structure ones. Use the provided template(s), change the artifact id and add your plugins and features to the modules section. The templates are here or in the EpsilonLabs updatesite repository ) To enable the pomless build, copy the extensions.xml (or in the repository) file to a .mvn folder in your project. Local maven build \u00b6 Install Maven and build your project to test that your poms are correct. You should also make sure that any tests you have coded are executed as part of the Maven build. mvn clean install Check that the required JARs have been created in the target folder. Test your CI build \u00b6 Merge your repository changes (new files) to your main branch and push to GitHub. This should trigger a new build. Go to CircleCI and verify that your build completed without errors. CircleCI will simply execute a maven build so if your local build succeeded the CircleCi should too. Additionally check that all the JARs have been stored as artifacts. In your project's build information page click on the Artifacts tab: Add your project to the EpsilonLabs update site \u00b6 Fork the EpsilonLabs update site repository and add your project in two places: Add a new entry(line) to the projects.txt file. The line should have your project name (the name of the project in GitHub) and the target platform information. In most cases this can be Any . If you only support a specific platform you should provide the correct values. Add a new local repository to the updasite's root pom (the project name should match the entry in the projects file): <repository> <id> epsilonlabs-{project} </id> <url> file:///${main.basedir}/repository/{project}} </url> <layout> p2 </layout> </repository> Make a pull request to the main EpsilonLabs update site project. After your request has been merged you should see your project in the update site. Additional resources \u00b6 Eclipse p2 publisher","title":"Publishing your project to the Epsilon Labs Update Site"},{"location":"doc/articles/labsupdatesite/#publishing-your-project-to-the-epsilon-labs-update-site","text":"In this article we explain the steps required to publish your Epsilon related project in the Epsilon Labs update site.","title":"Publishing your project to the Epsilon Labs Update Site"},{"location":"doc/articles/labsupdatesite/#general-recommendations","text":"As part of the process you will configure your project to be under continuous integration (CI) which is automatically triggered when you push changes to the main branch of your project's git repository. For this reason it is recommended that you create a develop branch in which you make frequent commits/pushes and only merge changes to the main branch when you want to release a new version (you might be interested in GitFlow )","title":"General Recommendations"},{"location":"doc/articles/labsupdatesite/#creating-feature-plugins","text":"In the Eclipse world, a feature is a group of one or more plugins that offer a specific functionality within Eclipse. For example, the Epsilon Core feature groups all the plugins that provide support for the core Epsilon languages (EOL, ETL, EGL, etc.) and drivers (CSV, XML, Bibtext, etc.). In order to publish your project you need to create feature plugins. As a minimum you would need to provide two features: one for the base functionality and other for the developer tools. The developer tools are the plugins that provide UI contributions (menus, launchers, etc.). For example, the JDBC project provides these two features (developer tools plugins and features should use the dt suffix): org.eclipse.epsilon.emc.jdbc.mysql.feature org.eclipse.epsilon.emc.jdbc.mysql.feature.dt","title":"Creating Feature Plugins"},{"location":"doc/articles/labsupdatesite/#feature-information","text":"NOTE : Correctly fill the feature information. This information is displayed within the Install New Software tool and therefore the first point of contact between your project and the user. Feature Description Optional URL: Leave blank Text: Meaningful information about the plugins Copyright Notice Optional URL: Leave blank Text: Copyright \u00a9 2008 The University of York. All rights reserved. Contributors: License Agreement Use the appropriate license agreement. This depends on the libraries you are using. Sites to visit Any important sites of interest (e.g. Epsilon's website)","title":"Feature Information"},{"location":"doc/articles/labsupdatesite/#group-your-projects-plugins","text":"Add each of your project plugins to the relevant feature. Remember that your dt plugins should go in your dt (development tools) feature.","title":"Group your project's plugins"},{"location":"doc/articles/labsupdatesite/#create-a-sitexml","text":"An update site contains information about the features and plugins that can be installed from it. In order to the EpsilonLabs Updatesite to know what features/plugins you provide you must add this information to a site.xml file. You can find a template here or in the EpsilonLabs update site repository (template folder). In a nutshell, site.xml lists the features of your project and provides a category (a logical grouping of features) for your project.","title":"Create a site.xml"},{"location":"doc/articles/labsupdatesite/#set-up-ci","text":"Go to CircleCi and log in using your Github credentials (for simple configuration of the project).","title":"Set up CI"},{"location":"doc/articles/labsupdatesite/#add-your-project-to-circleci","text":"In the top left corner select the epsilonlabs organization. Click on Add Project Click on Setup Project In Language select Maven(Java) Skip the circli configuration (we will show you this next) Click on Start Building","title":"Add your project to CircleCI"},{"location":"doc/articles/labsupdatesite/#set-up-epsilonlabs-build-trigger","text":"Open the epsilonlabs CircleCI project Go to settings Go to API Permisssions Copy the token value of the TRIGGER_TOKEN Go to your project Go to settings Go to Environment Variables Add variable: Name : TRIGGER_BUILD, Value : Paste the TRIGGER_TOKEN value","title":"Set up EpsilonLabs build Trigger"},{"location":"doc/articles/labsupdatesite/#configure-circleci-for-your-project","text":"Create a .circleci folder in the root of your project Create a new config.yml file Use the template provided ( here or in the EpsilonLabs updatesite repository ) and make sure you add an store_artifacts entry for each plugin and feature JAR. Note : The path information points to the target folder which will be populated by maven (see next).","title":"Configure CircleCI for your project"},{"location":"doc/articles/labsupdatesite/#use-maven-tycho-to-build-your-project","text":"We will use a pom-less configuration to build your project with maven and Tycho. Create a POM for your project. If you divide your projects into plugins, features, tests folders (btw, you should) you need to create a parent pom, and then a pom for each folder. A pom-less build avoids having a pom for each project, but still needs the structure ones. Use the provided template(s), change the artifact id and add your plugins and features to the modules section. The templates are here or in the EpsilonLabs updatesite repository ) To enable the pomless build, copy the extensions.xml (or in the repository) file to a .mvn folder in your project.","title":"Use Maven + Tycho to build your project"},{"location":"doc/articles/labsupdatesite/#local-maven-build","text":"Install Maven and build your project to test that your poms are correct. You should also make sure that any tests you have coded are executed as part of the Maven build. mvn clean install Check that the required JARs have been created in the target folder.","title":"Local maven build"},{"location":"doc/articles/labsupdatesite/#test-your-ci-build","text":"Merge your repository changes (new files) to your main branch and push to GitHub. This should trigger a new build. Go to CircleCI and verify that your build completed without errors. CircleCI will simply execute a maven build so if your local build succeeded the CircleCi should too. Additionally check that all the JARs have been stored as artifacts. In your project's build information page click on the Artifacts tab:","title":"Test your CI build"},{"location":"doc/articles/labsupdatesite/#add-your-project-to-the-epsilonlabs-update-site","text":"Fork the EpsilonLabs update site repository and add your project in two places: Add a new entry(line) to the projects.txt file. The line should have your project name (the name of the project in GitHub) and the target platform information. In most cases this can be Any . If you only support a specific platform you should provide the correct values. Add a new local repository to the updasite's root pom (the project name should match the entry in the projects file): <repository> <id> epsilonlabs-{project} </id> <url> file:///${main.basedir}/repository/{project}} </url> <layout> p2 </layout> </repository> Make a pull request to the main EpsilonLabs update site project. After your request has been merged you should see your project in the update site.","title":"Add your project to the EpsilonLabs update site"},{"location":"doc/articles/labsupdatesite/#additional-resources","text":"Eclipse p2 publisher","title":"Additional resources"},{"location":"doc/articles/lambda-expressions/","text":"Native lambda expressions \u00b6 Whilst EOL has many useful declarative operations built in, some applications and developers may benefit from using alternative implementations, such as the Java Streams API . Epsilon now allows you to invoke functional interfaces using EOL first-order operation syntax. Provided that the method being invoked takes one or more functional interface s as a parameter and the correct number of parameters are supplied to each interface, this integration should work seamlessly as with regular first-order operation call expressions. For lambda expressions which do not require a parameter, you can either omit the parameter, use null or _ in place of the parameter, like so: var optional = Native(\"java.util.stream.IntStream\") .range(0, 16) .filter(i | i / 4 >= 2) .findFirst(); optional.orElse(64/4); // No lambda - literal value always calculated even if not present. optional.orElseGet(null | someIntensiveCalculation()); // Evaluation only occurs if no value is present. optional.orElseThrow(| new Native(\"org.eclipse.epsilon.eol.exceptions.EolRuntimeException\")); Here is an example of how one could use Java Streams and the equivalent approach using EOL (i.e. without native delegation): var Collectors = Native(\"java.util.stream.Collectors\"); var testData = Sequence{-1024..1024}; var positiveOddsSquaredEol = testData .select(i | i >= 0 and i.mod(2) > 0) .collect(i | i * i) .asSet(); var positiveOddsSquaredJava = testData.stream() .filter(i | i >= 0 and i.mod(2) > 0) .map(i | i * i) .collect(Collectors.toSet()); assertEquals(positiveOddsSquaredEol, positiveOddsSquaredJava); One benefits of using Streams is lazy evaluation, which allows you to chain a series of operations without executing the entire pipeline on all elements. This can be more efficient since streams are not materialised in intermediate operations, unlike EOL first-order operations which always return a collection and are thus evaluated eagerly. As with built-in EOL operations, Streams also support parallel execution, although this must be explicitly specified with the .parallel() property on the stream. Currently EOL does not support operations which require a simple variable and non-functional interface as a parameter, such as the iterate operation. To work around this, you can assign lambda expressions to variables, deriving them by calling a built-in operation to obtain the desired type. // UnaryOperator var doubler = unary(i | i * 2); assertEquals(16, doubler.apply(8)); // Predicate var isEvenTester = predicate(i | i.mod(2) == 0); assertFalse(predicate.test(3)); // Function var hasher = func(x | x.hashCode()); assertEquals(-1007761232, hasher.apply(\"a string\")); // Consumer var printer = consumer(x | x.println()); printer.accept(\"Testing...\"); // Supplier var threadSafeCollectionMaker = supplier( | new Native(\"java.util.concurrent.ConcurrentLinkedDeque\")); var deque = threadSafeCollectionMaker.get(); // Runnable var sayHi = runnable( | \"Hello, World!\".println()); sayHi.run(); Streams vs EOL cheat sheet \u00b6 Aside from the fact that streams are lazy and Epsilon operations are eager, there is some inevitable overlap in their functionality. This section provides an equivalence mapping from Epsilon to Java Streams to help you migrate from one to the other. select => filter collect => map forAll => allMatch exists => anyMatch none => noneMatch nMatch => No efficient short-circuiting equivalent, but result can be achieved using filter followed by .count() == n count => count one => Same as nMatch with n = 1 selectOne => filter followed by .findAny() / .findFirst() then .orElse(null) if the desired absence of a result is null reject => same as select with negated predicate sortBy => sorted mapBy => .collect(Collectors.groupingBy) aggregate => .collect(Collectors.toMap) In addition, non-first-order operations on Epsilon collection types can be simulated as follows for streams: flatten => .flatMap(c | c.stream()) -- please note that flatten is recursive whilst flatMap is not sum => .filter(e | e.isInteger()).mapToInt(i | i).sum() -- replace Int/Integer with appropriate type (Long, Double etc.) min / max => Same as sum but replace the last call with min or max as required product => Same as sum but replace the last call with .reduce(i1, i2 | i1 * i2).getAsLong() -- replace Long with appropriate type asBag => .collect(Collectors.toCollection(| new Bag)) asSequence / asSet / asOrderedSet => Same as asBag but replace Bag with desired type Please note that streams are one-shot and the pipeline cannot be re-used once a terminal operation is invoked (see the API for details).","title":"Native lambda expressions"},{"location":"doc/articles/lambda-expressions/#native-lambda-expressions","text":"Whilst EOL has many useful declarative operations built in, some applications and developers may benefit from using alternative implementations, such as the Java Streams API . Epsilon now allows you to invoke functional interfaces using EOL first-order operation syntax. Provided that the method being invoked takes one or more functional interface s as a parameter and the correct number of parameters are supplied to each interface, this integration should work seamlessly as with regular first-order operation call expressions. For lambda expressions which do not require a parameter, you can either omit the parameter, use null or _ in place of the parameter, like so: var optional = Native(\"java.util.stream.IntStream\") .range(0, 16) .filter(i | i / 4 >= 2) .findFirst(); optional.orElse(64/4); // No lambda - literal value always calculated even if not present. optional.orElseGet(null | someIntensiveCalculation()); // Evaluation only occurs if no value is present. optional.orElseThrow(| new Native(\"org.eclipse.epsilon.eol.exceptions.EolRuntimeException\")); Here is an example of how one could use Java Streams and the equivalent approach using EOL (i.e. without native delegation): var Collectors = Native(\"java.util.stream.Collectors\"); var testData = Sequence{-1024..1024}; var positiveOddsSquaredEol = testData .select(i | i >= 0 and i.mod(2) > 0) .collect(i | i * i) .asSet(); var positiveOddsSquaredJava = testData.stream() .filter(i | i >= 0 and i.mod(2) > 0) .map(i | i * i) .collect(Collectors.toSet()); assertEquals(positiveOddsSquaredEol, positiveOddsSquaredJava); One benefits of using Streams is lazy evaluation, which allows you to chain a series of operations without executing the entire pipeline on all elements. This can be more efficient since streams are not materialised in intermediate operations, unlike EOL first-order operations which always return a collection and are thus evaluated eagerly. As with built-in EOL operations, Streams also support parallel execution, although this must be explicitly specified with the .parallel() property on the stream. Currently EOL does not support operations which require a simple variable and non-functional interface as a parameter, such as the iterate operation. To work around this, you can assign lambda expressions to variables, deriving them by calling a built-in operation to obtain the desired type. // UnaryOperator var doubler = unary(i | i * 2); assertEquals(16, doubler.apply(8)); // Predicate var isEvenTester = predicate(i | i.mod(2) == 0); assertFalse(predicate.test(3)); // Function var hasher = func(x | x.hashCode()); assertEquals(-1007761232, hasher.apply(\"a string\")); // Consumer var printer = consumer(x | x.println()); printer.accept(\"Testing...\"); // Supplier var threadSafeCollectionMaker = supplier( | new Native(\"java.util.concurrent.ConcurrentLinkedDeque\")); var deque = threadSafeCollectionMaker.get(); // Runnable var sayHi = runnable( | \"Hello, World!\".println()); sayHi.run();","title":"Native lambda expressions"},{"location":"doc/articles/lambda-expressions/#streams-vs-eol-cheat-sheet","text":"Aside from the fact that streams are lazy and Epsilon operations are eager, there is some inevitable overlap in their functionality. This section provides an equivalence mapping from Epsilon to Java Streams to help you migrate from one to the other. select => filter collect => map forAll => allMatch exists => anyMatch none => noneMatch nMatch => No efficient short-circuiting equivalent, but result can be achieved using filter followed by .count() == n count => count one => Same as nMatch with n = 1 selectOne => filter followed by .findAny() / .findFirst() then .orElse(null) if the desired absence of a result is null reject => same as select with negated predicate sortBy => sorted mapBy => .collect(Collectors.groupingBy) aggregate => .collect(Collectors.toMap) In addition, non-first-order operations on Epsilon collection types can be simulated as follows for streams: flatten => .flatMap(c | c.stream()) -- please note that flatten is recursive whilst flatMap is not sum => .filter(e | e.isInteger()).mapToInt(i | i).sum() -- replace Int/Integer with appropriate type (Long, Double etc.) min / max => Same as sum but replace the last call with min or max as required product => Same as sum but replace the last call with .reduce(i1, i2 | i1 * i2).getAsLong() -- replace Long with appropriate type asBag => .collect(Collectors.toCollection(| new Bag)) asSequence / asSet / asOrderedSet => Same as asBag but replace Bag with desired type Please note that streams are one-shot and the pipeline cannot be re-used once a terminal operation is invoked (see the API for details).","title":"Streams vs EOL cheat sheet"},{"location":"doc/articles/manage-the-epsilon-website-locally/","text":"Manage the Epsilon web site locally \u00b6 This article provides a step-by-step guide for obtaining a local copy of the Epsilon website. The website is managed using the mkdocs library. The content is organised in different Markdown files, from which a static website can be generated. Setting up your environment \u00b6 Clone the Git repository at https://github.com/eclipse/epsilon-website . Download and install virtualenv . Navigate to the mkdocs folder, and run ./serve.sh from a terminal. The first time this command is run, a Python virtual environment will be created unther the mkdocs/env directory. After the environment is ready (and on subsequent calls to ./serve.sh ), a local web server containing the Epsilon website will be running at http://localhost:8000 . Real-time modification of the website \u00b6 All the Markdown sources of the website are contained in the mkdocs folder. After running the ./serve.sh command, we can alter these sources, and the changes will be reflected automatically in the local website. This is very useful to get quick feedback of our changes, as we do not have to regenerate the website each time we make a modification. To shutdown the local web server at any time, hit CTRL + C on the terminal you used to launch it in the first place. Building the static site \u00b6 Once you've happy with the changes you've made to the Markdown sources, you can re-generate the static website. To do so, run ./build.sh and wait for it to finish. Updating the website contents \u00b6 As a convention for project commiters, introducing a change in the website is usually separated in two commits: the first one contains any changes to the Markdown sources, while the second one includes the result of building again the static site as described in the previous section. If you are not a commiter, but you find any typos or parts of the website that do not work as they should, thanks for letting us know ! Pushing your changes \u00b6 There is a publish.sh script in the repo, which creates separate commits for the changes to mkdocs and the changes to the generated static files, and then pushes both commits to the remote repo. You can use it as follows: ./publish.sh \"Added new article\" . Finding broken links \u00b6 wget and grep can be used to find broken links in the Epsilon website. First, run the website locally by executing the ./serve.sh command as described above. Then, we will traverse the website using wget with this command: wget -e robots=off --spider -r --no-parent -o wget_errors.txt http://localhost:8000 We have used these options: -e robots=off makes wget ignore robots.txt . This is OK in this case, as we're running the spider on our own local server. --spider prevents wget from downloading page requisites that do not contain links -r makes wget traverse through links --no-parent prevents wget from leaving /gmt/epsilon/ -o wget_errors.txt collects all messages in the wget_errors.txt file Once it's done, we can simply search for the word \"404\" in the log, with: grep -B2 -w 404 wget_errors.txt We will get a list of all the URLs which reported 404 (Not Found) HTTP error codes.","title":"Manage the Epsilon web site locally"},{"location":"doc/articles/manage-the-epsilon-website-locally/#manage-the-epsilon-web-site-locally","text":"This article provides a step-by-step guide for obtaining a local copy of the Epsilon website. The website is managed using the mkdocs library. The content is organised in different Markdown files, from which a static website can be generated.","title":"Manage the Epsilon web site locally"},{"location":"doc/articles/manage-the-epsilon-website-locally/#setting-up-your-environment","text":"Clone the Git repository at https://github.com/eclipse/epsilon-website . Download and install virtualenv . Navigate to the mkdocs folder, and run ./serve.sh from a terminal. The first time this command is run, a Python virtual environment will be created unther the mkdocs/env directory. After the environment is ready (and on subsequent calls to ./serve.sh ), a local web server containing the Epsilon website will be running at http://localhost:8000 .","title":"Setting up your environment"},{"location":"doc/articles/manage-the-epsilon-website-locally/#real-time-modification-of-the-website","text":"All the Markdown sources of the website are contained in the mkdocs folder. After running the ./serve.sh command, we can alter these sources, and the changes will be reflected automatically in the local website. This is very useful to get quick feedback of our changes, as we do not have to regenerate the website each time we make a modification. To shutdown the local web server at any time, hit CTRL + C on the terminal you used to launch it in the first place.","title":"Real-time modification of the website"},{"location":"doc/articles/manage-the-epsilon-website-locally/#building-the-static-site","text":"Once you've happy with the changes you've made to the Markdown sources, you can re-generate the static website. To do so, run ./build.sh and wait for it to finish.","title":"Building the static site"},{"location":"doc/articles/manage-the-epsilon-website-locally/#updating-the-website-contents","text":"As a convention for project commiters, introducing a change in the website is usually separated in two commits: the first one contains any changes to the Markdown sources, while the second one includes the result of building again the static site as described in the previous section. If you are not a commiter, but you find any typos or parts of the website that do not work as they should, thanks for letting us know !","title":"Updating the website contents"},{"location":"doc/articles/manage-the-epsilon-website-locally/#pushing-your-changes","text":"There is a publish.sh script in the repo, which creates separate commits for the changes to mkdocs and the changes to the generated static files, and then pushes both commits to the remote repo. You can use it as follows: ./publish.sh \"Added new article\" .","title":"Pushing your changes"},{"location":"doc/articles/manage-the-epsilon-website-locally/#finding-broken-links","text":"wget and grep can be used to find broken links in the Epsilon website. First, run the website locally by executing the ./serve.sh command as described above. Then, we will traverse the website using wget with this command: wget -e robots=off --spider -r --no-parent -o wget_errors.txt http://localhost:8000 We have used these options: -e robots=off makes wget ignore robots.txt . This is OK in this case, as we're running the spider on our own local server. --spider prevents wget from downloading page requisites that do not contain links -r makes wget traverse through links --no-parent prevents wget from leaving /gmt/epsilon/ -o wget_errors.txt collects all messages in the wget_errors.txt file Once it's done, we can simply search for the word \"404\" in the log, with: grep -B2 -w 404 wget_errors.txt We will get a list of all the URLs which reported 404 (Not Found) HTTP error codes.","title":"Finding broken links"},{"location":"doc/articles/maven-release/","text":"Releasing Epsilon to Maven Central \u00b6 This article describes the overall process required to release a new stable release of Epsilon to Maven Central. There are a few steps involved, some of which are outside our control. The guide will describe the steps that we do control, and point you to the relevant resources for the others. Preparation \u00b6 The first step is to gain deploy rights to our org.eclipse.epsilon groupId in the Sonatype OSS Nexus repository. To do this, please register at the Sonatype JIRA and give your JIRA username to the Epsilon release engineer(s), so we may file a ticket to have deploy rights granted to you. Testing the Plain Maven build \u00b6 Our plain Maven artifacts are built through a parallel hierarchy of pom-plain.xml files, starting from the root of the Epsilon repository. To do a plain Maven compilation + test build from scratch, simply run this: mvn -f pom-plain.xml clean test Keep in mind that plain Maven builds do not run unit tests, as we already run those in the Tycho build. Make sure that all tests pass in the Tycho build first. Double check the dependencies in the various pom-plain.xml files, especially those related to external libraries. Check the project metadata in the pom-plain.xml file, which lists the current developers, SCM URLs, and other details. Preparing a Maven release \u00b6 Set the version in the pom-plain.xml files: mvn -f pom-plain.xml versions:set Enter the version number of the release, and create a commit for it: git add ... git commit -m \"Set pom-plain versions to X.Y.Z\" Push the commit to Jenkins: git push Here is an example commit . Typically this would be the last thing you do before tagging the release. After you've pushed this and tagged the repository with the Epsilon version, remember to bump the version to the next SNAPSHOT. Release to Maven Central \u00b6 The Jenkins build will automatically sign the plain Maven JARs and create a new staging repository in the OSSRH Sonatype Nexus server. It will also attempt to \"close\" it to modification, which will trigger the Maven Central validation rules. If one of these rules fail, the repository will be left open: the violations will be recorded in the Jenkins build logs, and you can try to manually close the repository and see those checks applied once more. As a precaution, we require all staging repositories to be manually checked before we release them to Maven Central. Once the Jenkins build passes, log into Sonatype OSS with your JIRA credentials and check the \"Staging Repositories\" section. Search for \"epsilon\" and you should be able to see the newly created staging repository. Select the repository and check in the \"Contents\" tab that everything is in order. If you are not happy with it, you can drop the repository, add more commits to the Maven release branch, and retry the upload. If you are happy with the contents, click on \"Release\" and enter an appropriate message in the \"Reason\" field (usually, \"Stable release RELEASE of Eclipse Epsilon\" suffices). After about an hour or so, the staging repository will disappear, and after a few hours the contents of the repository should be available from Maven Central . This may take up to a day, so be patient!","title":"Releasing Epsilon to Maven Central"},{"location":"doc/articles/maven-release/#releasing-epsilon-to-maven-central","text":"This article describes the overall process required to release a new stable release of Epsilon to Maven Central. There are a few steps involved, some of which are outside our control. The guide will describe the steps that we do control, and point you to the relevant resources for the others.","title":"Releasing Epsilon to Maven Central"},{"location":"doc/articles/maven-release/#preparation","text":"The first step is to gain deploy rights to our org.eclipse.epsilon groupId in the Sonatype OSS Nexus repository. To do this, please register at the Sonatype JIRA and give your JIRA username to the Epsilon release engineer(s), so we may file a ticket to have deploy rights granted to you.","title":"Preparation"},{"location":"doc/articles/maven-release/#testing-the-plain-maven-build","text":"Our plain Maven artifacts are built through a parallel hierarchy of pom-plain.xml files, starting from the root of the Epsilon repository. To do a plain Maven compilation + test build from scratch, simply run this: mvn -f pom-plain.xml clean test Keep in mind that plain Maven builds do not run unit tests, as we already run those in the Tycho build. Make sure that all tests pass in the Tycho build first. Double check the dependencies in the various pom-plain.xml files, especially those related to external libraries. Check the project metadata in the pom-plain.xml file, which lists the current developers, SCM URLs, and other details.","title":"Testing the Plain Maven build"},{"location":"doc/articles/maven-release/#preparing-a-maven-release","text":"Set the version in the pom-plain.xml files: mvn -f pom-plain.xml versions:set Enter the version number of the release, and create a commit for it: git add ... git commit -m \"Set pom-plain versions to X.Y.Z\" Push the commit to Jenkins: git push Here is an example commit . Typically this would be the last thing you do before tagging the release. After you've pushed this and tagged the repository with the Epsilon version, remember to bump the version to the next SNAPSHOT.","title":"Preparing a Maven release"},{"location":"doc/articles/maven-release/#release-to-maven-central","text":"The Jenkins build will automatically sign the plain Maven JARs and create a new staging repository in the OSSRH Sonatype Nexus server. It will also attempt to \"close\" it to modification, which will trigger the Maven Central validation rules. If one of these rules fail, the repository will be left open: the violations will be recorded in the Jenkins build logs, and you can try to manually close the repository and see those checks applied once more. As a precaution, we require all staging repositories to be manually checked before we release them to Maven Central. Once the Jenkins build passes, log into Sonatype OSS with your JIRA credentials and check the \"Staging Repositories\" section. Search for \"epsilon\" and you should be able to see the newly created staging repository. Select the repository and check in the \"Contents\" tab that everything is in order. If you are not happy with it, you can drop the repository, add more commits to the Maven release branch, and retry the upload. If you are happy with the contents, click on \"Release\" and enter an appropriate message in the \"Reason\" field (usually, \"Stable release RELEASE of Eclipse Epsilon\" suffices). After about an hour or so, the staging repository will disappear, and after a few hours the contents of the repository should be available from Maven Central . This may take up to a day, so be patient!","title":"Release to Maven Central"},{"location":"doc/articles/minimal-examples/","text":"Constructing a Helpful Minimal Example \u00b6 From time to time, you may run into a problem when using Epsilon or find a bug. In these instances, we're happy to provide technical support and we endeavour to ensure that no question on our forum goes unanswered. We often ask users to supply a minimal example that we can use to reproduce the problem on our machine. A high quality example often allows to send a much quicker and more accurate response. This article describes how to put together a useful example. Constructing Minimal Examples in the Epsilon Playground In many cases, the easiest way to create and share a minimal example is through the Epsilon Playground . Once you have put together your example, just click on the \"Share\" button and include the short link that pops up in your message on the forum. Please include the following: The version of Epsilon that you're running. Instructions for reproducing the problem A minimal version of all of the artefacts needed to reproduce the problem: models, metamodels (e.g. .ecore files), Epsilon programs (e.g. .eol, .evl, .etl, .egl files) Where applicable, Eclipse launch configurations or Ant build files for your Epsilon programs. An Eclipse project containing the minimal artefacts (and launch configurations or Ant build files). Please refrain from including files and folders that are not part of an Eclipse project as it is not always clear what we are expected to do with them. The remainder of this article contains hints and tips for each of the above. Once you have a minimal example, please attach it to a message in the forum or email it to us. Finding the version of Epsilon \u00b6 When developing and maintaining Epsilon, we often work on several versions of Epsilon at once: we maintain separate interim and stable versions, and we often use separate development branches for experimental features. Consequently, we need to ensure that we're running the same version of Epsilon as you in order to reproduce your problem. To identify which version of Epsilon you have: Click Help\u2192About Eclipse (on Mac OS X click Eclipse\u2192About Eclipse ). Click the Installation Details button Depending on how Epsilon has been installed, its version number may appear on the list of Installed Software : If not, click Plug-ins . Sort the list by the Plug-in id column by clicking the column title. Locate the row with org.eclipse.epsilon.eol.engine as its plug-in id, as shown below. Instructions for reproducing the problem \u00b6 When reproducing your problem requires more than one or two steps, a short set of instructions is a great help for us. Please try to provide a list of steps that we can follow to reproduce the problem. For example: Open Example.model, and add a new Node with name \"foo\". Run the Foo2Bar.etl transformation with the supplied launch configuration. Open Example.model. Note that the Node that you added has not changed: it has not been transformed! The Node named \"foo\" should now be named \"bar\". A minimal version \u00b6 Often, Epsilon users are manipulating large models with many thousands of elements, or executing Epsilon programs with many hundreds of lines of code. When investigating a problem or fixing a bug, it is extremely helpful for us to receive a minimal project that focuses exactly on the problem that you are encountering. In particular, please provide: A small number of models, metamodels and Epsilon programs (ideally 1 of each). Small models and metamodels (ideally with very few model elements). Small programs (ideally containing only the code required to reproduce the problem). No code screenshots or dumps, please Although it can take a little extra time for you to produce a minimal example, we really appreciate it. A minimal example allows us to spend more time fixing the problem and providing advice, and much less time trying to reproduce the problem on our end. Also, based on our experience, messages that provide a minimal example tend to get answered much faster. On the other hand, examples which indicate little/no effort from the reporter's side to narrow down (e.g. complete code dumps) or to help us reproduce (e.g. screenshots of code that we'd have to retype) the problem tend to be pushed back to the end of the queue and can take significantly longer to investigate. In some cases, building a minimal example is a great way to troubleshoot the problem that you're experiencing, and you may even find a solution to the problem while doing so. Epsilon launch configurations \u00b6 When launching an Epsilon program from within Eclipse, it is common to produce a launch configuration, which defines the models on which an Epsilon program is executed. By default, Eclipse does not store these launch configurations in your workspace and hence they are not included in projects that are exported from your workspace. To store an existing launch configuration in your workspace: Click Run\u2192Run Configurations . Select the Epsilon program for which you wish to store a launch configuration from the left-hand pane. Select the Common tab. By default, under Save as the Local option is selected. Click Shared file and then Browse . Select the project that contains the Epsilon program from the dialogue box, and then click Ok , as shown below. Click Apply . Close the Run Configurations dialogue box. Eclipse will create a new .launch file in your project, which contains all of the information needed to launch your Epsilon program, as shown below. Exporting an Eclipse project from your workspace \u00b6 Once you have created a project containing a minimal example (and launch configurations or Ant scripts), you can create an archive file which can be emailed to us: Right-click your Project Click Export... Under the General category, select Archive File and click Next . Ensure that the project(s) that you wish to export are checked in the left-hand pane. Supply a file name in the To archive file text box. Click Finish . Please email the resulting archive file to us.","title":"Constructing a Helpful Minimal Example"},{"location":"doc/articles/minimal-examples/#constructing-a-helpful-minimal-example","text":"From time to time, you may run into a problem when using Epsilon or find a bug. In these instances, we're happy to provide technical support and we endeavour to ensure that no question on our forum goes unanswered. We often ask users to supply a minimal example that we can use to reproduce the problem on our machine. A high quality example often allows to send a much quicker and more accurate response. This article describes how to put together a useful example. Constructing Minimal Examples in the Epsilon Playground In many cases, the easiest way to create and share a minimal example is through the Epsilon Playground . Once you have put together your example, just click on the \"Share\" button and include the short link that pops up in your message on the forum. Please include the following: The version of Epsilon that you're running. Instructions for reproducing the problem A minimal version of all of the artefacts needed to reproduce the problem: models, metamodels (e.g. .ecore files), Epsilon programs (e.g. .eol, .evl, .etl, .egl files) Where applicable, Eclipse launch configurations or Ant build files for your Epsilon programs. An Eclipse project containing the minimal artefacts (and launch configurations or Ant build files). Please refrain from including files and folders that are not part of an Eclipse project as it is not always clear what we are expected to do with them. The remainder of this article contains hints and tips for each of the above. Once you have a minimal example, please attach it to a message in the forum or email it to us.","title":"Constructing a Helpful Minimal Example"},{"location":"doc/articles/minimal-examples/#finding-the-version-of-epsilon","text":"When developing and maintaining Epsilon, we often work on several versions of Epsilon at once: we maintain separate interim and stable versions, and we often use separate development branches for experimental features. Consequently, we need to ensure that we're running the same version of Epsilon as you in order to reproduce your problem. To identify which version of Epsilon you have: Click Help\u2192About Eclipse (on Mac OS X click Eclipse\u2192About Eclipse ). Click the Installation Details button Depending on how Epsilon has been installed, its version number may appear on the list of Installed Software : If not, click Plug-ins . Sort the list by the Plug-in id column by clicking the column title. Locate the row with org.eclipse.epsilon.eol.engine as its plug-in id, as shown below.","title":"Finding the version of Epsilon"},{"location":"doc/articles/minimal-examples/#instructions-for-reproducing-the-problem","text":"When reproducing your problem requires more than one or two steps, a short set of instructions is a great help for us. Please try to provide a list of steps that we can follow to reproduce the problem. For example: Open Example.model, and add a new Node with name \"foo\". Run the Foo2Bar.etl transformation with the supplied launch configuration. Open Example.model. Note that the Node that you added has not changed: it has not been transformed! The Node named \"foo\" should now be named \"bar\".","title":"Instructions for reproducing the problem"},{"location":"doc/articles/minimal-examples/#a-minimal-version","text":"Often, Epsilon users are manipulating large models with many thousands of elements, or executing Epsilon programs with many hundreds of lines of code. When investigating a problem or fixing a bug, it is extremely helpful for us to receive a minimal project that focuses exactly on the problem that you are encountering. In particular, please provide: A small number of models, metamodels and Epsilon programs (ideally 1 of each). Small models and metamodels (ideally with very few model elements). Small programs (ideally containing only the code required to reproduce the problem). No code screenshots or dumps, please Although it can take a little extra time for you to produce a minimal example, we really appreciate it. A minimal example allows us to spend more time fixing the problem and providing advice, and much less time trying to reproduce the problem on our end. Also, based on our experience, messages that provide a minimal example tend to get answered much faster. On the other hand, examples which indicate little/no effort from the reporter's side to narrow down (e.g. complete code dumps) or to help us reproduce (e.g. screenshots of code that we'd have to retype) the problem tend to be pushed back to the end of the queue and can take significantly longer to investigate. In some cases, building a minimal example is a great way to troubleshoot the problem that you're experiencing, and you may even find a solution to the problem while doing so.","title":"A minimal version"},{"location":"doc/articles/minimal-examples/#epsilon-launch-configurations","text":"When launching an Epsilon program from within Eclipse, it is common to produce a launch configuration, which defines the models on which an Epsilon program is executed. By default, Eclipse does not store these launch configurations in your workspace and hence they are not included in projects that are exported from your workspace. To store an existing launch configuration in your workspace: Click Run\u2192Run Configurations . Select the Epsilon program for which you wish to store a launch configuration from the left-hand pane. Select the Common tab. By default, under Save as the Local option is selected. Click Shared file and then Browse . Select the project that contains the Epsilon program from the dialogue box, and then click Ok , as shown below. Click Apply . Close the Run Configurations dialogue box. Eclipse will create a new .launch file in your project, which contains all of the information needed to launch your Epsilon program, as shown below.","title":"Epsilon launch configurations"},{"location":"doc/articles/minimal-examples/#exporting-an-eclipse-project-from-your-workspace","text":"Once you have created a project containing a minimal example (and launch configurations or Ant scripts), you can create an archive file which can be emailed to us: Right-click your Project Click Export... Under the General category, select Archive File and click Next . Ensure that the project(s) that you wish to export are checked in the left-hand pane. Supply a file name in the To archive file text box. Click Finish . Please email the resulting archive file to us.","title":"Exporting an Eclipse project from your workspace"},{"location":"doc/articles/modular-flexmi/","text":"Modularity Mechanisms in Flexmi \u00b6","title":"Modularity Mechanisms in Flexmi"},{"location":"doc/articles/modular-flexmi/#modularity-mechanisms-in-flexmi","text":"","title":"Modularity Mechanisms in Flexmi"},{"location":"doc/articles/monitoring-and-instrumenting-epsilon-programs/","text":"Monitoring and Instrumenting Epsilon Programs \u00b6 Epsilon interpreters provide support for hooking into the execution of model management programs. This can be useful for monitoring and instrumenting Epsilon programs at runtime, and for computing metrics (e.g. model/metamodel/statement coverage, performance metrics) of interest. The listing below demonstrates parsing an EOL program and adding an IExecutionListener to its interpreter, which prints the program's statements/expressions to the console as soon as they are executed. public static void main ( String [] args ) throws Exception { EolModule module = new EolModule (); module . parse ( \"for (i in 1.to(10)) { i.println(); }\" ); module . getContext (). getExecutorFactory (). addExecutionListener ( new IExecutionListener () { @Override public void finishedExecutingWithException ( ModuleElement me , EolRuntimeException exception , IEolContext context ) {} @Override public void finishedExecuting ( ModuleElement me , Object result , IEolContext context ) { System . out . println ( me ); } @Override public void aboutToExecute ( ModuleElement me , IEolContext context ) {} } ); module . execute (); } To monitor the execution of an ETL transformation, EVL constraints etc. you can replace EolModule with EtlModule , EvlModule etc.","title":"Monitoring and Instrumenting Epsilon Programs"},{"location":"doc/articles/monitoring-and-instrumenting-epsilon-programs/#monitoring-and-instrumenting-epsilon-programs","text":"Epsilon interpreters provide support for hooking into the execution of model management programs. This can be useful for monitoring and instrumenting Epsilon programs at runtime, and for computing metrics (e.g. model/metamodel/statement coverage, performance metrics) of interest. The listing below demonstrates parsing an EOL program and adding an IExecutionListener to its interpreter, which prints the program's statements/expressions to the console as soon as they are executed. public static void main ( String [] args ) throws Exception { EolModule module = new EolModule (); module . parse ( \"for (i in 1.to(10)) { i.println(); }\" ); module . getContext (). getExecutorFactory (). addExecutionListener ( new IExecutionListener () { @Override public void finishedExecutingWithException ( ModuleElement me , EolRuntimeException exception , IEolContext context ) {} @Override public void finishedExecuting ( ModuleElement me , Object result , IEolContext context ) { System . out . println ( me ); } @Override public void aboutToExecute ( ModuleElement me , IEolContext context ) {} } ); module . execute (); } To monitor the execution of an ETL transformation, EVL constraints etc. you can replace EolModule with EtlModule , EvlModule etc.","title":"Monitoring and Instrumenting Epsilon Programs"},{"location":"doc/articles/parallel-execution/","text":"Multi-threaded execution of Epsilon programs \u00b6 Some of Epsilon's languages support parallel execution, which can leverage multiple hardware threads to improve performance. To enable this, head to the Advanced tab and select a parallel implementation. Where there are multiple implementations, prefer the \"Elements\" or \"Atom\" ones. An \"Atom\" is a tuple of a module element and model element, so for example a \"ContextAtom\" in EVL is context-element pair - that is, the granularity of parallelisation will be at the model element level (one job for every model element). Note that the modelling technology must also be able to handle concurrent query operations. Most modelling technologies will likely be supported for read-only model management tasks such as validation and code generation, however some which rely on external tools e.g. Simulink cannot handle concurrent operations. In any case, since most models support caching, the cache must be set up to support concurrency. You should ensure that the appropriate concurrency support option is checked in the model configuration. Note that when choosing a parallel implementation, first-order operations such as select , exists etc. will also be parallelised automatically where appropriate. This applies in particular to the parallel EOL implementation. Annotation-based parallelism \u00b6 In cases where an \"Annotation-based\" implementation is available, you can choose which rules are parallelised with the @parallel annotation. For example in EVL: context ModelElementType { @parallel constraint Invariant { check { // ... } } If further control is required, you can also choose whether a rule will be executed in parallel on a per-element basis using an executable annotation. This allows you to write a Boolean EOL expression to determine whether a given model element should be executed in parallel for the annotated rule. You can access the model element in the annotation with self as usual, and also any operations or variables in scope. Any rules not annotated will be executed sequentially. pre { var parallelThreshold = 9001; } context ModelElementType { $parallel self.children.size() > parallelThreshold; constraint Invariant { check { // ... } } Limitations \u00b6 Currently Epsilon does not support assignment of extended properties when executing in parallel. Parallel operations also cannot be nested.","title":"Multi-threaded execution of Epsilon programs"},{"location":"doc/articles/parallel-execution/#multi-threaded-execution-of-epsilon-programs","text":"Some of Epsilon's languages support parallel execution, which can leverage multiple hardware threads to improve performance. To enable this, head to the Advanced tab and select a parallel implementation. Where there are multiple implementations, prefer the \"Elements\" or \"Atom\" ones. An \"Atom\" is a tuple of a module element and model element, so for example a \"ContextAtom\" in EVL is context-element pair - that is, the granularity of parallelisation will be at the model element level (one job for every model element). Note that the modelling technology must also be able to handle concurrent query operations. Most modelling technologies will likely be supported for read-only model management tasks such as validation and code generation, however some which rely on external tools e.g. Simulink cannot handle concurrent operations. In any case, since most models support caching, the cache must be set up to support concurrency. You should ensure that the appropriate concurrency support option is checked in the model configuration. Note that when choosing a parallel implementation, first-order operations such as select , exists etc. will also be parallelised automatically where appropriate. This applies in particular to the parallel EOL implementation.","title":"Multi-threaded execution of Epsilon programs"},{"location":"doc/articles/parallel-execution/#annotation-based-parallelism","text":"In cases where an \"Annotation-based\" implementation is available, you can choose which rules are parallelised with the @parallel annotation. For example in EVL: context ModelElementType { @parallel constraint Invariant { check { // ... } } If further control is required, you can also choose whether a rule will be executed in parallel on a per-element basis using an executable annotation. This allows you to write a Boolean EOL expression to determine whether a given model element should be executed in parallel for the annotated rule. You can access the model element in the annotation with self as usual, and also any operations or variables in scope. Any rules not annotated will be executed sequentially. pre { var parallelThreshold = 9001; } context ModelElementType { $parallel self.children.size() > parallelThreshold; constraint Invariant { check { // ... } }","title":"Annotation-based parallelism"},{"location":"doc/articles/parallel-execution/#limitations","text":"Currently Epsilon does not support assignment of extended properties when executing in parallel. Parallel operations also cannot be nested.","title":"Limitations"},{"location":"doc/articles/picto-embedded-views/","text":"Embedding Picto views in a static Markdown or HTML document \u00b6 It is possible to include other Picto views in a static Markdown or HTML document. This feature is very useful to e.g. create on-the-fly reports concerning one or more models that can be later exported and shared for discussion. We will reuse the social network example depicted in the Picto documentation. The complete source code of this example is available here . The screenshot above depicts a visusalisation of a social network model. The Picto window shows a \"Readme\" view that is written in Markdown, and that contains other views from Picto's view tree. Static views in Picto \u00b6 Although it is possible to embed Picto views in any type of Picto visualisation, this embedding becomes specially useful in statically defined views, which are briefly introduced in the following. By default, the views that are included in the tree of a Picto visualisation are determined by the transformation selected in the .picto configuration file, which is generally an special EGX transformation. It is possible to add extra views by using the <view> tag in a Picto file: <?nsuri picto?> <picto format= \"egx\" transformation= \"picto/socialnetwork.egx\" > <view path= \"Custom, Alice and Bob\" icon= \"diagram-ff00ff\" type= \"Persons2Graphviz\" > <parameter name= \"names\" values= \"Alice, Bob\" /> </view> <view path= \"Readme\" icon= \"document\" format= \"markdown\" source= \"socialnetwork/readme.md\" position= \"0\" /> </picto> The snippet above shows the contents of the socialnetwork.model.picto file. The <picto> tag specifies the EGX transformation to use via the format and transformation attributes. Additionally, two <view> elements are added, of which we focus on the second one in this article, which is a static Picto view. A static Picto view depicts the contents of a static file. It can be defined by specifying its location in Picto's view tree (via the path and position attributes of the <view> tag) and the source and format of the file. In the example snippet, the \"Readme\" view appears first in the view tree ( position=\"0\" ), and it is using the socialnetwork/readme.md file of the example project, whose contents are depicted below: # Social network This is a simple way to represent network connections. ## Alice's network <a href=\"javascript:showView(['Social Network', 'Alice'])\">(Go to Alice)</a> <picto-view path=\"Social Network, Alice\"/> ## Embedded \"stats\" table view <picto-view path=\"Stats\" autoresize=\"true\"/> ## Embedded PlantUML (escaped backticks) \\```render-plantuml @startuml Alice -> Bob : Hello @enduml \\``` ## Static image ![ Epsilon logo ]( socialnetwork/epsilon.png ) Using the <picto-view> tag \u00b6 Embedding a Picto view is as easy as using the <picto-view> tag, specifying as path attribute the path of the view to be embedded in Picto's view tree. The Markdown file depicted above embeds two Picto views: the first one is Alice's social network (present in the Social Network > Alice path in the view tree), while the second one is the stats table of the whole model. As mentioned, the use of the <picto-view> tag is not limited to static views such as the one of the example, and can be used inside any kind of views (e.g. those created with EGL transformations). Iframes and Dynamic resizing of embedded views \u00b6 By default, an embedded picto view becomes as tall as the height of the contents that are originally rendered. However, the height of such contents might change dynamically, as it is the case of the stats table view: we can modify the number of elements shown in each page of the table, thus altering the required vertical space. For those cases where the height of a view might change dynamically, the autoresize attribute can be added to the <picto-view> tag to automatically adapt to such changes. In the example above, autoresize is set to true for the \"Stats\" view, so that pagination changes do not cause vertical cropping issues. If we only want to ensure that embedded views do not affect the host visualisation, we can enforce the use of an iframe by setting the iframe attribute to true . Note that setting autoresize to true also implies that an iframe will be used, so it is not necessary to specify both.","title":"Embedding Picto views in a static Markdown or HTML document"},{"location":"doc/articles/picto-embedded-views/#embedding-picto-views-in-a-static-markdown-or-html-document","text":"It is possible to include other Picto views in a static Markdown or HTML document. This feature is very useful to e.g. create on-the-fly reports concerning one or more models that can be later exported and shared for discussion. We will reuse the social network example depicted in the Picto documentation. The complete source code of this example is available here . The screenshot above depicts a visusalisation of a social network model. The Picto window shows a \"Readme\" view that is written in Markdown, and that contains other views from Picto's view tree.","title":"Embedding Picto views in a static Markdown or HTML document"},{"location":"doc/articles/picto-embedded-views/#static-views-in-picto","text":"Although it is possible to embed Picto views in any type of Picto visualisation, this embedding becomes specially useful in statically defined views, which are briefly introduced in the following. By default, the views that are included in the tree of a Picto visualisation are determined by the transformation selected in the .picto configuration file, which is generally an special EGX transformation. It is possible to add extra views by using the <view> tag in a Picto file: <?nsuri picto?> <picto format= \"egx\" transformation= \"picto/socialnetwork.egx\" > <view path= \"Custom, Alice and Bob\" icon= \"diagram-ff00ff\" type= \"Persons2Graphviz\" > <parameter name= \"names\" values= \"Alice, Bob\" /> </view> <view path= \"Readme\" icon= \"document\" format= \"markdown\" source= \"socialnetwork/readme.md\" position= \"0\" /> </picto> The snippet above shows the contents of the socialnetwork.model.picto file. The <picto> tag specifies the EGX transformation to use via the format and transformation attributes. Additionally, two <view> elements are added, of which we focus on the second one in this article, which is a static Picto view. A static Picto view depicts the contents of a static file. It can be defined by specifying its location in Picto's view tree (via the path and position attributes of the <view> tag) and the source and format of the file. In the example snippet, the \"Readme\" view appears first in the view tree ( position=\"0\" ), and it is using the socialnetwork/readme.md file of the example project, whose contents are depicted below: # Social network This is a simple way to represent network connections. ## Alice's network <a href=\"javascript:showView(['Social Network', 'Alice'])\">(Go to Alice)</a> <picto-view path=\"Social Network, Alice\"/> ## Embedded \"stats\" table view <picto-view path=\"Stats\" autoresize=\"true\"/> ## Embedded PlantUML (escaped backticks) \\```render-plantuml @startuml Alice -> Bob : Hello @enduml \\``` ## Static image ![ Epsilon logo ]( socialnetwork/epsilon.png )","title":"Static views in Picto"},{"location":"doc/articles/picto-embedded-views/#using-the-picto-view-tag","text":"Embedding a Picto view is as easy as using the <picto-view> tag, specifying as path attribute the path of the view to be embedded in Picto's view tree. The Markdown file depicted above embeds two Picto views: the first one is Alice's social network (present in the Social Network > Alice path in the view tree), while the second one is the stats table of the whole model. As mentioned, the use of the <picto-view> tag is not limited to static views such as the one of the example, and can be used inside any kind of views (e.g. those created with EGL transformations).","title":"Using the &lt;picto-view&gt; tag"},{"location":"doc/articles/picto-embedded-views/#iframes-and-dynamic-resizing-of-embedded-views","text":"By default, an embedded picto view becomes as tall as the height of the contents that are originally rendered. However, the height of such contents might change dynamically, as it is the case of the stats table view: we can modify the number of elements shown in each page of the table, thus altering the required vertical space. For those cases where the height of a view might change dynamically, the autoresize attribute can be added to the <picto-view> tag to automatically adapt to such changes. In the example above, autoresize is set to true for the \"Stats\" view, so that pagination changes do not cause vertical cropping issues. If we only want to ensure that embedded views do not affect the host visualisation, we can enforce the use of an iframe by setting the iframe attribute to true . Note that setting autoresize to true also implies that an iframe will be used, so it is not necessary to specify both.","title":"Iframes and Dynamic resizing of embedded views"},{"location":"doc/articles/picto-sequence-diagrams/","text":"Drill-Down Sequence Diagrams with Picto \u00b6 This article demonstrates using Picto and its PlantUML integration to generate drill-down sequence diagrams from models conforming to a minimal EMF-based sequence diagram language. Metamodel \u00b6 Below is the metamodel of our mini sequence-diagram ( minisd ) DSL (in Emfatic ). In our language, a scenario consists of a number of interactions between participants, and alternative execution paths ( Alt ). @namespace(uri=\"minisd\", prefix=\"\") package minisd; class Scenario extends Block {} class Participant { attr String name; } abstract class Step {} class Block extends Step { attr String title; val Step[*] steps; } class Alt extends Step { attr String title; val Block[*] blocks; } class Interaction extends Step { ref Participant from; ref Participant to; attr String message; } Customer-ATM Model \u00b6 Below is a Flexmi model that conforms to the minisd DSL and captures the interaction between a customer and an ATM. <?nsuri minisd?> <?render-egx minisd2plantuml.egx?> <_> <participant name= \"Customer\" /> <participant name= \"ATM\" /> <scenario title= \"Customer-ATM\" > <int from= \"Customer\" to= \"ATM\" msg= \"Insert card\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Request PIN\" /> <int from= \"Customer\" to= \"ATM\" msg= \"Enter PIN\" /> <alt title= \"Check PIN\" > <block title= \"PIN valid\" > <int from= \"ATM\" to= \"Customer\" msg= \"Display options\" /> <alt title= \"Options\" > <block title= \"Cash withdrawal\" > <int from= \"Customer\" to= \"ATM\" msg= \"Select cash withdrawal\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Ask for amount\" /> <int from= \"Customer\" to= \"ATM\" msg= \"Enter amount\" /> <alt title= \"Check funds\" > <block title= \"Sufficient funds\" > <int from= \"ATM\" to= \"Customer\" msg= \"Produce cash\" /> </block> <block title= \"Insufficient funds\" > <int from= \"ATM\" to= \"Customer\" msg= \"Produce error message\" /> </block> </alt> </block> <block title= \"Balance display\" > <int from= \"Customer\" to= \"ATM\" msg= \"Select balance display\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Display balance\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Return card\" /> </block> </alt> </block> <block title= \"PIN invalid\" > <int from= \"ATM\" to= \"Customer\" msg= \"Try again\" /> </block> </alt> </scenario> </_> Visualisation Transformation \u00b6 To visualise models that conform to the minisd DSL (such as the Customer-ATM model above) in Picto, we have written a model-to-text transformation in EGL, that transforms such models into a series of PlantUML sequence diagrams. In particular, the transformation produces one sequence diagram for the entire model, and one sequence diagram for each execution path in it. The EGX orchestration program and the EGL template are shown below. minisd2plantuml.egx rule Scenario2PlantUml transform s : Scenario { template : \"minisd2plantuml.egl\" parameters : Map { \"mainBlock\" = null, \"format\" = \"plantuml\", \"path\" = List{s.title}, \"icon\" = \"sequence\" } } rule Block2PlantUml transform b : Block { guard : b.eContainer.isTypeOf(Alt) template : \"minisd2plantuml.egl\" parameters : Map { \"mainBlock\" = b, \"format\" = \"plantuml\", \"path\" = b.closure(p|p.eContainer).invert().including(b).title, \"icon\" = \"block\" } } rule Alt2PlantUml transform a : Alt { parameters : Map { \"format\" = \"text\", \"path\" = a.closure(p|p.eContainer).invert().including(a).title, \"icon\" = \"alt\" } } minisd2plantuml.egl @startuml [% var excludedBlocks = Sequence{}; if (mainBlock.isDefined()) { var ancestors = mainBlock.closure(b|b.eContainer()).select(b|b.isTypeOf(Block)).including(mainBlock); for (a in ancestors) { if (a.eContainer().isDefined() and a.eContainer().isTypeOf(Alt)) { excludedBlocks.addAll(a.eContainer().blocks.excluding(a)); } } } %] [%=Scenario.all.first().toPlantUml()%] @enduml [% operation Scenario toPlantUml() { return self.steps.collect(s|s.toPlantUml()).concat(\"\\n\"); } operation Interaction toPlantUml() { return self.from.name + \"->\" + self.to.name + \": \" + self.message + \"\\n\"; } operation Alt toPlantUml() { var plantUml = \"\"; var visibleBlocks = self.blocks.excludingAll(excludedBlocks); for (b in visibleBlocks) { if (loopCount == 1) { plantUml += \"alt\"; if (mainBlock.isDefined() and mainBlock.eContainer == self) { plantUml += \" #azure\"; } } else plantUml += \"else \"; plantUml += \" \" + b.title; plantUml += \"\\n\" + b.toPlantUml(); } if (visibleBlocks.notEmpty()) plantUml += \"\\nend\\n\"; return plantUml; } operation Block toPlantUml() { if (excludedBlocks.contains(self)) return \"\"; return self.steps.collect(s|s.toPlantUml()).concat(\"\"); } %] Drill-Down Sequence Diagrams \u00b6 The result is a set of sequence diagrams that we can navigate to drill down the alternative interaction paths. Notice how selecting an alternative (e.g. Sufficient funds ) hides all irrelevant information from the sequence diagram (e.g. Balance display , PIN invalid ). Source code The complete source code for this example is in Epsilon's Git repository .","title":"Drill-Down Sequence Diagrams with Picto"},{"location":"doc/articles/picto-sequence-diagrams/#drill-down-sequence-diagrams-with-picto","text":"This article demonstrates using Picto and its PlantUML integration to generate drill-down sequence diagrams from models conforming to a minimal EMF-based sequence diagram language.","title":"Drill-Down Sequence Diagrams with Picto"},{"location":"doc/articles/picto-sequence-diagrams/#metamodel","text":"Below is the metamodel of our mini sequence-diagram ( minisd ) DSL (in Emfatic ). In our language, a scenario consists of a number of interactions between participants, and alternative execution paths ( Alt ). @namespace(uri=\"minisd\", prefix=\"\") package minisd; class Scenario extends Block {} class Participant { attr String name; } abstract class Step {} class Block extends Step { attr String title; val Step[*] steps; } class Alt extends Step { attr String title; val Block[*] blocks; } class Interaction extends Step { ref Participant from; ref Participant to; attr String message; }","title":"Metamodel"},{"location":"doc/articles/picto-sequence-diagrams/#customer-atm-model","text":"Below is a Flexmi model that conforms to the minisd DSL and captures the interaction between a customer and an ATM. <?nsuri minisd?> <?render-egx minisd2plantuml.egx?> <_> <participant name= \"Customer\" /> <participant name= \"ATM\" /> <scenario title= \"Customer-ATM\" > <int from= \"Customer\" to= \"ATM\" msg= \"Insert card\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Request PIN\" /> <int from= \"Customer\" to= \"ATM\" msg= \"Enter PIN\" /> <alt title= \"Check PIN\" > <block title= \"PIN valid\" > <int from= \"ATM\" to= \"Customer\" msg= \"Display options\" /> <alt title= \"Options\" > <block title= \"Cash withdrawal\" > <int from= \"Customer\" to= \"ATM\" msg= \"Select cash withdrawal\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Ask for amount\" /> <int from= \"Customer\" to= \"ATM\" msg= \"Enter amount\" /> <alt title= \"Check funds\" > <block title= \"Sufficient funds\" > <int from= \"ATM\" to= \"Customer\" msg= \"Produce cash\" /> </block> <block title= \"Insufficient funds\" > <int from= \"ATM\" to= \"Customer\" msg= \"Produce error message\" /> </block> </alt> </block> <block title= \"Balance display\" > <int from= \"Customer\" to= \"ATM\" msg= \"Select balance display\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Display balance\" /> <int from= \"ATM\" to= \"Customer\" msg= \"Return card\" /> </block> </alt> </block> <block title= \"PIN invalid\" > <int from= \"ATM\" to= \"Customer\" msg= \"Try again\" /> </block> </alt> </scenario> </_>","title":"Customer-ATM Model"},{"location":"doc/articles/picto-sequence-diagrams/#visualisation-transformation","text":"To visualise models that conform to the minisd DSL (such as the Customer-ATM model above) in Picto, we have written a model-to-text transformation in EGL, that transforms such models into a series of PlantUML sequence diagrams. In particular, the transformation produces one sequence diagram for the entire model, and one sequence diagram for each execution path in it. The EGX orchestration program and the EGL template are shown below. minisd2plantuml.egx rule Scenario2PlantUml transform s : Scenario { template : \"minisd2plantuml.egl\" parameters : Map { \"mainBlock\" = null, \"format\" = \"plantuml\", \"path\" = List{s.title}, \"icon\" = \"sequence\" } } rule Block2PlantUml transform b : Block { guard : b.eContainer.isTypeOf(Alt) template : \"minisd2plantuml.egl\" parameters : Map { \"mainBlock\" = b, \"format\" = \"plantuml\", \"path\" = b.closure(p|p.eContainer).invert().including(b).title, \"icon\" = \"block\" } } rule Alt2PlantUml transform a : Alt { parameters : Map { \"format\" = \"text\", \"path\" = a.closure(p|p.eContainer).invert().including(a).title, \"icon\" = \"alt\" } } minisd2plantuml.egl @startuml [% var excludedBlocks = Sequence{}; if (mainBlock.isDefined()) { var ancestors = mainBlock.closure(b|b.eContainer()).select(b|b.isTypeOf(Block)).including(mainBlock); for (a in ancestors) { if (a.eContainer().isDefined() and a.eContainer().isTypeOf(Alt)) { excludedBlocks.addAll(a.eContainer().blocks.excluding(a)); } } } %] [%=Scenario.all.first().toPlantUml()%] @enduml [% operation Scenario toPlantUml() { return self.steps.collect(s|s.toPlantUml()).concat(\"\\n\"); } operation Interaction toPlantUml() { return self.from.name + \"->\" + self.to.name + \": \" + self.message + \"\\n\"; } operation Alt toPlantUml() { var plantUml = \"\"; var visibleBlocks = self.blocks.excludingAll(excludedBlocks); for (b in visibleBlocks) { if (loopCount == 1) { plantUml += \"alt\"; if (mainBlock.isDefined() and mainBlock.eContainer == self) { plantUml += \" #azure\"; } } else plantUml += \"else \"; plantUml += \" \" + b.title; plantUml += \"\\n\" + b.toPlantUml(); } if (visibleBlocks.notEmpty()) plantUml += \"\\nend\\n\"; return plantUml; } operation Block toPlantUml() { if (excludedBlocks.contains(self)) return \"\"; return self.steps.collect(s|s.toPlantUml()).concat(\"\"); } %]","title":"Visualisation Transformation"},{"location":"doc/articles/picto-sequence-diagrams/#drill-down-sequence-diagrams","text":"The result is a set of sequence diagrams that we can navigate to drill down the alternative interaction paths. Notice how selecting an alternative (e.g. Sufficient funds ) hides all irrelevant information from the sequence diagram (e.g. Balance display , PIN invalid ). Source code The complete source code for this example is in Epsilon's Git repository .","title":"Drill-Down Sequence Diagrams"},{"location":"doc/articles/picto-tables/","text":"Generating table views in Picto \u00b6 This article shows how Picto is able to render CSV files as enhanced HTML tables provided by the Metro UI library, which include table styling, pagination, column sorting, and search capabilities. It also shows how the Pinset language can be used to create these table views without having to generate CSVs through a general-purpose model-to-text transformation. Rendering CSV files in the workspace \u00b6 Picto can be used to render CSV files present in an Eclipse project. The following figure shows the table generated for one of the output CSV files of the Pinset grading example: To automatically render CSV files in Picto, the Render verbatim sources option needs to be enabled. This option can be turned on temporarily in the top-right hamburger menu option of the Picto window, or it can be permanently set in the Eclipse preferences (Epsilon > Picto). Generating table views with a Pinset transformation \u00b6 Pinset is a domain-specific transformation language that allows extracting tabular datasets from models. Initially devised for data analysis purposes, this language can be used along Picto to generate table-based model visualisations. In the Social Network example that can be found in the Picto documentation, one of the views is generated with the following Pinset dataset rule: dataset personStats over person : Person { properties[name] column liked_by : Person.all.select(p | p.likes.includes(person)).size() column liking : person.likes.size() column disliked_by : Person.all.select(p | p.dislikes.includes(person)).size() column disliking : person.dislikes.size() column like_meter : liked_by - disliked_by } Briefly, a Pinset dataset rule contains EOL-based definitions of the different columns of the output dataset. These columns operate over elements of the input model (such as the Person elements in the rule above) to create the dataset rows. In the example, likes and dislikes counts are obtained for each Person element in the dataset. Check the Pinset documentation for more information about other features of the language such as advanced column generators. To use the above Pinset rule to create a Picto view in the social network model visualisation, the following EGX rule is present in the picto/socialnetwork.egx file: rule Persons2Table { template : \"persons2table.pinset\" parameters : Map { \"path\" = Sequence{\"Stats\"}, \"icon\" = \"table\", \"format\" = \"csv\" // ,\"pinsetrule\" = \"otherStats\" } } The EGX rule above is very similar to the ones normally used for EGL templates. As differences, the rule points to a .pinset template file where the Pinset dataset rules are contained, and the defined icon and format are table and csv respectivelly. Lastly, as a Pinset file can contain several dataset rules, it is possible to select which rule to use in the visualisation with the pinsetrule parameter (commented out in the rule above). The above EGX and Pinset rules generate the following table view:","title":"Generating table views in Picto"},{"location":"doc/articles/picto-tables/#generating-table-views-in-picto","text":"This article shows how Picto is able to render CSV files as enhanced HTML tables provided by the Metro UI library, which include table styling, pagination, column sorting, and search capabilities. It also shows how the Pinset language can be used to create these table views without having to generate CSVs through a general-purpose model-to-text transformation.","title":"Generating table views in Picto"},{"location":"doc/articles/picto-tables/#rendering-csv-files-in-the-workspace","text":"Picto can be used to render CSV files present in an Eclipse project. The following figure shows the table generated for one of the output CSV files of the Pinset grading example: To automatically render CSV files in Picto, the Render verbatim sources option needs to be enabled. This option can be turned on temporarily in the top-right hamburger menu option of the Picto window, or it can be permanently set in the Eclipse preferences (Epsilon > Picto).","title":"Rendering CSV files in the workspace"},{"location":"doc/articles/picto-tables/#generating-table-views-with-a-pinset-transformation","text":"Pinset is a domain-specific transformation language that allows extracting tabular datasets from models. Initially devised for data analysis purposes, this language can be used along Picto to generate table-based model visualisations. In the Social Network example that can be found in the Picto documentation, one of the views is generated with the following Pinset dataset rule: dataset personStats over person : Person { properties[name] column liked_by : Person.all.select(p | p.likes.includes(person)).size() column liking : person.likes.size() column disliked_by : Person.all.select(p | p.dislikes.includes(person)).size() column disliking : person.dislikes.size() column like_meter : liked_by - disliked_by } Briefly, a Pinset dataset rule contains EOL-based definitions of the different columns of the output dataset. These columns operate over elements of the input model (such as the Person elements in the rule above) to create the dataset rows. In the example, likes and dislikes counts are obtained for each Person element in the dataset. Check the Pinset documentation for more information about other features of the language such as advanced column generators. To use the above Pinset rule to create a Picto view in the social network model visualisation, the following EGX rule is present in the picto/socialnetwork.egx file: rule Persons2Table { template : \"persons2table.pinset\" parameters : Map { \"path\" = Sequence{\"Stats\"}, \"icon\" = \"table\", \"format\" = \"csv\" // ,\"pinsetrule\" = \"otherStats\" } } The EGX rule above is very similar to the ones normally used for EGL templates. As differences, the rule points to a .pinset template file where the Pinset dataset rules are contained, and the defined icon and format are table and csv respectivelly. Lastly, as a Pinset file can contain several dataset rules, it is possible to select which rule to use in the visualisation with the pinsetrule parameter (commented out in the rule above). The above EGX and Pinset rules generate the following table view:","title":"Generating table views with a Pinset transformation"},{"location":"doc/articles/picto-xtext/","text":"Visualising Xtext Models with Picto \u00b6 This article shows how Picto can be used to produce graphical views from Xtext-based models. To demonstrate the Picto/Xtext integration, we use the Entity DSL showcased in the 15' Xtext tutorial . Setup \u00b6 Import the projects below from the examples folder of the Epsilon Git repository org.eclipse.epsilon.examples.picto.xtext.domainmodel org.eclipse.epsilon.examples.picto.xtext.domainmodel.ide org.eclipse.epsilon.examples.picto.xtext.domainmodel.ui org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto Right-click on Domainmodel.xtext and select Run As \u2192 Generate Xtext Artefacts Run a nested Eclipse instance. In the nested Eclipse instance workspace, create a new file named blog.dmodel with the content below: datatype String entity Blog { title: String many posts: Post } entity HasAuthor { author: String } entity Post extends HasAuthor { title: String content: String many comments: Comment } entity Comment extends HasAuthor { content: String many responses: Comment } Open the Picto view from the Window \u2192 Show View menu. Go through the produced graphical views as shown in the image above. The Picto-Xtext Integration Plugin Project \u00b6 We now dive into the org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto project which contains the Picto-Xtext integration code (the rest of the projects are standard Xtext projects). The DmodelPictoSource class \u00b6 This class extends Picto's built-in EglPictoSource class and produces graphical views in Picto from *.dmodel files edited in an Xtext-based editor. In particular: The supportsEditorType method specifies that this class contributes visualisation capabilities to Xtext-based editors, the title of which ends with .dmodel The getRenderingMetadata method specifies the EGL transformation that produces the graphical views every time an editor of interest is opened, activated or saved. The getFile and getResource methods extract an IFile and an EMF Resource from the editor of interest and should be reusable without changes for other Xtext-based languages too. The showElement method reveals and highlights the element with the specified id in the Xtext editor, enabling navigation back to the source model of the view. package org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto ; import org.eclipse.core.resources.IFile ; import org.eclipse.emf.ecore.resource.Resource ; import org.eclipse.epsilon.picto.dom.Picto ; import org.eclipse.epsilon.picto.dom.PictoFactory ; import org.eclipse.epsilon.picto.source.EglPictoSource ; import org.eclipse.jface.text.source.ISourceViewer ; import org.eclipse.ui.IEditorInput ; import org.eclipse.ui.IEditorPart ; import org.eclipse.ui.IFileEditorInput ; import org.eclipse.ui.PlatformUI ; import org.eclipse.xtext.nodemodel.ICompositeNode ; import org.eclipse.xtext.nodemodel.util.NodeModelUtils ; import org.eclipse.xtext.resource.XtextResource ; import org.eclipse.xtext.ui.editor.XtextEditor ; import org.eclipse.xtext.ui.workspace.WorkspaceLockAccess.Result ; import org.eclipse.xtext.util.concurrent.IUnitOfWork ; public class DmodelPictoSource extends EglPictoSource { @Override protected Picto getRenderingMetadata ( IEditorPart editorPart ) { Picto metadata = PictoFactory . eINSTANCE . createPicto (); metadata . setTransformation ( \"platform:/plugin/org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto/dmodel.egx\" ); return metadata ; } @Override protected Resource getResource ( IEditorPart editorPart ) { XtextEditor editor = ( XtextEditor ) editorPart ; final XtextResourceHolder holder = new XtextResourceHolder (); editor . getDocument (). readOnly ( new IUnitOfWork < Result , XtextResource > () { public Result exec ( XtextResource state ) throws Exception { holder . setResource ( state ); return null ; }; }); return holder . getResource (); } @Override protected IFile getFile ( IEditorPart editorPart ) { IEditorInput editorInput = (( XtextEditor ) editorPart ). getEditorInput (); if ( editorInput instanceof IFileEditorInput ) { return (( IFileEditorInput ) editorInput ). getFile (); } return null ; } @Override protected boolean supportsEditorType ( IEditorPart editorPart ) { return editorPart instanceof XtextEditor && editorPart . getTitle (). endsWith ( \".dmodel\" ); } @Override public void showElement ( String id , String uri , IEditorPart editor ) { ICompositeNode node = NodeModelUtils . getNode ( getResource ( editor ). getEObject ( id )); if ( node != null ) { ISourceViewer textViewer = (( XtextEditor ) editor ). getInternalSourceViewer (); int offset = node . getOffset (); int length = node . getLength (); textViewer . setRangeIndication ( offset , length , true ); textViewer . revealRange ( offset , length ); textViewer . setSelectedRange ( offset , length ); PlatformUI . getWorkbench (). getActiveWorkbenchWindow (). getActivePage (). activate ( editor ); } } } Picto is made aware of this class through the org.eclipse.epsilon.picto.pictoSource extension in the project's plugin.xml . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <?eclipse version=\"3.4\"?> <plugin> <extension point= \"org.eclipse.epsilon.picto.pictoSource\" > <pictoSource class= \"org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto.DmodelPictoSource\" > </pictoSource> </extension> </plugin> The Visualisation Transformation \u00b6 The visualisation transformation has been implemented using Epsilon's EGL model-to-text transformation language and produces Graphviz-based class diagrams from the active entity model. The transformation consists of the dmodel.egx coordination rules, and the entity2graphviz.egl template shown below. The transformation produces one view for each entity in the model, which consists of the entity itself, any super/sub-types it may have, as well as other entities that it is related to. dmodel.egx rule Entity2Graphviz transform e : Entity { template : \"entity2graphviz.egl\" parameters : Map{ \"path\" = Sequence{\"Model\", e.name}, \"icon\" = \"diagram-ffffff\", \"format\" = \"graphviz-dot\" } } entity2graphviz.egl digraph G { graph[splines=ortho] node[fontname=Arial, fontsize=10, shape=record] edge[fontname=Arial, fontsize=10] [%var entities = getVisibleEntities();%] [%for (e in entities){%] [%=e.getNodeName()%][shape=none, margin=0, label=<[%=e.getLabel()%]>] [%}%] [%for (f in e.features.flatten().select(f|f.type.isTypeOf(Entity) and f.type <> e)){%] [%=f.eContainer.getNodeName()%]->[%=f.type.getNodeName()%][arrowhead=[%=f.getArrow()%],arrowtail=none,tooltip=\"[%=f.name%]\"]; [%}%] [%if (e.superType.isDefined()){%] [%=e.superType.getNodeName()%]->[%=e.getNodeName()%][arrowhead=none,arrowtail=empty,dir=back]; [%}%] [%for (s in Entity.all.select(en|en.superType = e)){%] [%=e.getNodeName()%]->[%=s.getNodeName()%][arrowhead=none,arrowtail=empty,dir=back]; [%}%] } [% operation Entity getLabel() { var onClick = \"top.showView(['Model','\" + self.name + \"'])\"; if (self == e) { onClick = \"top.showElement('\" + self.id + \"', '\" + self.eResource.uri + \"')\"; } var label = \"<table cellspacing='0' cellborder='0' cellpadding='1' bgcolor='\" + self.getColour() + \"'>\"; label += \"<tr><td sides='B' colspan='2' border='1' cellpadding='0'>\" + \"<table border='0' cellspacing='0' cellborder='0'>\" + \"<tr><td align='right' valign='middle'><img src='\" + self.getIcon()+ \"'></img></td>\" + \"<td align='left' valign='middle' href=\\\"javascript:\" + onClick + \"\\\" tooltip='Go'>\" + self.name + \" </td></tr></table></td></tr>\"; label += \"<tr><td></td><td></td></tr>\"; for (f in self.features.sortBy(a|a.name.toLowerCase())) { label += \"<tr>\"; label += \"<td><img src='\" + f.getIcon() + \"'></img></td><td align='left'>\" + f.getLabel() + \"</td>\"; label += \"</tr>\"; } if (self.features.isEmpty()){ label += \"<tr>\"; label += \"<td> </td><td> </td>\"; label += \"</tr>\"; } label += \"</table>\"; return label; } operation Entity getIcon() { return getImage(\"icons/entity.gif\"); } operation Feature getLabel() { return self.name + \" : \" + self.type?.name + (self.many ? \"[\"+\"*\"+\"]\" : \"\") ; } operation Feature getIcon() { return getImage(\"icons/attribute.gif\"); } operation Entity getNodeName() { return \"_Entity\" + Entity.all.indexOf(self); } operation Feature getArrow() { if (self.many) { return \"crow\"; } else { return \"open\"; } } operation getVisibleEntities() { var visibleEntities : Set; visibleEntities.add(e); visibleEntities.addAll(e.features.select(f|f.type.isTypeOf(Entity)).collect(f|f.type)); if (e.superType.isDefined()) visibleEntities.add(e.superType); visibleEntities.addAll(Entity.all.select(en|en.superType = e)); return visibleEntities; } operation Entity getColour() { if (self == e) return \"#fff2d2\"; else return \"#fffcdc\"; } %] Interactive Diagrams \u00b6 As shown below, you can navigate between diagrams and back to the Xtext editor using Picto's built-in showElement and showView JavaScript functions . Lazy Execution \u00b6 Since Picto executes EGL transformations lazily when the entity model is saved, only the view that is currently visible is regenerated immediately, which is useful when working with large models.","title":"Visualising Xtext Models with Picto"},{"location":"doc/articles/picto-xtext/#visualising-xtext-models-with-picto","text":"This article shows how Picto can be used to produce graphical views from Xtext-based models. To demonstrate the Picto/Xtext integration, we use the Entity DSL showcased in the 15' Xtext tutorial .","title":"Visualising Xtext Models with Picto"},{"location":"doc/articles/picto-xtext/#setup","text":"Import the projects below from the examples folder of the Epsilon Git repository org.eclipse.epsilon.examples.picto.xtext.domainmodel org.eclipse.epsilon.examples.picto.xtext.domainmodel.ide org.eclipse.epsilon.examples.picto.xtext.domainmodel.ui org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto Right-click on Domainmodel.xtext and select Run As \u2192 Generate Xtext Artefacts Run a nested Eclipse instance. In the nested Eclipse instance workspace, create a new file named blog.dmodel with the content below: datatype String entity Blog { title: String many posts: Post } entity HasAuthor { author: String } entity Post extends HasAuthor { title: String content: String many comments: Comment } entity Comment extends HasAuthor { content: String many responses: Comment } Open the Picto view from the Window \u2192 Show View menu. Go through the produced graphical views as shown in the image above.","title":"Setup"},{"location":"doc/articles/picto-xtext/#the-picto-xtext-integration-plugin-project","text":"We now dive into the org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto project which contains the Picto-Xtext integration code (the rest of the projects are standard Xtext projects).","title":"The Picto-Xtext Integration Plugin Project"},{"location":"doc/articles/picto-xtext/#the-dmodelpictosource-class","text":"This class extends Picto's built-in EglPictoSource class and produces graphical views in Picto from *.dmodel files edited in an Xtext-based editor. In particular: The supportsEditorType method specifies that this class contributes visualisation capabilities to Xtext-based editors, the title of which ends with .dmodel The getRenderingMetadata method specifies the EGL transformation that produces the graphical views every time an editor of interest is opened, activated or saved. The getFile and getResource methods extract an IFile and an EMF Resource from the editor of interest and should be reusable without changes for other Xtext-based languages too. The showElement method reveals and highlights the element with the specified id in the Xtext editor, enabling navigation back to the source model of the view. package org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto ; import org.eclipse.core.resources.IFile ; import org.eclipse.emf.ecore.resource.Resource ; import org.eclipse.epsilon.picto.dom.Picto ; import org.eclipse.epsilon.picto.dom.PictoFactory ; import org.eclipse.epsilon.picto.source.EglPictoSource ; import org.eclipse.jface.text.source.ISourceViewer ; import org.eclipse.ui.IEditorInput ; import org.eclipse.ui.IEditorPart ; import org.eclipse.ui.IFileEditorInput ; import org.eclipse.ui.PlatformUI ; import org.eclipse.xtext.nodemodel.ICompositeNode ; import org.eclipse.xtext.nodemodel.util.NodeModelUtils ; import org.eclipse.xtext.resource.XtextResource ; import org.eclipse.xtext.ui.editor.XtextEditor ; import org.eclipse.xtext.ui.workspace.WorkspaceLockAccess.Result ; import org.eclipse.xtext.util.concurrent.IUnitOfWork ; public class DmodelPictoSource extends EglPictoSource { @Override protected Picto getRenderingMetadata ( IEditorPart editorPart ) { Picto metadata = PictoFactory . eINSTANCE . createPicto (); metadata . setTransformation ( \"platform:/plugin/org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto/dmodel.egx\" ); return metadata ; } @Override protected Resource getResource ( IEditorPart editorPart ) { XtextEditor editor = ( XtextEditor ) editorPart ; final XtextResourceHolder holder = new XtextResourceHolder (); editor . getDocument (). readOnly ( new IUnitOfWork < Result , XtextResource > () { public Result exec ( XtextResource state ) throws Exception { holder . setResource ( state ); return null ; }; }); return holder . getResource (); } @Override protected IFile getFile ( IEditorPart editorPart ) { IEditorInput editorInput = (( XtextEditor ) editorPart ). getEditorInput (); if ( editorInput instanceof IFileEditorInput ) { return (( IFileEditorInput ) editorInput ). getFile (); } return null ; } @Override protected boolean supportsEditorType ( IEditorPart editorPart ) { return editorPart instanceof XtextEditor && editorPart . getTitle (). endsWith ( \".dmodel\" ); } @Override public void showElement ( String id , String uri , IEditorPart editor ) { ICompositeNode node = NodeModelUtils . getNode ( getResource ( editor ). getEObject ( id )); if ( node != null ) { ISourceViewer textViewer = (( XtextEditor ) editor ). getInternalSourceViewer (); int offset = node . getOffset (); int length = node . getLength (); textViewer . setRangeIndication ( offset , length , true ); textViewer . revealRange ( offset , length ); textViewer . setSelectedRange ( offset , length ); PlatformUI . getWorkbench (). getActiveWorkbenchWindow (). getActivePage (). activate ( editor ); } } } Picto is made aware of this class through the org.eclipse.epsilon.picto.pictoSource extension in the project's plugin.xml . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <?eclipse version=\"3.4\"?> <plugin> <extension point= \"org.eclipse.epsilon.picto.pictoSource\" > <pictoSource class= \"org.eclipse.epsilon.examples.picto.xtext.domainmodel.picto.DmodelPictoSource\" > </pictoSource> </extension> </plugin>","title":"The DmodelPictoSource class"},{"location":"doc/articles/picto-xtext/#the-visualisation-transformation","text":"The visualisation transformation has been implemented using Epsilon's EGL model-to-text transformation language and produces Graphviz-based class diagrams from the active entity model. The transformation consists of the dmodel.egx coordination rules, and the entity2graphviz.egl template shown below. The transformation produces one view for each entity in the model, which consists of the entity itself, any super/sub-types it may have, as well as other entities that it is related to. dmodel.egx rule Entity2Graphviz transform e : Entity { template : \"entity2graphviz.egl\" parameters : Map{ \"path\" = Sequence{\"Model\", e.name}, \"icon\" = \"diagram-ffffff\", \"format\" = \"graphviz-dot\" } } entity2graphviz.egl digraph G { graph[splines=ortho] node[fontname=Arial, fontsize=10, shape=record] edge[fontname=Arial, fontsize=10] [%var entities = getVisibleEntities();%] [%for (e in entities){%] [%=e.getNodeName()%][shape=none, margin=0, label=<[%=e.getLabel()%]>] [%}%] [%for (f in e.features.flatten().select(f|f.type.isTypeOf(Entity) and f.type <> e)){%] [%=f.eContainer.getNodeName()%]->[%=f.type.getNodeName()%][arrowhead=[%=f.getArrow()%],arrowtail=none,tooltip=\"[%=f.name%]\"]; [%}%] [%if (e.superType.isDefined()){%] [%=e.superType.getNodeName()%]->[%=e.getNodeName()%][arrowhead=none,arrowtail=empty,dir=back]; [%}%] [%for (s in Entity.all.select(en|en.superType = e)){%] [%=e.getNodeName()%]->[%=s.getNodeName()%][arrowhead=none,arrowtail=empty,dir=back]; [%}%] } [% operation Entity getLabel() { var onClick = \"top.showView(['Model','\" + self.name + \"'])\"; if (self == e) { onClick = \"top.showElement('\" + self.id + \"', '\" + self.eResource.uri + \"')\"; } var label = \"<table cellspacing='0' cellborder='0' cellpadding='1' bgcolor='\" + self.getColour() + \"'>\"; label += \"<tr><td sides='B' colspan='2' border='1' cellpadding='0'>\" + \"<table border='0' cellspacing='0' cellborder='0'>\" + \"<tr><td align='right' valign='middle'><img src='\" + self.getIcon()+ \"'></img></td>\" + \"<td align='left' valign='middle' href=\\\"javascript:\" + onClick + \"\\\" tooltip='Go'>\" + self.name + \" </td></tr></table></td></tr>\"; label += \"<tr><td></td><td></td></tr>\"; for (f in self.features.sortBy(a|a.name.toLowerCase())) { label += \"<tr>\"; label += \"<td><img src='\" + f.getIcon() + \"'></img></td><td align='left'>\" + f.getLabel() + \"</td>\"; label += \"</tr>\"; } if (self.features.isEmpty()){ label += \"<tr>\"; label += \"<td> </td><td> </td>\"; label += \"</tr>\"; } label += \"</table>\"; return label; } operation Entity getIcon() { return getImage(\"icons/entity.gif\"); } operation Feature getLabel() { return self.name + \" : \" + self.type?.name + (self.many ? \"[\"+\"*\"+\"]\" : \"\") ; } operation Feature getIcon() { return getImage(\"icons/attribute.gif\"); } operation Entity getNodeName() { return \"_Entity\" + Entity.all.indexOf(self); } operation Feature getArrow() { if (self.many) { return \"crow\"; } else { return \"open\"; } } operation getVisibleEntities() { var visibleEntities : Set; visibleEntities.add(e); visibleEntities.addAll(e.features.select(f|f.type.isTypeOf(Entity)).collect(f|f.type)); if (e.superType.isDefined()) visibleEntities.add(e.superType); visibleEntities.addAll(Entity.all.select(en|en.superType = e)); return visibleEntities; } operation Entity getColour() { if (self == e) return \"#fff2d2\"; else return \"#fffcdc\"; } %]","title":"The Visualisation Transformation"},{"location":"doc/articles/picto-xtext/#interactive-diagrams","text":"As shown below, you can navigate between diagrams and back to the Xtext editor using Picto's built-in showElement and showView JavaScript functions .","title":"Interactive Diagrams"},{"location":"doc/articles/picto-xtext/#lazy-execution","text":"Since Picto executes EGL transformations lazily when the entity model is saved, only the view that is currently visible is regenerated immediately, which is useful when working with large models.","title":"Lazy Execution"},{"location":"doc/articles/plain-xml/","text":"Scripting XML documents using Epsilon \u00b6 In this article we demonstrate how you can create, query and modify plain standalone XML documents (i.e. no XSD/DTD needed) in Epsilon programs using the PlainXML driver added in version 0.8.9. All the examples in this article demonstrate using EOL to script XML documents. However, it's worth stressing that XML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or to text), compare and merge your XML documents. Querying an XML document \u00b6 We use the following library.xml as a base for demonstrating the EOL syntax for querying XML documents. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" > <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" > <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" > <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> Querying/modifying XML documents in EOL \u00b6 The PlainXML driver uses predefined naming conventions to allow developers to programmatically access and modify XML documents in a concise way. This section outlines the supported conventions in the form of questions and answers followed by relevant examples. How can I access elements by tag name? \u00b6 The t_ prefix in front of the name of the tag is used to represent a type, instances of which are all the elements with that tag. For instance, t_book.all can be used to get all elements tagged as <book> in the document, t_author.all to retrieve all <author> elements etc. Also, if b is an element with a <book> tag, then b.isTypeOf(t_book) shall return true. If the tag name contains hyphens, underscores, and/or periods, you must escape the complete type name inside back ticks: `t_first-name // Get all <book> elements var books = t_book.all; // Get a random book var b = books.random(); // Check if b is a book // Prints 'true' b.isTypeOf(t_book).println(); // Check if b is a library // Prints 'false' b.isTypeOf(t_library).println(); How can I get the tag name of an element? \u00b6 You can use the .name property for this purpose. For instance, if b is an element tagged as <book> , b.name shall return book . The name property is read-only. // Get a random <book> element var b = t_book.all.random(); // Print its tag // Prints 'book' b.name.println(); tagName property is deprecated Previously the tagName property was suggested for getting the tag name of an element. Due to the introduction of modules in Java 9 accessing this property is deprecated and future use can result in run time exceptions. How can I get/set the attributes of an element? \u00b6 You can use the attribute name as a property of the element object, prefixed by a_ . For example, if b is the first book of library.xml , b.a_title will return EMF Eclipse Modeling Framework . Attribute properties are read/write. In this example, b.a_pages will return 744 as a string. For 744 to be returned as an integer instead, the i_ prefix should be used instead (i.e. b.i_pages . The driver also supports the following preffixes: b_ for boolean, s_ for string (alias of a_ ) and r_ for real values. // Print all the titles of the books in the library for (b in t_book.all) { b.a_title.println(); } // Print the total number of pages of all books var total = 0; for (b in t_book.all) { total = total + b.i_pages; } total.print(); // ... the same using collect() and sum() // instead of a for loop t_book.all.collect(b|b.i_pages).sum(); How can I get/set the text of an element? \u00b6 You can use the .text read-write property for this. for (author in t_author.all) { author.text.println(); } How do I get the parent of an element? \u00b6 You can use the .parentNode read-only property for this. // Get a random book var b = t_book.all.random(); // Print the tag of its parent node // Prints 'library' b.parentNode.name.println(); How do I get the children of an element? \u00b6 You can use the .children read-only property for this. // Get the <library> element var lib = t_library.all.first(); // Iterate through its children for (b in lib.children) { // Print the title of each child b.a_title.println(); } How do I get child elements with a specific tag name? \u00b6 Using what you've learned so far, you can do this using a combination of the .children property and the select/selectOne() operations. However, the driver also supports e_ and c_ -prefixed shorthand properties for accessing one or a collection of elements with the specified name respectively. e_ and c_ properties are read-only. // Get a random book var b = t_book.all.random(); // Get its <author> children using the // .children property var authors = b.children.select(a|a.name = \"author\"); // Do the same using the shorthand authors = b.c_author; // Get its <published> child and print // its text using the // .children property b.children.selectOne(p|p.name = \"published\").text.println(); // Do the same using the shorthand // (e_ instead of c_ this time as // we only want one element, // not a collection of them) b.e_published.text.println(); How do I create an element? \u00b6 You can use the new operator for this. // Check how many <books> are in the library // Prints '3' t_book.all.size().println(); // Creates a new book element var b = new t_book; // Check again // Prints '4' t_book.all.size().println(); How can I add a child to an existing element? \u00b6 You can use the .appendChild(child) operation for this. // Create a new book var b = new t_book; // Get the library element var lib = t_library.all.first(); // Add the book to the library lib.appendChild(b); How can I set the root element of an XML document? \u00b6 You can use the .root property for this. XMLDoc.root = new t_library; root element is required When writing scripts that create new XML documents, e.g. ETL, the root element must be set on the output model. This can be done ina pre block (e.g. if the root is not craeted by a transformation rule) or in a rule/operation/other. For the Library example above (where lib is the model name): pre { var root = new t_library; lib.root = root; } If a root element is not assigned, then the output file will be empty. Using XML attributes as references \u00b6 The XML model type allows XML attributes to be used as references by using the attribute value as a \"key\" of another element. For example, we could extend the library example to include an author and editor reference on each book, and move authors to the root: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" authors= \"DS,FB,MP,EM\" editor= \"EG\" > <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" authors= \"RG\" > <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" > <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> <author id= \"DS\" > Dave Steinberg </author> <author id= \"FB\" > Frank Budinsky </author> <author id= \"MP\" > Marcelo Paternostro </author> <author id= \"EM\" > Ed Merks </author> <author id= \"RG\" > Richard Gronback </author> <editor id= \"EG\" > Erich Gamma </editor> </library> Note that the attributes used for references must be a comma-separated list of \"keys\". For enabling the references, we need to add the desired bindings to the model. The bind method has the following signature: bind(String sourceTag, String sourceAttribute, String targetTag, String targetAttribute, boolean many) . Thus, for the library example, in EOL this can be done like this: model.bind(\"book\", \"authors\", \"author\", \"id\", true); model.bind(\"book\", \"editor\", \"editor\", \"name\", false); where model is the name of the model (as specified in the run configuration). These statements should be at the top of the EOL file so the bindings are added before any other code executes. For rule-based languages, this could be done in a pre block. If invoking from java ) the bind method can be called on the model variable. After the bindings are in place, we can use them: var lib = t_library.all.first(); // Prints 4 lib.c_book.first().authors.size().println(); // Prints Frank Budinsky lib.c_book.first().authors.second().text.println(); Adding an XML document to your launch configuration \u00b6 To add an XML document to your Epsilon launch configuration, you need to select \"Plain XML document\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load an XML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full uri for your document (e.g. http://api.twitter.com/1/statuses/followers/epsilonews.xml or file:/c:/myxml.xml ). Loading an XML document in your ANT buildfile \u00b6 The following ANT build file demonstrates how you can use ANT to load/store and process XML documents with Epsilon. <project default= \"main\" > <target name= \"main\" > <epsilon.xml.loadModel name= \"XMLDoc\" file= \"library.xml\" read= \"true\" store= \"false\" /> </epsilon.xml.loadModel> <epsilon.eol src= \"my.eol\" > <model ref= \"XMLDoc\" /> </epsilon.eol> </target> </project> Loading an XML document through Java code \u00b6 The following excerpt demonstrates using XML models using Epsilon's Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); PlainXmlModel model = new PlainXmlModel (); model . setName ( \"M\" ); model . setFile ( new File ( \"...\" )); model . load (); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute (); Additional resources \u00b6 http://java.sun.com/javase/6/docs/api/org/w3c/dom/Element.html : Complete list of the operations that are applicable to XML elements","title":"Scripting XML documents using Epsilon"},{"location":"doc/articles/plain-xml/#scripting-xml-documents-using-epsilon","text":"In this article we demonstrate how you can create, query and modify plain standalone XML documents (i.e. no XSD/DTD needed) in Epsilon programs using the PlainXML driver added in version 0.8.9. All the examples in this article demonstrate using EOL to script XML documents. However, it's worth stressing that XML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - XML or EMF-based -, or to text), compare and merge your XML documents.","title":"Scripting XML documents using Epsilon"},{"location":"doc/articles/plain-xml/#querying-an-xml-document","text":"We use the following library.xml as a base for demonstrating the EOL syntax for querying XML documents. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" > <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" > <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" > <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library>","title":"Querying an XML document"},{"location":"doc/articles/plain-xml/#queryingmodifying-xml-documents-in-eol","text":"The PlainXML driver uses predefined naming conventions to allow developers to programmatically access and modify XML documents in a concise way. This section outlines the supported conventions in the form of questions and answers followed by relevant examples.","title":"Querying/modifying XML documents in EOL"},{"location":"doc/articles/plain-xml/#how-can-i-access-elements-by-tag-name","text":"The t_ prefix in front of the name of the tag is used to represent a type, instances of which are all the elements with that tag. For instance, t_book.all can be used to get all elements tagged as <book> in the document, t_author.all to retrieve all <author> elements etc. Also, if b is an element with a <book> tag, then b.isTypeOf(t_book) shall return true. If the tag name contains hyphens, underscores, and/or periods, you must escape the complete type name inside back ticks: `t_first-name // Get all <book> elements var books = t_book.all; // Get a random book var b = books.random(); // Check if b is a book // Prints 'true' b.isTypeOf(t_book).println(); // Check if b is a library // Prints 'false' b.isTypeOf(t_library).println();","title":"How can I access elements by tag name?"},{"location":"doc/articles/plain-xml/#how-can-i-get-the-tag-name-of-an-element","text":"You can use the .name property for this purpose. For instance, if b is an element tagged as <book> , b.name shall return book . The name property is read-only. // Get a random <book> element var b = t_book.all.random(); // Print its tag // Prints 'book' b.name.println(); tagName property is deprecated Previously the tagName property was suggested for getting the tag name of an element. Due to the introduction of modules in Java 9 accessing this property is deprecated and future use can result in run time exceptions.","title":"How can I get the tag name of an element?"},{"location":"doc/articles/plain-xml/#how-can-i-getset-the-attributes-of-an-element","text":"You can use the attribute name as a property of the element object, prefixed by a_ . For example, if b is the first book of library.xml , b.a_title will return EMF Eclipse Modeling Framework . Attribute properties are read/write. In this example, b.a_pages will return 744 as a string. For 744 to be returned as an integer instead, the i_ prefix should be used instead (i.e. b.i_pages . The driver also supports the following preffixes: b_ for boolean, s_ for string (alias of a_ ) and r_ for real values. // Print all the titles of the books in the library for (b in t_book.all) { b.a_title.println(); } // Print the total number of pages of all books var total = 0; for (b in t_book.all) { total = total + b.i_pages; } total.print(); // ... the same using collect() and sum() // instead of a for loop t_book.all.collect(b|b.i_pages).sum();","title":"How can I get/set the attributes of an element?"},{"location":"doc/articles/plain-xml/#how-can-i-getset-the-text-of-an-element","text":"You can use the .text read-write property for this. for (author in t_author.all) { author.text.println(); }","title":"How can I get/set the text of an element?"},{"location":"doc/articles/plain-xml/#how-do-i-get-the-parent-of-an-element","text":"You can use the .parentNode read-only property for this. // Get a random book var b = t_book.all.random(); // Print the tag of its parent node // Prints 'library' b.parentNode.name.println();","title":"How do I get the parent of an element?"},{"location":"doc/articles/plain-xml/#how-do-i-get-the-children-of-an-element","text":"You can use the .children read-only property for this. // Get the <library> element var lib = t_library.all.first(); // Iterate through its children for (b in lib.children) { // Print the title of each child b.a_title.println(); }","title":"How do I get the children of an element?"},{"location":"doc/articles/plain-xml/#how-do-i-get-child-elements-with-a-specific-tag-name","text":"Using what you've learned so far, you can do this using a combination of the .children property and the select/selectOne() operations. However, the driver also supports e_ and c_ -prefixed shorthand properties for accessing one or a collection of elements with the specified name respectively. e_ and c_ properties are read-only. // Get a random book var b = t_book.all.random(); // Get its <author> children using the // .children property var authors = b.children.select(a|a.name = \"author\"); // Do the same using the shorthand authors = b.c_author; // Get its <published> child and print // its text using the // .children property b.children.selectOne(p|p.name = \"published\").text.println(); // Do the same using the shorthand // (e_ instead of c_ this time as // we only want one element, // not a collection of them) b.e_published.text.println();","title":"How do I get child elements with a specific tag name?"},{"location":"doc/articles/plain-xml/#how-do-i-create-an-element","text":"You can use the new operator for this. // Check how many <books> are in the library // Prints '3' t_book.all.size().println(); // Creates a new book element var b = new t_book; // Check again // Prints '4' t_book.all.size().println();","title":"How do I create an element?"},{"location":"doc/articles/plain-xml/#how-can-i-add-a-child-to-an-existing-element","text":"You can use the .appendChild(child) operation for this. // Create a new book var b = new t_book; // Get the library element var lib = t_library.all.first(); // Add the book to the library lib.appendChild(b);","title":"How can I add a child to an existing element?"},{"location":"doc/articles/plain-xml/#how-can-i-set-the-root-element-of-an-xml-document","text":"You can use the .root property for this. XMLDoc.root = new t_library; root element is required When writing scripts that create new XML documents, e.g. ETL, the root element must be set on the output model. This can be done ina pre block (e.g. if the root is not craeted by a transformation rule) or in a rule/operation/other. For the Library example above (where lib is the model name): pre { var root = new t_library; lib.root = root; } If a root element is not assigned, then the output file will be empty.","title":"How can I set the root element of an XML document?"},{"location":"doc/articles/plain-xml/#using-xml-attributes-as-references","text":"The XML model type allows XML attributes to be used as references by using the attribute value as a \"key\" of another element. For example, we could extend the library example to include an author and editor reference on each book, and move authors to the root: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <library> <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" authors= \"DS,FB,MP,EM\" editor= \"EG\" > <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" authors= \"RG\" > <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" > <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> <author id= \"DS\" > Dave Steinberg </author> <author id= \"FB\" > Frank Budinsky </author> <author id= \"MP\" > Marcelo Paternostro </author> <author id= \"EM\" > Ed Merks </author> <author id= \"RG\" > Richard Gronback </author> <editor id= \"EG\" > Erich Gamma </editor> </library> Note that the attributes used for references must be a comma-separated list of \"keys\". For enabling the references, we need to add the desired bindings to the model. The bind method has the following signature: bind(String sourceTag, String sourceAttribute, String targetTag, String targetAttribute, boolean many) . Thus, for the library example, in EOL this can be done like this: model.bind(\"book\", \"authors\", \"author\", \"id\", true); model.bind(\"book\", \"editor\", \"editor\", \"name\", false); where model is the name of the model (as specified in the run configuration). These statements should be at the top of the EOL file so the bindings are added before any other code executes. For rule-based languages, this could be done in a pre block. If invoking from java ) the bind method can be called on the model variable. After the bindings are in place, we can use them: var lib = t_library.all.first(); // Prints 4 lib.c_book.first().authors.size().println(); // Prints Frank Budinsky lib.c_book.first().authors.second().text.println();","title":"Using XML attributes as references"},{"location":"doc/articles/plain-xml/#adding-an-xml-document-to-your-launch-configuration","text":"To add an XML document to your Epsilon launch configuration, you need to select \"Plain XML document\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load an XML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full uri for your document (e.g. http://api.twitter.com/1/statuses/followers/epsilonews.xml or file:/c:/myxml.xml ).","title":"Adding an XML document to your launch configuration"},{"location":"doc/articles/plain-xml/#loading-an-xml-document-in-your-ant-buildfile","text":"The following ANT build file demonstrates how you can use ANT to load/store and process XML documents with Epsilon. <project default= \"main\" > <target name= \"main\" > <epsilon.xml.loadModel name= \"XMLDoc\" file= \"library.xml\" read= \"true\" store= \"false\" /> </epsilon.xml.loadModel> <epsilon.eol src= \"my.eol\" > <model ref= \"XMLDoc\" /> </epsilon.eol> </target> </project>","title":"Loading an XML document in your ANT buildfile"},{"location":"doc/articles/plain-xml/#loading-an-xml-document-through-java-code","text":"The following excerpt demonstrates using XML models using Epsilon's Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); PlainXmlModel model = new PlainXmlModel (); model . setName ( \"M\" ); model . setFile ( new File ( \"...\" )); model . load (); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute ();","title":"Loading an XML document through Java code"},{"location":"doc/articles/plain-xml/#additional-resources","text":"http://java.sun.com/javase/6/docs/api/org/w3c/dom/Element.html : Complete list of the operations that are applicable to XML elements","title":"Additional resources"},{"location":"doc/articles/playground/","text":"Epsilon Playground \u00b6 The Epsilon Playground is a web application for fiddling with metamodelling, modelling and automated model management using Emfatic , Flexmi and Epsilon's languages. Its back-end is implemented using Google Cloud Platform Functions and the front-end builds heavily on the Metro 4 framework. Diagrams are rendered using PlantUML and Kroki . Emfatic Metamodels in the Playground \u00b6 For metamodelling, the Playground uses Ecore's Emfatic textual syntax, augmented with a couple of annotations to control the graphical layout of the metamodels. @diagram(direction=\"up/down/left/right\") : Can be attached to references ( val / ref ) to specify the direction of the respective edge in the diagram ( right by default for non-containment references, and down for containment references) @diagram(inheritance.direction=\"up/down/left/right\") : Can be attached to classes to specify the direction of its inheritance edges in the diagram ( up by default). For example, the plain Emfatic metamodel below is rendered as follows: package ptl; class Project { attr String name; val Task[*] tasks; val Person[*] people; } abstract class Task { attr String name; } class ManualTask extends Task { ref Person person; } class AutomatedTask extends Task { } class Person { attr String name; } while its annotated version produces the diagram below. package ptl; class Project { attr String name; val Task[*] tasks; val Person[*] people; } abstract class Task { attr String name; } class ManualTask extends Task { @diagram(direction=\"up\") ref Person person; } @diagram(inheritance.direction=\"down\") class AutomatedTask extends Task { } class Person { attr String name; } Save and share your work \u00b6 To share your work, click the Share button. This will create a short link that you can copy to your clipboard. Please note that the contents of the editors will be stored in the back-end of the Epsilon Playground so that they can be retrieved when you visit that link again later. Download your work \u00b6 To download a zipped archive of your work, click the Download button. Depending on your selection, the zipped archived will contain the model management program(s), the models and metamodels of the example, a readme.md file with instructions as well as: Gradle / Maven : a build.gradle or pom.xml file that includes the Epsilon dependencies and the ANT tasks you need to run the example from the command line Ant (Eclipse) : a build.xml file that in includes the ANT tasks you need to run the example from within Eclipse Java (Gradle) / Java (Maven) : a Java class that runs the model management program using Epsilon's API, and a build.gradle or pom.xml file that includes the Epsilon dependencies Custom examples \u00b6 You can launch the Playground with a custom set of examples by appending an examples parameter to the URL, which points to a JSON file that contains your own examples. For instance, this link below launches the Playground with its default set of examples. https://eclipse.org/epsilon/playground/?examples=https://raw.githubusercontent.com/eclipse/epsilon-website/master/mkdocs/docs/playground/examples/examples.json The structure of examples.json should be self-explanatory but if you have any questions, please let us know. Settings \u00b6 Through the Settings dialog, you can show/hide the different panels of the playground as well as line numbers in editors. If you hide the program panel, you can still run the program it contains using the Ctrl+S or Cmd+S keyboard shortcut. Docker container \u00b6 If the Playground is a critical dependency for you (e.g. to support a training course), you may want to run your own instance through a Docker container . Despite using automated testing with Cypress , as we are evolving the Playground, we may indadvertedly introduce regressions that break the Playground and make (parts of it) unusable for a period of time. Fair usage policy \u00b6 The cost of running Epsilon Playground is proportional to the number of requests made to its Google Cloud Platform back-end (i.e. execution of programs and rendering of diagrams). With fair usage we can comfortably afford this cost and keep the Playground operational, but in case of excessive use we may have to take it down with no notice. To keep costs down, server-side operations that take more than 60 seconds to complete are automatically terminated. For extensive use, large models, or complex programs, please use the development tools / Java libraries provided on the Epsilon website instead, or run your own instance of the Epsilon Playground in a Docker container . Reporting bugs and requesting help \u00b6 Please submit bug reports using GitHub Issues and ask for help in Epsilon's forum . You can submit feature requests too but please keep in mind that the Playground is not a replacement for Epsilon's Eclipse-based development tools . The Playground has been tested on recent versions of Firefox and Chrome. It's unlikely that we'll be able to invest too much effort in making it compatible with older/other browsers but any pull requests you may be able to contribute are always welcome.","title":"Epsilon Playground"},{"location":"doc/articles/playground/#epsilon-playground","text":"The Epsilon Playground is a web application for fiddling with metamodelling, modelling and automated model management using Emfatic , Flexmi and Epsilon's languages. Its back-end is implemented using Google Cloud Platform Functions and the front-end builds heavily on the Metro 4 framework. Diagrams are rendered using PlantUML and Kroki .","title":"Epsilon Playground"},{"location":"doc/articles/playground/#emfatic-metamodels-in-the-playground","text":"For metamodelling, the Playground uses Ecore's Emfatic textual syntax, augmented with a couple of annotations to control the graphical layout of the metamodels. @diagram(direction=\"up/down/left/right\") : Can be attached to references ( val / ref ) to specify the direction of the respective edge in the diagram ( right by default for non-containment references, and down for containment references) @diagram(inheritance.direction=\"up/down/left/right\") : Can be attached to classes to specify the direction of its inheritance edges in the diagram ( up by default). For example, the plain Emfatic metamodel below is rendered as follows: package ptl; class Project { attr String name; val Task[*] tasks; val Person[*] people; } abstract class Task { attr String name; } class ManualTask extends Task { ref Person person; } class AutomatedTask extends Task { } class Person { attr String name; } while its annotated version produces the diagram below. package ptl; class Project { attr String name; val Task[*] tasks; val Person[*] people; } abstract class Task { attr String name; } class ManualTask extends Task { @diagram(direction=\"up\") ref Person person; } @diagram(inheritance.direction=\"down\") class AutomatedTask extends Task { } class Person { attr String name; }","title":"Emfatic Metamodels in the Playground"},{"location":"doc/articles/playground/#save-and-share-your-work","text":"To share your work, click the Share button. This will create a short link that you can copy to your clipboard. Please note that the contents of the editors will be stored in the back-end of the Epsilon Playground so that they can be retrieved when you visit that link again later.","title":"Save and share your work"},{"location":"doc/articles/playground/#download-your-work","text":"To download a zipped archive of your work, click the Download button. Depending on your selection, the zipped archived will contain the model management program(s), the models and metamodels of the example, a readme.md file with instructions as well as: Gradle / Maven : a build.gradle or pom.xml file that includes the Epsilon dependencies and the ANT tasks you need to run the example from the command line Ant (Eclipse) : a build.xml file that in includes the ANT tasks you need to run the example from within Eclipse Java (Gradle) / Java (Maven) : a Java class that runs the model management program using Epsilon's API, and a build.gradle or pom.xml file that includes the Epsilon dependencies","title":"Download your work"},{"location":"doc/articles/playground/#custom-examples","text":"You can launch the Playground with a custom set of examples by appending an examples parameter to the URL, which points to a JSON file that contains your own examples. For instance, this link below launches the Playground with its default set of examples. https://eclipse.org/epsilon/playground/?examples=https://raw.githubusercontent.com/eclipse/epsilon-website/master/mkdocs/docs/playground/examples/examples.json The structure of examples.json should be self-explanatory but if you have any questions, please let us know.","title":"Custom examples"},{"location":"doc/articles/playground/#settings","text":"Through the Settings dialog, you can show/hide the different panels of the playground as well as line numbers in editors. If you hide the program panel, you can still run the program it contains using the Ctrl+S or Cmd+S keyboard shortcut.","title":"Settings"},{"location":"doc/articles/playground/#docker-container","text":"If the Playground is a critical dependency for you (e.g. to support a training course), you may want to run your own instance through a Docker container . Despite using automated testing with Cypress , as we are evolving the Playground, we may indadvertedly introduce regressions that break the Playground and make (parts of it) unusable for a period of time.","title":"Docker container"},{"location":"doc/articles/playground/#fair-usage-policy","text":"The cost of running Epsilon Playground is proportional to the number of requests made to its Google Cloud Platform back-end (i.e. execution of programs and rendering of diagrams). With fair usage we can comfortably afford this cost and keep the Playground operational, but in case of excessive use we may have to take it down with no notice. To keep costs down, server-side operations that take more than 60 seconds to complete are automatically terminated. For extensive use, large models, or complex programs, please use the development tools / Java libraries provided on the Epsilon website instead, or run your own instance of the Epsilon Playground in a Docker container .","title":"Fair usage policy"},{"location":"doc/articles/playground/#reporting-bugs-and-requesting-help","text":"Please submit bug reports using GitHub Issues and ask for help in Epsilon's forum . You can submit feature requests too but please keep in mind that the Playground is not a replacement for Epsilon's Eclipse-based development tools . The Playground has been tested on recent versions of Firefox and Chrome. It's unlikely that we'll be able to invest too much effort in making it compatible with older/other browsers but any pull requests you may be able to contribute are always welcome.","title":"Reporting bugs and requesting help"},{"location":"doc/articles/preparing-the-macosx-distribution/","text":"Preparing the MacOSX distribution \u00b6 Build the distribution locally Compress it using the following terminal command zip -r -X epsilon-1.x-unsigned.zip Eclipse.app/ Upload the zip file to build.eclipse.org Update and run the https://ci.eclipse.org/epsilon/job/macosx-app-signing Download the signed zip file locally Extract the signed Eclipse.app from the zip file using the following terminal command unzip epsilon-1.5-signed.zip Use Disk Utility to create a .dmg image that contains the extracted Eclipse.app","title":"Preparing the MacOSX distribution"},{"location":"doc/articles/preparing-the-macosx-distribution/#preparing-the-macosx-distribution","text":"Build the distribution locally Compress it using the following terminal command zip -r -X epsilon-1.x-unsigned.zip Eclipse.app/ Upload the zip file to build.eclipse.org Update and run the https://ci.eclipse.org/epsilon/job/macosx-app-signing Download the signed zip file locally Extract the signed Eclipse.app from the zip file using the following terminal command unzip epsilon-1.5-signed.zip Use Disk Utility to create a .dmg image that contains the extracted Eclipse.app","title":"Preparing the MacOSX distribution"},{"location":"doc/articles/profiled-uml-models/","text":"Managing Profiled UML Models in Epsilon \u00b6 This article shows how to create and query profiled Eclipse UML models using Epsilon's core language ( EOL ). For our example we will use a profile called ActivityFunctions which contains a single Function stereotype that applies to UML activities, and has a single body String property. Creating a Profiled UML Model \u00b6 In the run configuration of our EOL program we need to add two models of type UML UML : The profiled model we wish to create. This model should not be read on load but should be stored on disposal (i.e. when the EOL program finishes). ActivityFunctionsProfile : The model containing the ActivityFunctions profile that we wish to apply to the UML model. This model should be read on load but not stored on disposal (since we don't really want to make any changes to it). The EOL program that creates and populates our UML model looks as follows. // Get hold of the ActivityFunctions profile // that contains the Function stereotype var profile = ActivityFunctionsProfile!Profile.all.first(); // Get hold of the Function stereotype var functionStereotype = profile.getPackagedElement(\"Function\"); // Create a new plain UML Model element var newModel : new UML!Model(name=\"NewModel\"); // Apply the ActivityFunctions profile to it newModel.applyProfile(profile); // Create a new plain UML Activity element var newActivity : new UML!Activity(name=\"NewActivity\"); // ... add it as a child of the Model created above newModel.packagedElement.add(newActivity); // ... and apply the Function stereotype to it var newFunction = newActivity.applyStereotype(functionStereotype); // Set the value of the body property of the Function stereotype newFunction.body = \"return 42;\"; At this point, if we try to query Function.all , the call will fail as the UML model is unaware of the Function type. To remedy this, we need to get hold of the EPackage representation of the ActivityProfile and add it to the package registry of the UML model as follows. // Get hold of the EPackage representation of the ActivityProfile var profileEPackage = newModel.profileApplications.first().appliedDefinition; // ... and add it to the package registry of our UML model UML.resource.resourceSet.packageRegistry. put(profileEPackage.nsURI, profileEPackage); Once we have done this, we can query use all the stereotypes in the profile (i.e. Function in this case) as regular types, as shown below. // Gets hold of the Function stereotype // application we created above newFunction = UML!Function.all.first(); newFunction.body.println(); // The function and its underlying activity are still // two separate elements in the model, linked via // the function's base_Activity reference newFunction.base_Activity.name.println(); Querying a Profiled UML Model \u00b6 Querying a profiled UML model (such as the one we created using the program above) is much simpler as the EPackage representations of its applied profiles are automatically put in the package registry of the model during loading. As such we, can query the model as follows. var func = Function.all.first(); func.body.println(); var activity = func.base_Activity; activity.name.println(); Plugin-Based Profiles \u00b6 In our example, the profile we wish to apply to our model is located in a file that resides in the same workspace as our UML model. If we need to use a profile contributed by a plugin instead (e.g. the built-in UML Ecore profile), this can be achieved as follows. var umlTool : new Native(\"org.eclipse.epsilon.emc.uml.dt.UMLTool\"); var ecoreProfile = umlTool.getProfile (\"http://www.eclipse.org/uml2/schemas/Ecore/5\"); // or // var ecoreProfile = umlTool.getProfileFromPathmapUri // (\"pathmap://UML_PROFILES/Ecore.profile.uml\").println(); Profiled UML Models in Rule-Based Epsilon Languages \u00b6 In rule-based languages such as ETL and EVL, any required profiles must be applied in a pre block, before any of the rules (e.g. transformation rules, validation constraints) that refer to types in the profile are executed. Resources \u00b6 The complete source code for this example is available in Epsilon's Git repository .","title":"Managing Profiled UML Models in Epsilon"},{"location":"doc/articles/profiled-uml-models/#managing-profiled-uml-models-in-epsilon","text":"This article shows how to create and query profiled Eclipse UML models using Epsilon's core language ( EOL ). For our example we will use a profile called ActivityFunctions which contains a single Function stereotype that applies to UML activities, and has a single body String property.","title":"Managing Profiled UML Models in Epsilon"},{"location":"doc/articles/profiled-uml-models/#creating-a-profiled-uml-model","text":"In the run configuration of our EOL program we need to add two models of type UML UML : The profiled model we wish to create. This model should not be read on load but should be stored on disposal (i.e. when the EOL program finishes). ActivityFunctionsProfile : The model containing the ActivityFunctions profile that we wish to apply to the UML model. This model should be read on load but not stored on disposal (since we don't really want to make any changes to it). The EOL program that creates and populates our UML model looks as follows. // Get hold of the ActivityFunctions profile // that contains the Function stereotype var profile = ActivityFunctionsProfile!Profile.all.first(); // Get hold of the Function stereotype var functionStereotype = profile.getPackagedElement(\"Function\"); // Create a new plain UML Model element var newModel : new UML!Model(name=\"NewModel\"); // Apply the ActivityFunctions profile to it newModel.applyProfile(profile); // Create a new plain UML Activity element var newActivity : new UML!Activity(name=\"NewActivity\"); // ... add it as a child of the Model created above newModel.packagedElement.add(newActivity); // ... and apply the Function stereotype to it var newFunction = newActivity.applyStereotype(functionStereotype); // Set the value of the body property of the Function stereotype newFunction.body = \"return 42;\"; At this point, if we try to query Function.all , the call will fail as the UML model is unaware of the Function type. To remedy this, we need to get hold of the EPackage representation of the ActivityProfile and add it to the package registry of the UML model as follows. // Get hold of the EPackage representation of the ActivityProfile var profileEPackage = newModel.profileApplications.first().appliedDefinition; // ... and add it to the package registry of our UML model UML.resource.resourceSet.packageRegistry. put(profileEPackage.nsURI, profileEPackage); Once we have done this, we can query use all the stereotypes in the profile (i.e. Function in this case) as regular types, as shown below. // Gets hold of the Function stereotype // application we created above newFunction = UML!Function.all.first(); newFunction.body.println(); // The function and its underlying activity are still // two separate elements in the model, linked via // the function's base_Activity reference newFunction.base_Activity.name.println();","title":"Creating a Profiled UML Model"},{"location":"doc/articles/profiled-uml-models/#querying-a-profiled-uml-model","text":"Querying a profiled UML model (such as the one we created using the program above) is much simpler as the EPackage representations of its applied profiles are automatically put in the package registry of the model during loading. As such we, can query the model as follows. var func = Function.all.first(); func.body.println(); var activity = func.base_Activity; activity.name.println();","title":"Querying a Profiled UML Model"},{"location":"doc/articles/profiled-uml-models/#plugin-based-profiles","text":"In our example, the profile we wish to apply to our model is located in a file that resides in the same workspace as our UML model. If we need to use a profile contributed by a plugin instead (e.g. the built-in UML Ecore profile), this can be achieved as follows. var umlTool : new Native(\"org.eclipse.epsilon.emc.uml.dt.UMLTool\"); var ecoreProfile = umlTool.getProfile (\"http://www.eclipse.org/uml2/schemas/Ecore/5\"); // or // var ecoreProfile = umlTool.getProfileFromPathmapUri // (\"pathmap://UML_PROFILES/Ecore.profile.uml\").println();","title":"Plugin-Based Profiles"},{"location":"doc/articles/profiled-uml-models/#profiled-uml-models-in-rule-based-epsilon-languages","text":"In rule-based languages such as ETL and EVL, any required profiles must be applied in a pre block, before any of the rules (e.g. transformation rules, validation constraints) that refer to types in the profile are executed.","title":"Profiled UML Models in Rule-Based Epsilon Languages"},{"location":"doc/articles/profiled-uml-models/#resources","text":"The complete source code for this example is available in Epsilon's Git repository .","title":"Resources"},{"location":"doc/articles/profiling/","text":"Profiling Epsilon Programs \u00b6 The purpose of this article is to provide an overview and a usage example of the Epsilon profiling tools. Profiling is particularly useful in order to obtain metrics for theperformance of Epsilon code, and to identify blocks of code that are either executed more often than anticipated or take too much time to execute. Adding profiling statements to your Epsilon code \u00b6 Code-level support for profiling in Epsilon has been implemented in the form of a tool called ProfilerTool ( org.eclipse.epsilon.eol.tools.ProfilerTool ). To add support for profiling in your Epsilon program you must instantiate the tool and call its start() and stop() methods. The following EOL example contains an operation fib() that calculates the Fibonacci number of a given integer, and a call to the fib() operation with an initial value of 15. 15.fib(); operation Integer fib() : Integer { var fib : Integer; if (self = 1 or self = 0){ fib = 1; } else { fib = (self-1).fib()+(self-2).fib(); } return fib; } Our aim in this example is to enrich the program with profiling statements so that we canget to know how many times the fib() operation is executed and how much time each calltakes to execute. To achieve this we modify our program as follows: var profiler : new Native(\"org.eclipse.epsilon.eol.tools.ProfilerTool\"); profiler.start(\"Program\"); 15.fib(); profiler.stop(); operation Integer fib() : Integer { profiler.start(\"fib\",self); var fib : Integer; if (self = 1 or self = 0){ fib = 1; } else { fib = (self-1).fib()+(self-2).fib(); } profiler.stop(); return fib; } We add an instantiation statement that creates a new instance of the ProfilerTool in Line 1. Then we define two profiling targets. The first one is called \"Program\" and measures the performance of line 3 and the second one is called \"fib\" and measures the performance of the body of the fib() operation. Note that the first call to the start() method has only one argument (the mandatory targetName : String argument) while the second one has an additional argument. This extra (optional) argument ( data : Any ) enables users to capture context-specific information where multiple calls to the specific start() method are anticipated. In our example, we store the value of the integer on which the operation is executed ( self ). Here we should note that since profiling has been implemented in the context of EOL, the same technique can be used to profile code in all task-specific languages of Epsilon (ETL, ECL, EML etc). Inspecting Profiling Information \u00b6 Once we've executed the program, we can inspect the profiling information gathered, by activating the \"Profiling\" Eclipse view. Upon activation the view will look like this: To populate the view with the information gathered during profiling, we click the \"Refresh view\" button in the toolbar of the view. This makes the view look like this: From this summary view we see that the Program target has been executed 1 time and has taken 1292 ms to execute. Similarly, the fib target has been executed 1973 times with a total time of 1292 ms and an average of 0.6548. By clicking on the respective column headers of the summary table we can sort the targets by name, # times executed, total execution time etc. To obtain a more detailed view on the profiling data, we can switch to the \"Details\" tab located at the bottom of the view. Unlike the table-oriented \"Summary\" view, the \"Details\" view contains a tree-table combination that visualizes each target instance and displays its execution time, the context specific data, as well as the location of the profiling statement in the source code. By default, the children of each target are ordered by execution order. However, by checking the \"Sort children by execution time\" button on the view toolbar we can sort the children by execution time as well. Also, double-clicking a particular target should bring up the respective editor and highlight the line in which the call to the start() method of the ProfilerTool exists. Execution Time Measuring Modes \u00b6 The Epsilon profiling tools support two different modes for measuring the time each target has consumed to execute. In the individual mode, each target is assigned only the time it has taken to execute itself. In the aggregated mode, the execution time of a target is that of the target itself plus the execution times of its children (recursively). To change between the two modes, we can check/uncheck the \"Show aggregated execution times\" button on the toolbar. Enabling Profiling in Epsilon Run Configurations \u00b6 You can turn profiling on through the \"Profiling\" tab of the run configuration of your Epsilon program. Enabling Profiling in Epsilon ANT tasks \u00b6 In addition to profiling specific code blocks, we can use the Epsilon profiling tools to profile entire model management operations invoked as ANT tasks by setting the optional profile attribute to true. In the following example, we have created an ANT build-file that invokes the Fib.eol EOL program we demonstrated above. <project default= \"main\" > <target name= \"main\" > <epsilon.eol src= \"Fib.eol\" profile= \"true\" /> </target> </project> Executing the ANT build-file and refreshing the following Profiling view makes it look like this: We can see that a new target named after the filename of the executed EOL program has been created along with the targets created using the in-line calls to the start() method of the ProfilerTool . Notes on Using the Profiling Tools \u00b6 The underlying profiler is loosely coupled with Epsilon. This means that it records profiling information when asked to, and which is never cleared automatically. To clear the profile, you must click the \"Reset profiler\" button in the Profiling view. To enable real-time preview of the profiling data as they are being recorded, we have added an \"Auto Refresh\" button to the view. However, this should be used with caution as real-time rendering of the results may lead to (significantly) increased execution times due to the time consumed to actually query the profiler and display the data in the widgets. With regard to the impact of the profiling code on the produced metrics we have tried to minimize it by using an elaborated stopwatch mechanism. Initial tests have shown that each start() -- stop() pair introduces a 0-10ms overhead of the measured time; however this is only indicative and may vary according to the execution platform.","title":"Profiling Epsilon Programs"},{"location":"doc/articles/profiling/#profiling-epsilon-programs","text":"The purpose of this article is to provide an overview and a usage example of the Epsilon profiling tools. Profiling is particularly useful in order to obtain metrics for theperformance of Epsilon code, and to identify blocks of code that are either executed more often than anticipated or take too much time to execute.","title":"Profiling Epsilon Programs"},{"location":"doc/articles/profiling/#adding-profiling-statements-to-your-epsilon-code","text":"Code-level support for profiling in Epsilon has been implemented in the form of a tool called ProfilerTool ( org.eclipse.epsilon.eol.tools.ProfilerTool ). To add support for profiling in your Epsilon program you must instantiate the tool and call its start() and stop() methods. The following EOL example contains an operation fib() that calculates the Fibonacci number of a given integer, and a call to the fib() operation with an initial value of 15. 15.fib(); operation Integer fib() : Integer { var fib : Integer; if (self = 1 or self = 0){ fib = 1; } else { fib = (self-1).fib()+(self-2).fib(); } return fib; } Our aim in this example is to enrich the program with profiling statements so that we canget to know how many times the fib() operation is executed and how much time each calltakes to execute. To achieve this we modify our program as follows: var profiler : new Native(\"org.eclipse.epsilon.eol.tools.ProfilerTool\"); profiler.start(\"Program\"); 15.fib(); profiler.stop(); operation Integer fib() : Integer { profiler.start(\"fib\",self); var fib : Integer; if (self = 1 or self = 0){ fib = 1; } else { fib = (self-1).fib()+(self-2).fib(); } profiler.stop(); return fib; } We add an instantiation statement that creates a new instance of the ProfilerTool in Line 1. Then we define two profiling targets. The first one is called \"Program\" and measures the performance of line 3 and the second one is called \"fib\" and measures the performance of the body of the fib() operation. Note that the first call to the start() method has only one argument (the mandatory targetName : String argument) while the second one has an additional argument. This extra (optional) argument ( data : Any ) enables users to capture context-specific information where multiple calls to the specific start() method are anticipated. In our example, we store the value of the integer on which the operation is executed ( self ). Here we should note that since profiling has been implemented in the context of EOL, the same technique can be used to profile code in all task-specific languages of Epsilon (ETL, ECL, EML etc).","title":"Adding profiling statements to your Epsilon code"},{"location":"doc/articles/profiling/#inspecting-profiling-information","text":"Once we've executed the program, we can inspect the profiling information gathered, by activating the \"Profiling\" Eclipse view. Upon activation the view will look like this: To populate the view with the information gathered during profiling, we click the \"Refresh view\" button in the toolbar of the view. This makes the view look like this: From this summary view we see that the Program target has been executed 1 time and has taken 1292 ms to execute. Similarly, the fib target has been executed 1973 times with a total time of 1292 ms and an average of 0.6548. By clicking on the respective column headers of the summary table we can sort the targets by name, # times executed, total execution time etc. To obtain a more detailed view on the profiling data, we can switch to the \"Details\" tab located at the bottom of the view. Unlike the table-oriented \"Summary\" view, the \"Details\" view contains a tree-table combination that visualizes each target instance and displays its execution time, the context specific data, as well as the location of the profiling statement in the source code. By default, the children of each target are ordered by execution order. However, by checking the \"Sort children by execution time\" button on the view toolbar we can sort the children by execution time as well. Also, double-clicking a particular target should bring up the respective editor and highlight the line in which the call to the start() method of the ProfilerTool exists.","title":"Inspecting Profiling Information"},{"location":"doc/articles/profiling/#execution-time-measuring-modes","text":"The Epsilon profiling tools support two different modes for measuring the time each target has consumed to execute. In the individual mode, each target is assigned only the time it has taken to execute itself. In the aggregated mode, the execution time of a target is that of the target itself plus the execution times of its children (recursively). To change between the two modes, we can check/uncheck the \"Show aggregated execution times\" button on the toolbar.","title":"Execution Time Measuring Modes"},{"location":"doc/articles/profiling/#enabling-profiling-in-epsilon-run-configurations","text":"You can turn profiling on through the \"Profiling\" tab of the run configuration of your Epsilon program.","title":"Enabling Profiling in Epsilon Run Configurations"},{"location":"doc/articles/profiling/#enabling-profiling-in-epsilon-ant-tasks","text":"In addition to profiling specific code blocks, we can use the Epsilon profiling tools to profile entire model management operations invoked as ANT tasks by setting the optional profile attribute to true. In the following example, we have created an ANT build-file that invokes the Fib.eol EOL program we demonstrated above. <project default= \"main\" > <target name= \"main\" > <epsilon.eol src= \"Fib.eol\" profile= \"true\" /> </target> </project> Executing the ANT build-file and refreshing the following Profiling view makes it look like this: We can see that a new target named after the filename of the executed EOL program has been created along with the targets created using the in-line calls to the start() method of the ProfilerTool .","title":"Enabling Profiling in Epsilon ANT tasks"},{"location":"doc/articles/profiling/#notes-on-using-the-profiling-tools","text":"The underlying profiler is loosely coupled with Epsilon. This means that it records profiling information when asked to, and which is never cleared automatically. To clear the profile, you must click the \"Reset profiler\" button in the Profiling view. To enable real-time preview of the profiling data as they are being recorded, we have added an \"Auto Refresh\" button to the view. However, this should be used with caution as real-time rendering of the results may lead to (significantly) increased execution times due to the time consumed to actually query the profiler and display the data in the widgets. With regard to the impact of the profiling code on the produced metrics we have tried to minimize it by using an elaborated stopwatch mechanism. Initial tests have shown that each start() -- stop() pair introduces a 0-10ms overhead of the measured time; however this is only indicative and may vary according to the execution platform.","title":"Notes on Using the Profiling Tools"},{"location":"doc/articles/reflective-emf-tutorial/","text":"Reflective EMF Tutorial \u00b6 This tutorial demonstrates how to create an EMF Ecore metamodel and a sample model that conforms to it reflectively (i.e. without generating any code). Prerequisites \u00b6 To go through this tutorial you need to first install the Eclipse Modeling Distribution, Epsilon and Emfatic. Installation instructions are available here . Create a new project \u00b6 Go to File \u2192 New \u2192 Other... and select General \u2192 Project . Type library as the project name: Create library.emf \u00b6 Go to File \u2192 New \u2192 Other... and select File . Type library.emf as the file name: This is where we'll specify our Ecore metamodel using the Emfatic textual syntax Add content to library.emf \u00b6 Now library.emf should be open and you can copy-paste the following text into it (our sample metamodel) and save. @namespace(uri=\"library\", prefix=\"\") package library; class Library { val Writer[*] writers; val Book[*] books; } class Writer { attr String name; ref Book[*] books; } class Book { attr String title; attr int pages = 100; attr BookCategory category; } enum BookCategory { Mystery; ScienceFiction; Biography; } Now your library.emf editor should look like this: Generate library.ecore from library.emf \u00b6 The next step is to generate a proper XMI-based Ecore metamodel from the Emfatic textual representation. To do this, you can right-click library.emf and select Generate Ecore model as shown below: Once you've done this you should have a new file called library.ecore sitting next to your library.emf . Congratulations! You're half-way there! Tip If at some point you change library.emf , you need to repeat this step in order to update library.ecore . Register library.ecore \u00b6 The next step is to let EMF know of the existence of your newly created library.ecore metamodel. To do this, right-click library.ecore and select Register EPackages as shown below: Create a model that conforms to library.ecore \u00b6 Now we're ready to create models that conform to our new Ecore metamodel! To create a model, go to File \u2192 New \u2192 Other... and select EMF Model as shown below: Click Next and set the name of the model to mylibrary.model : Then hit the Browse... button next to the Metamodel URI field and select library in the list that pops up: Finally, select Library from the Root instance type combo box and hit Finish : Now mylibrary.model should be open in a tree-based editor: Add content to mylibrary.model \u00b6 To create a new Book under the library, you can right-click it and select New Child \u2192 Books \u2192 Book To set the title of the new book, you can right-click it and select Show Properties View Then, in the Title field of the Properties view, you can type the name of the book: Congratulations! You've just created your first EMF model!","title":"Reflective EMF Tutorial"},{"location":"doc/articles/reflective-emf-tutorial/#reflective-emf-tutorial","text":"This tutorial demonstrates how to create an EMF Ecore metamodel and a sample model that conforms to it reflectively (i.e. without generating any code).","title":"Reflective EMF Tutorial"},{"location":"doc/articles/reflective-emf-tutorial/#prerequisites","text":"To go through this tutorial you need to first install the Eclipse Modeling Distribution, Epsilon and Emfatic. Installation instructions are available here .","title":"Prerequisites"},{"location":"doc/articles/reflective-emf-tutorial/#create-a-new-project","text":"Go to File \u2192 New \u2192 Other... and select General \u2192 Project . Type library as the project name:","title":"Create a new project"},{"location":"doc/articles/reflective-emf-tutorial/#create-libraryemf","text":"Go to File \u2192 New \u2192 Other... and select File . Type library.emf as the file name: This is where we'll specify our Ecore metamodel using the Emfatic textual syntax","title":"Create library.emf"},{"location":"doc/articles/reflective-emf-tutorial/#add-content-to-libraryemf","text":"Now library.emf should be open and you can copy-paste the following text into it (our sample metamodel) and save. @namespace(uri=\"library\", prefix=\"\") package library; class Library { val Writer[*] writers; val Book[*] books; } class Writer { attr String name; ref Book[*] books; } class Book { attr String title; attr int pages = 100; attr BookCategory category; } enum BookCategory { Mystery; ScienceFiction; Biography; } Now your library.emf editor should look like this:","title":"Add content to library.emf"},{"location":"doc/articles/reflective-emf-tutorial/#generate-libraryecore-from-libraryemf","text":"The next step is to generate a proper XMI-based Ecore metamodel from the Emfatic textual representation. To do this, you can right-click library.emf and select Generate Ecore model as shown below: Once you've done this you should have a new file called library.ecore sitting next to your library.emf . Congratulations! You're half-way there! Tip If at some point you change library.emf , you need to repeat this step in order to update library.ecore .","title":"Generate library.ecore from library.emf"},{"location":"doc/articles/reflective-emf-tutorial/#register-libraryecore","text":"The next step is to let EMF know of the existence of your newly created library.ecore metamodel. To do this, right-click library.ecore and select Register EPackages as shown below:","title":"Register library.ecore"},{"location":"doc/articles/reflective-emf-tutorial/#create-a-model-that-conforms-to-libraryecore","text":"Now we're ready to create models that conform to our new Ecore metamodel! To create a model, go to File \u2192 New \u2192 Other... and select EMF Model as shown below: Click Next and set the name of the model to mylibrary.model : Then hit the Browse... button next to the Metamodel URI field and select library in the list that pops up: Finally, select Library from the Root instance type combo box and hit Finish : Now mylibrary.model should be open in a tree-based editor:","title":"Create a model that conforms to library.ecore"},{"location":"doc/articles/reflective-emf-tutorial/#add-content-to-mylibrarymodel","text":"To create a new Book under the library, you can right-click it and select New Child \u2192 Books \u2192 Book To set the title of the new book, you can right-click it and select Show Properties View Then, in the Title field of the Properties view, you can type the name of the book: Congratulations! You've just created your first EMF model!","title":"Add content to mylibrary.model"},{"location":"doc/articles/release-tasks/","text":"Releasing a new version of Epsilon \u00b6 There are a number of adiministrative and engineering tasks required to release a new verison of Epsilon. It's important to do them in proper order, as described below. Getting the release approved by Eclipse \u00b6 Log in to the PMI . Under the \"Releases\" section (right hand side under \"Committer Tools\"), click on \"Create a new release\" and fill in the fields. Note that we typically have a major.minor naming scheme, so for the release name, make sure it's 2 numbers (i.e. don't add a .0 patch number). If it has been more than one year since the last release, a review is required, so the release date should be set at least 8 days later than today. In this case, you will also need to do \"Generate IP log\" for the release. On the release, go to \"Edit\". At a minimum, you should ensure \"The Basics\" section is filled in and correct. For \"IP Due Dilligence Type\", select Type A if you're unsure. The hit \"Save\". When you're happy with it, and it has been more than a year since the last release, you need to submit the release for review. Updating Orbit repos \u00b6 Before creating the release, it's worth updating links to the Orbit repository used for resolving our dependencies. This commit provides an example of the process, showing which files should be updated. Managing the update sites \u00b6 When creating a new release, we need to add the update site for this release to the composite . We also need to create a folder containing the javadocs for the release under a directory with the name of the release at the root of the download site . We also need to remove the old release folder (move it to the archive). The new update site for the release is obtained by copying the interim. These tasks are automated by a shell script . Please check this before the release. The main thing you'll need to check are the OldVersion and NewVersion variables. There are two ways this can be run, but in any case, it needs to be run from the CI server. One way is to uncomment the NEW VERSION stage in the Jenkinsfile at the root of the repository, then push to trigger it. The other way is to run the release-logistics Jenkins job. Of course, you should check what is being run first, since if anything is deleted or overwritten, it can't be undone. Login to the CI and then you can check what is being run in Configure . Scroll down to Build and check the Execute shell task, making sure it's the same as that in the shell script in the repo (or whichever looks correct). Creating a new version in the Oomph installer \u00b6 The releng/org.eclipse.epsilon.releng/epsilonUse.setup should be updated with the new version. You can copy the Interim version and rename it to the release. The ordering of Product Versions should always be the latest release at the top, then Interim, then older versions. Whichever is at the top will be the default when users try to install Epsilon using Oomph. Of course, the properties for the new version should be changed to match (e.g. the name, description and update site). Check these carefully. A version of Eclipse should also be hard-coded, rather than relying on the latest update site, so pick whichever is the latest Eclipse release and use that. Build and release to Maven Central \u00b6 See this article . Tagging the release \u00b6 You should run git tag x.y , replacing x.y with the version. Then do git push origin x.y (again, x.y is the version). You can verify the tag was pushed by checking the output of git ls-remote --tags origin . Update the website \u00b6 The Epsilon website's Download page should be the only place in the website repo that needs updating. Specifically, you will need to change two source files in the source directory . Add the new release info to all-versions.md . Copy index.md and rename it to the current / old release. Then update index.md to mention the new release. Generally it should be as easy as Find and Replacing the old version with the new one. Also don't forget to build the static site for changes to take effect. Bump up versions \u00b6 Run the following commands from the root of the repository, replacing X.Y.Z with the full version number of the release (where Z is the patch, usually 0). Tycho will automatically take care of updating the Maven and PDE projects ( MANIFEST.MF , feature.xml etc.). Note that the standalone POMs (i.e. the pom-plain.xml files) are bumped separately using the third command below. Also note the order: run the Tycho one first, then bump epsilon.version , then run the Tycho versions bump again and it should succeed. mvn org.eclipse.tycho:tycho-versions-plugin:set-version -DnewVersion=X.Y.Z-SNAPSHOT mvn versions:set-property -Dproperty=epsilon.version -DnewVersion=X.Y.Z-SNAPSHOT mvn org.eclipse.tycho:tycho-versions-plugin:set-version -DnewVersion=X.Y.Z-SNAPSHOT mvn -f pom-plain.xml versions:set -DnewVersion=X.Y.Z-SNAPSHOT You may also need to manually bump up the version of the releng/org.eclipse.epsilon.target project. Specifically, the META-INF/MANIFEST.MF , but it's also worth checking the pom.xml to make sure they're consistent with each other. Also, in the root pom.xml in the repository, there is a property called epsilon.version . Also check org.eclipse.epsilon.test/META-INF/MANIFEST.MF . The build will fail if anything is inconsistent. Announce release on forum \u00b6 It would be courteous to let users know of the new release, along with the new features, on the Epsilon Forum .","title":"Releasing a new version of Epsilon"},{"location":"doc/articles/release-tasks/#releasing-a-new-version-of-epsilon","text":"There are a number of adiministrative and engineering tasks required to release a new verison of Epsilon. It's important to do them in proper order, as described below.","title":"Releasing a new version of Epsilon"},{"location":"doc/articles/release-tasks/#getting-the-release-approved-by-eclipse","text":"Log in to the PMI . Under the \"Releases\" section (right hand side under \"Committer Tools\"), click on \"Create a new release\" and fill in the fields. Note that we typically have a major.minor naming scheme, so for the release name, make sure it's 2 numbers (i.e. don't add a .0 patch number). If it has been more than one year since the last release, a review is required, so the release date should be set at least 8 days later than today. In this case, you will also need to do \"Generate IP log\" for the release. On the release, go to \"Edit\". At a minimum, you should ensure \"The Basics\" section is filled in and correct. For \"IP Due Dilligence Type\", select Type A if you're unsure. The hit \"Save\". When you're happy with it, and it has been more than a year since the last release, you need to submit the release for review.","title":"Getting the release approved by Eclipse"},{"location":"doc/articles/release-tasks/#updating-orbit-repos","text":"Before creating the release, it's worth updating links to the Orbit repository used for resolving our dependencies. This commit provides an example of the process, showing which files should be updated.","title":"Updating Orbit repos"},{"location":"doc/articles/release-tasks/#managing-the-update-sites","text":"When creating a new release, we need to add the update site for this release to the composite . We also need to create a folder containing the javadocs for the release under a directory with the name of the release at the root of the download site . We also need to remove the old release folder (move it to the archive). The new update site for the release is obtained by copying the interim. These tasks are automated by a shell script . Please check this before the release. The main thing you'll need to check are the OldVersion and NewVersion variables. There are two ways this can be run, but in any case, it needs to be run from the CI server. One way is to uncomment the NEW VERSION stage in the Jenkinsfile at the root of the repository, then push to trigger it. The other way is to run the release-logistics Jenkins job. Of course, you should check what is being run first, since if anything is deleted or overwritten, it can't be undone. Login to the CI and then you can check what is being run in Configure . Scroll down to Build and check the Execute shell task, making sure it's the same as that in the shell script in the repo (or whichever looks correct).","title":"Managing the update sites"},{"location":"doc/articles/release-tasks/#creating-a-new-version-in-the-oomph-installer","text":"The releng/org.eclipse.epsilon.releng/epsilonUse.setup should be updated with the new version. You can copy the Interim version and rename it to the release. The ordering of Product Versions should always be the latest release at the top, then Interim, then older versions. Whichever is at the top will be the default when users try to install Epsilon using Oomph. Of course, the properties for the new version should be changed to match (e.g. the name, description and update site). Check these carefully. A version of Eclipse should also be hard-coded, rather than relying on the latest update site, so pick whichever is the latest Eclipse release and use that.","title":"Creating a new version in the Oomph installer"},{"location":"doc/articles/release-tasks/#build-and-release-to-maven-central","text":"See this article .","title":"Build and release to Maven Central"},{"location":"doc/articles/release-tasks/#tagging-the-release","text":"You should run git tag x.y , replacing x.y with the version. Then do git push origin x.y (again, x.y is the version). You can verify the tag was pushed by checking the output of git ls-remote --tags origin .","title":"Tagging the release"},{"location":"doc/articles/release-tasks/#update-the-website","text":"The Epsilon website's Download page should be the only place in the website repo that needs updating. Specifically, you will need to change two source files in the source directory . Add the new release info to all-versions.md . Copy index.md and rename it to the current / old release. Then update index.md to mention the new release. Generally it should be as easy as Find and Replacing the old version with the new one. Also don't forget to build the static site for changes to take effect.","title":"Update the website"},{"location":"doc/articles/release-tasks/#bump-up-versions","text":"Run the following commands from the root of the repository, replacing X.Y.Z with the full version number of the release (where Z is the patch, usually 0). Tycho will automatically take care of updating the Maven and PDE projects ( MANIFEST.MF , feature.xml etc.). Note that the standalone POMs (i.e. the pom-plain.xml files) are bumped separately using the third command below. Also note the order: run the Tycho one first, then bump epsilon.version , then run the Tycho versions bump again and it should succeed. mvn org.eclipse.tycho:tycho-versions-plugin:set-version -DnewVersion=X.Y.Z-SNAPSHOT mvn versions:set-property -Dproperty=epsilon.version -DnewVersion=X.Y.Z-SNAPSHOT mvn org.eclipse.tycho:tycho-versions-plugin:set-version -DnewVersion=X.Y.Z-SNAPSHOT mvn -f pom-plain.xml versions:set -DnewVersion=X.Y.Z-SNAPSHOT You may also need to manually bump up the version of the releng/org.eclipse.epsilon.target project. Specifically, the META-INF/MANIFEST.MF , but it's also worth checking the pom.xml to make sure they're consistent with each other. Also, in the root pom.xml in the repository, there is a property called epsilon.version . Also check org.eclipse.epsilon.test/META-INF/MANIFEST.MF . The build will fail if anything is inconsistent.","title":"Bump up versions"},{"location":"doc/articles/release-tasks/#announce-release-on-forum","text":"It would be courteous to let users know of the new release, along with the new features, on the Epsilon Forum .","title":"Announce release on forum"},{"location":"doc/articles/resolved-bugs/","text":"Resolved Bugs \u00b6 There are two types of resolved bugs in Epsilon. Bugs that have been fixed in the latest version of the source code and in the latest interim version but have not been yet integrated in the latest stable version Bugs that have been fixed in the latest stable version Bugzilla Conventions \u00b6 Below are the conventions used by the Epsilon committers to characterise reported bugs according to their status. New bug: Status \u2192 New Assigned bug: Status \u2192 Assigned Bug fixed in the latest version of the source code (interim update site is rebuilt automatically): Status \u2192 Resolved/Fixed Bug fixed in the latest stable version: Status \u2192 Closed/Fixed Release Process \u00b6 When releasing a new stable version, go through all bugs of type [1], set their status to Closed/Fixed.","title":"Resolved Bugs"},{"location":"doc/articles/resolved-bugs/#resolved-bugs","text":"There are two types of resolved bugs in Epsilon. Bugs that have been fixed in the latest version of the source code and in the latest interim version but have not been yet integrated in the latest stable version Bugs that have been fixed in the latest stable version","title":"Resolved Bugs"},{"location":"doc/articles/resolved-bugs/#bugzilla-conventions","text":"Below are the conventions used by the Epsilon committers to characterise reported bugs according to their status. New bug: Status \u2192 New Assigned bug: Status \u2192 Assigned Bug fixed in the latest version of the source code (interim update site is rebuilt automatically): Status \u2192 Resolved/Fixed Bug fixed in the latest stable version: Status \u2192 Closed/Fixed","title":"Bugzilla Conventions"},{"location":"doc/articles/resolved-bugs/#release-process","text":"When releasing a new stable version, go through all bugs of type [1], set their status to Closed/Fixed.","title":"Release Process"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/","text":"Running Epsilon's Ant Tasks from Command Line \u00b6 This example project shows how to download, configure and run Epsilon's Ant tasks from the command line using Ant, Maven and Gradle. To run the examples below, you only need to have Ant , Maven or Gradle installed in your system. Ant \u00b6 When you run the ant command in the root directory of the project, the following will happen: The build file ( build.xml ) will download Apache Ivy in a temporary directory Ivy will fetch the required Epsilon jars (also in a temporary directory) from Maven Central/Sonatype The build file will set up Epsilon's Ant tasks The following part of the build file will be executed, which will load an EMF-based model and then run an EOL program against it <epsilon.emf.loadModel name= \"Library\" modelfile= \"library.model\" metamodelfile= \"library.ecore\" /> <epsilon.eol> for (writer in Writer.all) { (writer.name + \" wrote \" + writer.books.title.concat(\", \")).println(); } <model ref= \"Library\" /> </epsilon.eol> If everything goes well, the last few lines of the output of the ant command should look like this: run-epsilon: [epsilon.eol] Agatha Christie wrote Endless Night BUILD SUCCESSFUL The complete source code is below and in Epsilon's Git repo . build.xml <project default= \"run-epsilon\" xmlns:ivy= \"antlib:org.apache.ivy.ant\" > <!-- This part of the build file runs our Epsilon tasks --> <target name= \"run-epsilon\" depends= \"setup-epsilon\" > <!-- Load the library.model EMF model --> <epsilon.emf.loadModel name= \"Library\" modelfile= \"library.model\" metamodelfile= \"library.ecore\" /> <!-- Run library.eol against it --> <epsilon.eol src= \"library.eol\" > <model ref= \"Library\" /> </epsilon.eol> </target> <!-- The rest of the build file downloads Ivy, fetches the Epsilon jars and sets up the Epsilon ANT tasks --> <property name= \"ivy.version\" value= \"2.5.0\" /> <property name= \"ivy.jar.dir\" value= \"${basedir}/ivy\" /> <property name= \"ivy.jar.file\" value= \"${ivy.jar.dir}/ivy.jar\" /> <!-- Downloads Ivy --> <target name= \"download-ivy\" unless= \"skip.download\" > <mkdir dir= \"${ivy.jar.dir}\" /> <get src= \"https://repo1.maven.org/maven2/org/apache/ivy/ivy/${ivy.version}/ivy-${ivy.version}.jar\" dest= \"${ivy.jar.file}\" usetimestamp= \"true\" /> </target> <!-- Sets up the Ivy ANT tasks --> <target name= \"setup-ivy\" depends= \"download-ivy\" > <path id= \"ivy.lib.path\" > <fileset dir= \"${ivy.jar.dir}\" includes= \"*.jar\" /> </path> <taskdef resource= \"org/apache/ivy/ant/antlib.xml\" uri= \"antlib:org.apache.ivy.ant\" classpathref= \"ivy.lib.path\" /> </target> <target name= \"setup-epsilon\" depends= \"setup-ivy\" > <!-- Uncomment the line below to clear Ivy's cache --> <!--ivy:cleancache/--> <ivy:settings file= \"ivysettings.xml\" /> <!-- Fetch all relevant Epsilon jars under lib/binaries --> <ivy:retrieve conf= \"binaries\" pattern= \"lib/[conf]/[artifact](-[classifier]).[ext]\" /> <!-- Construct a path from all the jars under lib/binaries --> <path id= \"lib.path\" > <fileset dir= \"lib/binaries\" includes= \"*.jar\" /> </path> <!-- Load the ANT tasks from o.e.e.workflow and o.e.e.workflow.emf using the same classloader --> <taskdef classpathref= \"lib.path\" resource= \"org/eclipse/epsilon/workflow/tasks/tasks.xml\" loaderref= \"lib.path.loader\" /> <taskdef classpathref= \"lib.path\" resource= \"org/eclipse/epsilon/workflow/tasks/emf/tasks.xml\" loaderref= \"lib.path.loader\" /> </target> </project> ivy.xml <ivy-module version= \"2.0\" > <info organisation= \"\" module= \"\" /> <configurations> <conf name= \"binaries\" /> </configurations> <dependencies> <dependency org= \"org.eclipse.epsilon\" name= \"org.eclipse.epsilon.workflow\" rev= \"2.4.0\" conf= \"binaries->default\" /> <dependency org= \"org.eclipse.epsilon\" name= \"org.eclipse.epsilon.workflow.emf\" rev= \"2.4.0\" conf= \"binaries->default\" /> <exclude artifact= \"org.eclipse.equinox.registry\" /> <exclude artifact= \"org.eclipse.core.runtime\" /> </dependencies> </ivy-module> ivysettings.xml <ivysettings> <settings defaultResolver= \"default-chain\" defaultConflictManager= \"all\" /> <resolvers> <ibiblio name= \"maven-central\" m2compatible= \"true\" usepoms= \"true\" /> <ibiblio name= \"sonatype-snapshots\" root= \"https://oss.sonatype.org/content/repositories/snapshots\" m2compatible= \"true\" /> <chain name= \"default-chain\" > <resolver ref= \"sonatype-snapshots\" /> <resolver ref= \"maven-central\" /> </chain> </resolvers> </ivysettings> Maven \u00b6 Since Maven can run Ant tasks, Epsilon Ant tasks can also be executed from a Maven build ( mvn clean install ) as shown below. pom.xml <project> <modelVersion> 4.0.0 </modelVersion> <artifactId> epsilon-maven </artifactId> <groupId> org.eclipse.epsilon </groupId> <version> 1.0-SNAPSHOT </version> <pluginRepositories> <pluginRepository> <id> Sonatype </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </pluginRepository> </pluginRepositories> <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-antrun-plugin </artifactId> <version> 3.0.0 </version> <executions> <execution> <phase> compile </phase> <configuration> <target> <!-- Set up the core Epsilon tasks --> <taskdef resource= \"org/eclipse/epsilon/workflow/tasks/tasks.xml\" /> <!-- Set up the Epsilon EMF tasks --> <taskdef resource= \"org/eclipse/epsilon/workflow/tasks/emf/tasks.xml\" /> <!-- Load the library.model EMF model --> <epsilon.emf.loadModel name= \"Library\" modelfile= \"library.model\" metamodelfile= \"library.ecore\" /> <!-- Run library.eol against it --> <epsilon.eol src= \"library.eol\" > <model ref= \"Library\" /> </epsilon.eol> <!-- Run library.eunit --> <epsilon.eunit src= \"library.eunit\" > <modelTasks> <epsilon.emf.loadModel name= \"A\" metamodelfile= \"library.ecore\" read= \"false\" store= \"false\" modelfile= \"dummyA.model\" /> <epsilon.emf.loadModel name= \"B\" metamodelfile= \"library.ecore\" read= \"false\" store= \"false\" modelfile= \"dummyB.model\" /> </modelTasks> <comparators> <comparator classname= \"org.eclipse.epsilon.eunit.cmp.emf.EMFModelComparator\" /> </comparators> </epsilon.eunit> </target> </configuration> <goals> <goal> run </goal> </goals> </execution> </executions> <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.workflow </artifactId> <version> 2.4.0 </version> </dependency> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.workflow.emf </artifactId> <version> 2.4.0 </version> </dependency> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eunit.cmp.emf </artifactId> <version> 2.4.0 </version> </dependency> </dependencies> </plugin> </plugins> </build> </project> Gradle \u00b6 Since Gradle can also run Ant tasks , Epsilon Ant tasks can also be executed from a Gradle build ( gradle run ) as shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow.emf:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.eunit.cmp.emf:2.4.0' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set up the Epsilon EMF tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/emf/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the library.model EMF model ant . 'epsilon.emf.loadModel' ( name: 'Library' , modelfile: 'library.model' , metamodelfile: 'library.ecore' ) // Run library.eol against it ant . 'epsilon.eol' ( src: 'library.eol' ){ model ( ref: 'Library' ) } // Run library.eunit ant . 'epsilon.eunit' ( src: 'library.eunit' ){ modelTasks () { ant . 'epsilon.emf.loadModel' ( name: 'A' , metamodelfile: 'library.ecore' , read: 'false' , store: 'false' , modelfile: 'dummyA.model' ) ant . 'epsilon.emf.loadModel' ( name: 'B' , metamodelfile: 'library.ecore' , read: 'false' , store: 'false' , modelfile: 'dummyB.model' ) } comparators () { comparator ( classname: 'org.eclipse.epsilon.eunit.cmp.emf.EMFModelComparator' ) } } } Flexmi and Emfatic \u00b6 You can also use Flexmi instead of XMI ( library.flexmi instead of library.model ) for the model, and Emfatic instead of Ecore ( library.emf instead of library.ecore ) by adding the following dependency to your ANT/Maven/Gradle build. Ivy/ANT <dependency org= \"org.eclipse.emfatic\" name= \"org.eclipse.emfatic.core\" rev= \"1.1.0-SNAPSHOT\" conf= \"binaries->default\" /> Maven <dependency> <groupId> org.eclipse.emfatic </groupId> <artifactId> org.eclipse.emfatic.core </artifactId> <version> 1.1.0-SNAPSHOT </version> </dependency> Gradle epsilon 'org.eclipse.emfatic:org.eclipse.emfatic.core:1.1.0-SNAPSHOT' A complete Gradle example that uses library.flexmi instead of (the XMI-based) library.model , and library.emf instead of library.ecore is shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow.emf:2.4.0' epsilon ( 'org.eclipse.emfatic:org.eclipse.emfatic.core:1.1.0-SNAPSHOT' ) { exclude group: 'org.eclipse.platform' } } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set up the Epsilon EMF tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/emf/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the library.flexmi EMF model ant . 'epsilon.emf.loadModel' ( name: 'Library' , modelfile: '../library.flexmi' , metamodelfile: '../library.emf' ) // Run library.eol against it ant . 'epsilon.eol' ( src: '../library.eol' ){ model ( ref: 'Library' ) } } library.eol for (writer in Writer.all) { (writer.name + \" wrote \" + writer.books.title.concat(\", \")).println(); } library.flexmi <?nsuri library?> <library> <writer name= \"Agatha Christie\" /> <book title= \"Endless Night\" pages= \"224\" author= \"Agatha Christie\" /> </library> library.emf @namespace(uri=\"library\", prefix=\"\") package library; class Library { val Writer[*] writers; val Book[*] books; } class Writer { attr String name; ref Book[*]#author books; } class Book { attr String title; attr int pages = 100; attr BookCategory category; ref Writer[1]#books author; } enum BookCategory { Mystery = 0; ScienceFiction = 1; Biography = 2; } Excel \u00b6 The example below demonstrates using the generic epsilon.loadModel task to run the same EOL program against an Excel spreadsheet . build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.emc.spreadsheets.excel:2.4.0' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the library.xlsx spreadsheet ant . 'epsilon.loadModel' ( name: 'Library' , impl: 'org.eclipse.epsilon.emc.spreadsheets.excel.ExcelModel' ){ parameter ( name: 'SPREADSHEET_FILE' , file: 'library.xlsx' ) parameter ( name: 'CONFIGURATION_FILE' , file: 'mapping.xml' ) } // Run library.eol against it ant . 'epsilon.eol' ( src: '../library.eol' ){ model ( ref: 'Library' ) } } mapping.xml <spreadsheet> <worksheet name= \"Writer\" > <column name= \"name\" /> <column name= \"books\" many= \"true\" /> </worksheet> <worksheet name= \"Book\" > <column name= \"id\" /> <column name= \"title\" /> <column name= \"pages\" datatype= \"integer\" /> </worksheet> <reference source= \"Writer->books\" target= \"Book->id\" /> </spreadsheet> UML \u00b6 Models conforming to the Eclipse UML2 metamodel can be queried as shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://repo.eclipse.org/content/repositories/acceleo-releases/\" } maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon ( 'org.eclipse.epsilon:org.eclipse.epsilon.emc.uml:2.4.0' ) { // UML2 is broken on Maven Central exclude group: 'org.eclipse.uml2' } epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' // Fetch the UML2 dependencies from repo.eclipse.org instead epsilon 'org.eclipse.uml2:org.eclipse.uml2.uml:5.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.common:2.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.types:2.0.0.v20140910-1354' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load a UML model from model.uml ant . 'epsilon.loadModel' ( name: 'UML' , impl: 'org.eclipse.epsilon.emc.uml.UmlModel' ){ parameter ( name: 'modelFile' , file: 'model.uml' ) } // Run library.eol against it ant . 'epsilon.eol' ( src: 'uml.eol' ){ model ( ref: 'UML' ) } } uml.eol // Print the names of all // classes in the model for (c in Class.all) { c.name.println(); } model.uml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xmi:XMI xmi:version= \"2.1\" xmlns:xmi= \"http://schema.omg.org/spec/XMI/2.1\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xmlns:uml= \"http://www.eclipse.org/uml2/5.0.0/UML\" > <uml:Model xmi:id= \"_in3dgJiMEeuzROqeHhotPw\" name= \"umlcddemo\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_in3dgJiMEeuzROqeHhotPw0\" source= \"genmymodel\" > <details xmi:id= \"_in3dgJiMEeuzROqeHhotPw00\" key= \"uuid\" value= \"_in3dgJiMEeuzROqeHhotPw\" /> <details xmi:id= \"_in3dgJiMEeuzROqeHhotPw01\" key= \"author\" value= \"kolovos\" /> </eAnnotations> </xmi:Extension> <packageImport xmi:id= \"_in3dgZiMEeuzROqeHhotPw\" importingNamespace= \"_in3dgJiMEeuzROqeHhotPw\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_in3dgZiMEeuzROqeHhotPw0\" source= \"genmymodel\" > <details xmi:id= \"_in3dgZiMEeuzROqeHhotPw00\" key= \"uuid\" value= \"_in3dgZiMEeuzROqeHhotPw\" /> </eAnnotations> </xmi:Extension> <importedPackage href= \"http://www.omg.org/spec/UML/20131001/PrimitiveTypes.xmi#/\" /> </packageImport> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_rAoBcHq6EDmVkdImmyh-dQ\" name= \"Project\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_rAoBcHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_rAoBcHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_rAoBcHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_xAOzcHq6EDmVkdImmyh-dQ\" name= \"Task\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_xAOzcHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_xAOzcHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_xAOzcHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_yHEfsXq6EDmVkdImmyh-dQ\" name= \"Project_Task\" memberEnd= \"_yHD4oXq6EDmVkdImmyh-dQ _yHCqgHq6EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_yHCqgHq6EDmVkdImmyh-dQ _yHD4oXq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHEfsXq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHEfsXq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHEfsXq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_yHCqgHq6EDmVkdImmyh-dQ\" name= \"project\" type= \"_rAoBcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_yHEfsXq6EDmVkdImmyh-dQ\" association= \"_yHEfsXq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHCqgHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHCqgHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHCqgHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_yHDRkHq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHDRkHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHDRkHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHDRkHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_yHD4oHq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHD4oHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHD4oHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHD4oHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_yHD4oXq6EDmVkdImmyh-dQ\" name= \"tasks\" type= \"_xAOzcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_yHEfsXq6EDmVkdImmyh-dQ\" association= \"_yHEfsXq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHD4oXq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHD4oXq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHD4oXq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_yHD4onq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHD4onq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHD4onq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHD4onq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_zUmCwHq6EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_zUmCwHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_zUmCwHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_zUmCwHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_86ZfYHq6EDmVkdImmyh-dQ\" name= \"Person\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_86ZfYHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_86ZfYHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_86ZfYHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_-j5z0nq6EDmVkdImmyh-dQ\" name= \"Project_Person\" memberEnd= \"_-j5Mwnq6EDmVkdImmyh-dQ _-j4lsnq6EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_-j4lsnq6EDmVkdImmyh-dQ _-j5Mwnq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5z0nq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5z0nq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5z0nq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_-j4lsnq6EDmVkdImmyh-dQ\" name= \"project\" type= \"_rAoBcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_-j5z0nq6EDmVkdImmyh-dQ\" association= \"_-j5z0nq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j4lsnq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j4lsnq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j4lsnq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_-j5MwHq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5MwHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5MwHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5MwHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_-j5MwXq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5MwXq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5MwXq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5MwXq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_-j5Mwnq6EDmVkdImmyh-dQ\" name= \"persons\" type= \"_86ZfYHq6EDmVkdImmyh-dQ\" owningAssociation= \"_-j5z0nq6EDmVkdImmyh-dQ\" association= \"_-j5z0nq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5Mwnq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5Mwnq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5Mwnq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_-j5z0Hq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5z0Hq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5z0Hq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5z0Hq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_Ctk-8Hq7EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_Ctk-8Hq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_Ctk-8Hq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_Ctk-8Hq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_FYr6UHq7EDmVkdImmyh-dQ\" name= \"Effort\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_FYr6UHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_FYr6UHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_FYr6UHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_HOgzgXq7EDmVkdImmyh-dQ\" name= \"Effort_Person\" memberEnd= \"_HOgMcHq7EDmVkdImmyh-dQ _HOeXQnq7EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_HOeXQnq7EDmVkdImmyh-dQ _HOgMcHq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgzgXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgzgXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgzgXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_HOeXQnq7EDmVkdImmyh-dQ\" name= \"effort\" type= \"_FYr6UHq7EDmVkdImmyh-dQ\" owningAssociation= \"_HOgzgXq7EDmVkdImmyh-dQ\" association= \"_HOgzgXq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOeXQnq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOeXQnq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOeXQnq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_HOflYHq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOflYHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOflYHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOflYHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_N8H7AHq7EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_N8H7AHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_N8H7AHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_N8H7AHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_HOgMcHq7EDmVkdImmyh-dQ\" name= \"person\" type= \"_86ZfYHq6EDmVkdImmyh-dQ\" owningAssociation= \"_HOgzgXq7EDmVkdImmyh-dQ\" association= \"_HOgzgXq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgMcHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgMcHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgMcHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_HOgMcXq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgMcXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgMcXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgMcXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_HOgzgHq7EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgzgHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgzgHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgzgHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_JLgrt3q7EDmVkdImmyh-dQ\" name= \"Effort_Task\" memberEnd= \"_JLgrtHq7EDmVkdImmyh-dQ _JLgrsXq7EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_JLgrsXq7EDmVkdImmyh-dQ _JLgrtHq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrt3q7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrt3q7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrt3q7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_JLgrsXq7EDmVkdImmyh-dQ\" name= \"effort\" type= \"_FYr6UHq7EDmVkdImmyh-dQ\" owningAssociation= \"_JLgrt3q7EDmVkdImmyh-dQ\" association= \"_JLgrt3q7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrsXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrsXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrsXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_JLgrsnq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrsnq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrsnq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrsnq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_TnCPYHq7EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_TnCPYHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_TnCPYHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_TnCPYHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_JLgrtHq7EDmVkdImmyh-dQ\" name= \"task\" type= \"_xAOzcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_JLgrt3q7EDmVkdImmyh-dQ\" association= \"_JLgrt3q7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrtHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrtHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrtHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_JLgrtXq7EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrtXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrtXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrtXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_JLgrtnq7EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrtnq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrtnq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrtnq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> </uml:Model> </xmi:XMI> GenMyModel \u00b6 GenMyModel is a web-based modelling tool that can be used to create UML2-compliant models. You can consume the XMI representation of a public GenMyModel UML model directly from Epsilon as shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://repo.eclipse.org/content/repositories/acceleo-releases/\" } maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon ( 'org.eclipse.epsilon:org.eclipse.epsilon.emc.uml:2.4.0' ) { // UML2 is broken on Maven Central exclude group: 'org.eclipse.uml2' } epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' // Fetch the UML2 dependencies from repo.eclipse.org instead epsilon 'org.eclipse.uml2:org.eclipse.uml2.uml:5.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.common:2.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.types:2.0.0.v20140910-1354' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load a UML model straight from GenMyModel ant . 'epsilon.loadModel' ( name: 'UML' , impl: 'org.eclipse.epsilon.emc.uml.UmlModel' ){ parameter ( name: 'modelUri' , value: 'https://app.genmymodel.com/api/projects/_in3dgJiMEeuzROqeHhotPw/custom-xmi' ) } // Run library.eol against it ant . 'epsilon.eol' ( src: '../uml.eol' ){ model ( ref: 'UML' ) } } Epsilon 1.x \u00b6 If you would like to use an older (1.x) version of Epsilon, you can use this example instead , which uses a fat jar we used to produce ( epsilon-1.x-kitchensink.jar ) before moving all our jars to Maven Central/Sonatype.","title":"Running Epsilon's Ant Tasks from Command Line"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#running-epsilons-ant-tasks-from-command-line","text":"This example project shows how to download, configure and run Epsilon's Ant tasks from the command line using Ant, Maven and Gradle. To run the examples below, you only need to have Ant , Maven or Gradle installed in your system.","title":"Running Epsilon's Ant Tasks from Command Line"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#ant","text":"When you run the ant command in the root directory of the project, the following will happen: The build file ( build.xml ) will download Apache Ivy in a temporary directory Ivy will fetch the required Epsilon jars (also in a temporary directory) from Maven Central/Sonatype The build file will set up Epsilon's Ant tasks The following part of the build file will be executed, which will load an EMF-based model and then run an EOL program against it <epsilon.emf.loadModel name= \"Library\" modelfile= \"library.model\" metamodelfile= \"library.ecore\" /> <epsilon.eol> for (writer in Writer.all) { (writer.name + \" wrote \" + writer.books.title.concat(\", \")).println(); } <model ref= \"Library\" /> </epsilon.eol> If everything goes well, the last few lines of the output of the ant command should look like this: run-epsilon: [epsilon.eol] Agatha Christie wrote Endless Night BUILD SUCCESSFUL The complete source code is below and in Epsilon's Git repo . build.xml <project default= \"run-epsilon\" xmlns:ivy= \"antlib:org.apache.ivy.ant\" > <!-- This part of the build file runs our Epsilon tasks --> <target name= \"run-epsilon\" depends= \"setup-epsilon\" > <!-- Load the library.model EMF model --> <epsilon.emf.loadModel name= \"Library\" modelfile= \"library.model\" metamodelfile= \"library.ecore\" /> <!-- Run library.eol against it --> <epsilon.eol src= \"library.eol\" > <model ref= \"Library\" /> </epsilon.eol> </target> <!-- The rest of the build file downloads Ivy, fetches the Epsilon jars and sets up the Epsilon ANT tasks --> <property name= \"ivy.version\" value= \"2.5.0\" /> <property name= \"ivy.jar.dir\" value= \"${basedir}/ivy\" /> <property name= \"ivy.jar.file\" value= \"${ivy.jar.dir}/ivy.jar\" /> <!-- Downloads Ivy --> <target name= \"download-ivy\" unless= \"skip.download\" > <mkdir dir= \"${ivy.jar.dir}\" /> <get src= \"https://repo1.maven.org/maven2/org/apache/ivy/ivy/${ivy.version}/ivy-${ivy.version}.jar\" dest= \"${ivy.jar.file}\" usetimestamp= \"true\" /> </target> <!-- Sets up the Ivy ANT tasks --> <target name= \"setup-ivy\" depends= \"download-ivy\" > <path id= \"ivy.lib.path\" > <fileset dir= \"${ivy.jar.dir}\" includes= \"*.jar\" /> </path> <taskdef resource= \"org/apache/ivy/ant/antlib.xml\" uri= \"antlib:org.apache.ivy.ant\" classpathref= \"ivy.lib.path\" /> </target> <target name= \"setup-epsilon\" depends= \"setup-ivy\" > <!-- Uncomment the line below to clear Ivy's cache --> <!--ivy:cleancache/--> <ivy:settings file= \"ivysettings.xml\" /> <!-- Fetch all relevant Epsilon jars under lib/binaries --> <ivy:retrieve conf= \"binaries\" pattern= \"lib/[conf]/[artifact](-[classifier]).[ext]\" /> <!-- Construct a path from all the jars under lib/binaries --> <path id= \"lib.path\" > <fileset dir= \"lib/binaries\" includes= \"*.jar\" /> </path> <!-- Load the ANT tasks from o.e.e.workflow and o.e.e.workflow.emf using the same classloader --> <taskdef classpathref= \"lib.path\" resource= \"org/eclipse/epsilon/workflow/tasks/tasks.xml\" loaderref= \"lib.path.loader\" /> <taskdef classpathref= \"lib.path\" resource= \"org/eclipse/epsilon/workflow/tasks/emf/tasks.xml\" loaderref= \"lib.path.loader\" /> </target> </project> ivy.xml <ivy-module version= \"2.0\" > <info organisation= \"\" module= \"\" /> <configurations> <conf name= \"binaries\" /> </configurations> <dependencies> <dependency org= \"org.eclipse.epsilon\" name= \"org.eclipse.epsilon.workflow\" rev= \"2.4.0\" conf= \"binaries->default\" /> <dependency org= \"org.eclipse.epsilon\" name= \"org.eclipse.epsilon.workflow.emf\" rev= \"2.4.0\" conf= \"binaries->default\" /> <exclude artifact= \"org.eclipse.equinox.registry\" /> <exclude artifact= \"org.eclipse.core.runtime\" /> </dependencies> </ivy-module> ivysettings.xml <ivysettings> <settings defaultResolver= \"default-chain\" defaultConflictManager= \"all\" /> <resolvers> <ibiblio name= \"maven-central\" m2compatible= \"true\" usepoms= \"true\" /> <ibiblio name= \"sonatype-snapshots\" root= \"https://oss.sonatype.org/content/repositories/snapshots\" m2compatible= \"true\" /> <chain name= \"default-chain\" > <resolver ref= \"sonatype-snapshots\" /> <resolver ref= \"maven-central\" /> </chain> </resolvers> </ivysettings>","title":"Ant"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#maven","text":"Since Maven can run Ant tasks, Epsilon Ant tasks can also be executed from a Maven build ( mvn clean install ) as shown below. pom.xml <project> <modelVersion> 4.0.0 </modelVersion> <artifactId> epsilon-maven </artifactId> <groupId> org.eclipse.epsilon </groupId> <version> 1.0-SNAPSHOT </version> <pluginRepositories> <pluginRepository> <id> Sonatype </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </pluginRepository> </pluginRepositories> <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-antrun-plugin </artifactId> <version> 3.0.0 </version> <executions> <execution> <phase> compile </phase> <configuration> <target> <!-- Set up the core Epsilon tasks --> <taskdef resource= \"org/eclipse/epsilon/workflow/tasks/tasks.xml\" /> <!-- Set up the Epsilon EMF tasks --> <taskdef resource= \"org/eclipse/epsilon/workflow/tasks/emf/tasks.xml\" /> <!-- Load the library.model EMF model --> <epsilon.emf.loadModel name= \"Library\" modelfile= \"library.model\" metamodelfile= \"library.ecore\" /> <!-- Run library.eol against it --> <epsilon.eol src= \"library.eol\" > <model ref= \"Library\" /> </epsilon.eol> <!-- Run library.eunit --> <epsilon.eunit src= \"library.eunit\" > <modelTasks> <epsilon.emf.loadModel name= \"A\" metamodelfile= \"library.ecore\" read= \"false\" store= \"false\" modelfile= \"dummyA.model\" /> <epsilon.emf.loadModel name= \"B\" metamodelfile= \"library.ecore\" read= \"false\" store= \"false\" modelfile= \"dummyB.model\" /> </modelTasks> <comparators> <comparator classname= \"org.eclipse.epsilon.eunit.cmp.emf.EMFModelComparator\" /> </comparators> </epsilon.eunit> </target> </configuration> <goals> <goal> run </goal> </goals> </execution> </executions> <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.workflow </artifactId> <version> 2.4.0 </version> </dependency> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.workflow.emf </artifactId> <version> 2.4.0 </version> </dependency> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eunit.cmp.emf </artifactId> <version> 2.4.0 </version> </dependency> </dependencies> </plugin> </plugins> </build> </project>","title":"Maven"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#gradle","text":"Since Gradle can also run Ant tasks , Epsilon Ant tasks can also be executed from a Gradle build ( gradle run ) as shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow.emf:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.eunit.cmp.emf:2.4.0' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set up the Epsilon EMF tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/emf/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the library.model EMF model ant . 'epsilon.emf.loadModel' ( name: 'Library' , modelfile: 'library.model' , metamodelfile: 'library.ecore' ) // Run library.eol against it ant . 'epsilon.eol' ( src: 'library.eol' ){ model ( ref: 'Library' ) } // Run library.eunit ant . 'epsilon.eunit' ( src: 'library.eunit' ){ modelTasks () { ant . 'epsilon.emf.loadModel' ( name: 'A' , metamodelfile: 'library.ecore' , read: 'false' , store: 'false' , modelfile: 'dummyA.model' ) ant . 'epsilon.emf.loadModel' ( name: 'B' , metamodelfile: 'library.ecore' , read: 'false' , store: 'false' , modelfile: 'dummyB.model' ) } comparators () { comparator ( classname: 'org.eclipse.epsilon.eunit.cmp.emf.EMFModelComparator' ) } } }","title":"Gradle"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#flexmi-and-emfatic","text":"You can also use Flexmi instead of XMI ( library.flexmi instead of library.model ) for the model, and Emfatic instead of Ecore ( library.emf instead of library.ecore ) by adding the following dependency to your ANT/Maven/Gradle build. Ivy/ANT <dependency org= \"org.eclipse.emfatic\" name= \"org.eclipse.emfatic.core\" rev= \"1.1.0-SNAPSHOT\" conf= \"binaries->default\" /> Maven <dependency> <groupId> org.eclipse.emfatic </groupId> <artifactId> org.eclipse.emfatic.core </artifactId> <version> 1.1.0-SNAPSHOT </version> </dependency> Gradle epsilon 'org.eclipse.emfatic:org.eclipse.emfatic.core:1.1.0-SNAPSHOT' A complete Gradle example that uses library.flexmi instead of (the XMI-based) library.model , and library.emf instead of library.ecore is shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow.emf:2.4.0' epsilon ( 'org.eclipse.emfatic:org.eclipse.emfatic.core:1.1.0-SNAPSHOT' ) { exclude group: 'org.eclipse.platform' } } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set up the Epsilon EMF tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/emf/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the library.flexmi EMF model ant . 'epsilon.emf.loadModel' ( name: 'Library' , modelfile: '../library.flexmi' , metamodelfile: '../library.emf' ) // Run library.eol against it ant . 'epsilon.eol' ( src: '../library.eol' ){ model ( ref: 'Library' ) } } library.eol for (writer in Writer.all) { (writer.name + \" wrote \" + writer.books.title.concat(\", \")).println(); } library.flexmi <?nsuri library?> <library> <writer name= \"Agatha Christie\" /> <book title= \"Endless Night\" pages= \"224\" author= \"Agatha Christie\" /> </library> library.emf @namespace(uri=\"library\", prefix=\"\") package library; class Library { val Writer[*] writers; val Book[*] books; } class Writer { attr String name; ref Book[*]#author books; } class Book { attr String title; attr int pages = 100; attr BookCategory category; ref Writer[1]#books author; } enum BookCategory { Mystery = 0; ScienceFiction = 1; Biography = 2; }","title":"Flexmi and Emfatic"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#excel","text":"The example below demonstrates using the generic epsilon.loadModel task to run the same EOL program against an Excel spreadsheet . build.gradle configurations { epsilon } repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.emc.spreadsheets.excel:2.4.0' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load the library.xlsx spreadsheet ant . 'epsilon.loadModel' ( name: 'Library' , impl: 'org.eclipse.epsilon.emc.spreadsheets.excel.ExcelModel' ){ parameter ( name: 'SPREADSHEET_FILE' , file: 'library.xlsx' ) parameter ( name: 'CONFIGURATION_FILE' , file: 'mapping.xml' ) } // Run library.eol against it ant . 'epsilon.eol' ( src: '../library.eol' ){ model ( ref: 'Library' ) } } mapping.xml <spreadsheet> <worksheet name= \"Writer\" > <column name= \"name\" /> <column name= \"books\" many= \"true\" /> </worksheet> <worksheet name= \"Book\" > <column name= \"id\" /> <column name= \"title\" /> <column name= \"pages\" datatype= \"integer\" /> </worksheet> <reference source= \"Writer->books\" target= \"Book->id\" /> </spreadsheet>","title":"Excel"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#uml","text":"Models conforming to the Eclipse UML2 metamodel can be queried as shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://repo.eclipse.org/content/repositories/acceleo-releases/\" } maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon ( 'org.eclipse.epsilon:org.eclipse.epsilon.emc.uml:2.4.0' ) { // UML2 is broken on Maven Central exclude group: 'org.eclipse.uml2' } epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' // Fetch the UML2 dependencies from repo.eclipse.org instead epsilon 'org.eclipse.uml2:org.eclipse.uml2.uml:5.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.common:2.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.types:2.0.0.v20140910-1354' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load a UML model from model.uml ant . 'epsilon.loadModel' ( name: 'UML' , impl: 'org.eclipse.epsilon.emc.uml.UmlModel' ){ parameter ( name: 'modelFile' , file: 'model.uml' ) } // Run library.eol against it ant . 'epsilon.eol' ( src: 'uml.eol' ){ model ( ref: 'UML' ) } } uml.eol // Print the names of all // classes in the model for (c in Class.all) { c.name.println(); } model.uml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xmi:XMI xmi:version= \"2.1\" xmlns:xmi= \"http://schema.omg.org/spec/XMI/2.1\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xmlns:uml= \"http://www.eclipse.org/uml2/5.0.0/UML\" > <uml:Model xmi:id= \"_in3dgJiMEeuzROqeHhotPw\" name= \"umlcddemo\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_in3dgJiMEeuzROqeHhotPw0\" source= \"genmymodel\" > <details xmi:id= \"_in3dgJiMEeuzROqeHhotPw00\" key= \"uuid\" value= \"_in3dgJiMEeuzROqeHhotPw\" /> <details xmi:id= \"_in3dgJiMEeuzROqeHhotPw01\" key= \"author\" value= \"kolovos\" /> </eAnnotations> </xmi:Extension> <packageImport xmi:id= \"_in3dgZiMEeuzROqeHhotPw\" importingNamespace= \"_in3dgJiMEeuzROqeHhotPw\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_in3dgZiMEeuzROqeHhotPw0\" source= \"genmymodel\" > <details xmi:id= \"_in3dgZiMEeuzROqeHhotPw00\" key= \"uuid\" value= \"_in3dgZiMEeuzROqeHhotPw\" /> </eAnnotations> </xmi:Extension> <importedPackage href= \"http://www.omg.org/spec/UML/20131001/PrimitiveTypes.xmi#/\" /> </packageImport> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_rAoBcHq6EDmVkdImmyh-dQ\" name= \"Project\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_rAoBcHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_rAoBcHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_rAoBcHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_xAOzcHq6EDmVkdImmyh-dQ\" name= \"Task\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_xAOzcHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_xAOzcHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_xAOzcHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_yHEfsXq6EDmVkdImmyh-dQ\" name= \"Project_Task\" memberEnd= \"_yHD4oXq6EDmVkdImmyh-dQ _yHCqgHq6EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_yHCqgHq6EDmVkdImmyh-dQ _yHD4oXq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHEfsXq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHEfsXq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHEfsXq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_yHCqgHq6EDmVkdImmyh-dQ\" name= \"project\" type= \"_rAoBcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_yHEfsXq6EDmVkdImmyh-dQ\" association= \"_yHEfsXq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHCqgHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHCqgHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHCqgHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_yHDRkHq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHDRkHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHDRkHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHDRkHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_yHD4oHq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHD4oHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHD4oHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHD4oHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_yHD4oXq6EDmVkdImmyh-dQ\" name= \"tasks\" type= \"_xAOzcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_yHEfsXq6EDmVkdImmyh-dQ\" association= \"_yHEfsXq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHD4oXq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHD4oXq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHD4oXq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_yHD4onq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_yHD4onq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_yHD4onq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_yHD4onq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_zUmCwHq6EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_zUmCwHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_zUmCwHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_zUmCwHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_86ZfYHq6EDmVkdImmyh-dQ\" name= \"Person\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_86ZfYHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_86ZfYHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_86ZfYHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_-j5z0nq6EDmVkdImmyh-dQ\" name= \"Project_Person\" memberEnd= \"_-j5Mwnq6EDmVkdImmyh-dQ _-j4lsnq6EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_-j4lsnq6EDmVkdImmyh-dQ _-j5Mwnq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5z0nq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5z0nq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5z0nq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_-j4lsnq6EDmVkdImmyh-dQ\" name= \"project\" type= \"_rAoBcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_-j5z0nq6EDmVkdImmyh-dQ\" association= \"_-j5z0nq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j4lsnq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j4lsnq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j4lsnq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_-j5MwHq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5MwHq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5MwHq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5MwHq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_-j5MwXq6EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5MwXq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5MwXq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5MwXq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_-j5Mwnq6EDmVkdImmyh-dQ\" name= \"persons\" type= \"_86ZfYHq6EDmVkdImmyh-dQ\" owningAssociation= \"_-j5z0nq6EDmVkdImmyh-dQ\" association= \"_-j5z0nq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5Mwnq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5Mwnq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5Mwnq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_-j5z0Hq6EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_-j5z0Hq6EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_-j5z0Hq6EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_-j5z0Hq6EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_Ctk-8Hq7EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_Ctk-8Hq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_Ctk-8Hq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_Ctk-8Hq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> <packagedElement xsi:type= \"uml:Class\" xmi:id= \"_FYr6UHq7EDmVkdImmyh-dQ\" name= \"Effort\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_FYr6UHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_FYr6UHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_FYr6UHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_HOgzgXq7EDmVkdImmyh-dQ\" name= \"Effort_Person\" memberEnd= \"_HOgMcHq7EDmVkdImmyh-dQ _HOeXQnq7EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_HOeXQnq7EDmVkdImmyh-dQ _HOgMcHq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgzgXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgzgXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgzgXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_HOeXQnq7EDmVkdImmyh-dQ\" name= \"effort\" type= \"_FYr6UHq7EDmVkdImmyh-dQ\" owningAssociation= \"_HOgzgXq7EDmVkdImmyh-dQ\" association= \"_HOgzgXq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOeXQnq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOeXQnq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOeXQnq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_HOflYHq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOflYHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOflYHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOflYHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_N8H7AHq7EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_N8H7AHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_N8H7AHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_N8H7AHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_HOgMcHq7EDmVkdImmyh-dQ\" name= \"person\" type= \"_86ZfYHq6EDmVkdImmyh-dQ\" owningAssociation= \"_HOgzgXq7EDmVkdImmyh-dQ\" association= \"_HOgzgXq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgMcHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgMcHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgMcHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_HOgMcXq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgMcXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgMcXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgMcXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_HOgzgHq7EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_HOgzgHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_HOgzgHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_HOgzgHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> <packagedElement xsi:type= \"uml:Association\" xmi:id= \"_JLgrt3q7EDmVkdImmyh-dQ\" name= \"Effort_Task\" memberEnd= \"_JLgrtHq7EDmVkdImmyh-dQ _JLgrsXq7EDmVkdImmyh-dQ\" navigableOwnedEnd= \"_JLgrsXq7EDmVkdImmyh-dQ _JLgrtHq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrt3q7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrt3q7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrt3q7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <ownedEnd xmi:id= \"_JLgrsXq7EDmVkdImmyh-dQ\" name= \"effort\" type= \"_FYr6UHq7EDmVkdImmyh-dQ\" owningAssociation= \"_JLgrt3q7EDmVkdImmyh-dQ\" association= \"_JLgrt3q7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrsXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrsXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrsXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_JLgrsnq7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrsnq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrsnq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrsnq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralUnlimitedNatural\" xmi:id= \"_TnCPYHq7EDmVkdImmyh-dQ\" value= \"*\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_TnCPYHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_TnCPYHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_TnCPYHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> <ownedEnd xmi:id= \"_JLgrtHq7EDmVkdImmyh-dQ\" name= \"task\" type= \"_xAOzcHq6EDmVkdImmyh-dQ\" owningAssociation= \"_JLgrt3q7EDmVkdImmyh-dQ\" association= \"_JLgrt3q7EDmVkdImmyh-dQ\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrtHq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrtHq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrtHq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> <lowerValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_JLgrtXq7EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrtXq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrtXq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrtXq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </lowerValue> <upperValue xsi:type= \"uml:LiteralInteger\" xmi:id= \"_JLgrtnq7EDmVkdImmyh-dQ\" value= \"1\" > <xmi:Extension extender= \"http://www.eclipse.org/emf/2002/Ecore\" > <eAnnotations xmi:id= \"_JLgrtnq7EDmVkdImmyh-dQ0\" source= \"genmymodel\" > <details xmi:id= \"_JLgrtnq7EDmVkdImmyh-dQ00\" key= \"uuid\" value= \"_JLgrtnq7EDmVkdImmyh-dQ\" /> </eAnnotations> </xmi:Extension> </upperValue> </ownedEnd> </packagedElement> </uml:Model> </xmi:XMI>","title":"UML"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#genmymodel","text":"GenMyModel is a web-based modelling tool that can be used to create UML2-compliant models. You can consume the XMI representation of a public GenMyModel UML model directly from Epsilon as shown below. build.gradle configurations { epsilon } repositories { maven { url \"https://repo.eclipse.org/content/repositories/acceleo-releases/\" } maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } mavenCentral () } dependencies { epsilon ( 'org.eclipse.epsilon:org.eclipse.epsilon.emc.uml:2.4.0' ) { // UML2 is broken on Maven Central exclude group: 'org.eclipse.uml2' } epsilon 'org.eclipse.epsilon:org.eclipse.epsilon.workflow:2.4.0' // Fetch the UML2 dependencies from repo.eclipse.org instead epsilon 'org.eclipse.uml2:org.eclipse.uml2.uml:5.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.common:2.0.1.v20140910-1354' epsilon 'org.eclipse.uml2:org.eclipse.uml2.types:2.0.0.v20140910-1354' } task setupEpsilonTasks { // Set up the core Epsilon tasks ant . taskdef ( resource: 'org/eclipse/epsilon/workflow/tasks/tasks.xml' , classpath: configurations . epsilon . asPath , loaderref: 'epsilon' ) // Set logging level to info so that EOL's println() is not suppressed ant . lifecycleLogLevel = 'INFO' } task run { dependsOn tasks . setupEpsilonTasks // Load a UML model straight from GenMyModel ant . 'epsilon.loadModel' ( name: 'UML' , impl: 'org.eclipse.epsilon.emc.uml.UmlModel' ){ parameter ( name: 'modelUri' , value: 'https://app.genmymodel.com/api/projects/_in3dgJiMEeuzROqeHhotPw/custom-xmi' ) } // Run library.eol against it ant . 'epsilon.eol' ( src: '../uml.eol' ){ model ( ref: 'UML' ) } }","title":"GenMyModel"},{"location":"doc/articles/running-epsilon-ant-tasks-from-command-line/#epsilon-1x","text":"If you would like to use an older (1.x) version of Epsilon, you can use this example instead , which uses a fat jar we used to produce ( epsilon-1.x-kitchensink.jar ) before moving all our jars to Maven Central/Sonatype.","title":"Epsilon 1.x"},{"location":"doc/articles/running-from-source/","text":"Running Epsilon from Source \u00b6 To run Epsilon from source, you need to: Download a copy of the latest version of Eclipse and select the \"Eclipse IDE for Eclipse Committers\" option when prompted during the installation process. Clone the Git repository from https://github.com/eclipse/epsilon Import all the projects under the plugins , features , and tests folders in your workspace. (optional) To organise your workspace, you can create working sets . For example, you could create three working sets that mirror the contents of the folders above ( plugins , features , and tests ). Open releng/org.eclipse.epsilon.target/org.eclipse.epsilon.target.target and click the \"Set as Active Target Platform\" link on the top right Right-click on any Epsilon plugin project in the Project Explorer and select Run as \u2192 Eclipse Application Naming Conventions \u00b6 The execution engines for the various Epsilon languages are located in org.eclipse.epsilon.*.engine plugins. These are Eclipse-independent. Plugins named *.dt contain development tools (e.g. editors, run configurations, debuggers) for the respective Epsilon languages. Plugins named org.eclipse.epsilon.emc.* contain Epsilon Model Connectivity (EMC) drivers through which Epsilon languages can interact with different types of models (e.g. EMF models, spreadsheets etc.) Plugins named org.eclipse.epsilon.emc.*.dt contain development tools (e.g. model configuration dialogs) for the respective EMC drivers. Plugins named *.workflow contribute ANT tasks . Modifying the Epsilon parsers \u00b6 Before you can regenerate the Epsilon parsers, you need to clone the epsilon-antlr-dev Git repo into a sibling folder of the Epsilon repo. To modify e.g. the EVL parser, you need to change Evl.g and/or EvlParserRules.g . To re-generate the parser you need to run build-evl-parser.xml as an Ant build. Since all Epsilon languages extend EOL, if you modify the EOL parser, you'll then need to run build-all-eol-dependent-parsers.xml Running the Epsilon tests \u00b6 After making any changes to the Epsilon source code, you're advised to run the Epsilon test suites to avoid regressions. Epsilon provides two main test suites: EpsilonTestSuite and EpsilonPluggedInTestSuite (the latter needs to be run as a JUnit Plug-In Test )","title":"Running Epsilon from Source"},{"location":"doc/articles/running-from-source/#running-epsilon-from-source","text":"To run Epsilon from source, you need to: Download a copy of the latest version of Eclipse and select the \"Eclipse IDE for Eclipse Committers\" option when prompted during the installation process. Clone the Git repository from https://github.com/eclipse/epsilon Import all the projects under the plugins , features , and tests folders in your workspace. (optional) To organise your workspace, you can create working sets . For example, you could create three working sets that mirror the contents of the folders above ( plugins , features , and tests ). Open releng/org.eclipse.epsilon.target/org.eclipse.epsilon.target.target and click the \"Set as Active Target Platform\" link on the top right Right-click on any Epsilon plugin project in the Project Explorer and select Run as \u2192 Eclipse Application","title":"Running Epsilon from Source"},{"location":"doc/articles/running-from-source/#naming-conventions","text":"The execution engines for the various Epsilon languages are located in org.eclipse.epsilon.*.engine plugins. These are Eclipse-independent. Plugins named *.dt contain development tools (e.g. editors, run configurations, debuggers) for the respective Epsilon languages. Plugins named org.eclipse.epsilon.emc.* contain Epsilon Model Connectivity (EMC) drivers through which Epsilon languages can interact with different types of models (e.g. EMF models, spreadsheets etc.) Plugins named org.eclipse.epsilon.emc.*.dt contain development tools (e.g. model configuration dialogs) for the respective EMC drivers. Plugins named *.workflow contribute ANT tasks .","title":"Naming Conventions"},{"location":"doc/articles/running-from-source/#modifying-the-epsilon-parsers","text":"Before you can regenerate the Epsilon parsers, you need to clone the epsilon-antlr-dev Git repo into a sibling folder of the Epsilon repo. To modify e.g. the EVL parser, you need to change Evl.g and/or EvlParserRules.g . To re-generate the parser you need to run build-evl-parser.xml as an Ant build. Since all Epsilon languages extend EOL, if you modify the EOL parser, you'll then need to run build-all-eol-dependent-parsers.xml","title":"Modifying the Epsilon parsers"},{"location":"doc/articles/running-from-source/#running-the-epsilon-tests","text":"After making any changes to the Epsilon source code, you're advised to run the Epsilon test suites to avoid regressions. Epsilon provides two main test suites: EpsilonTestSuite and EpsilonPluggedInTestSuite (the latter needs to be run as a JUnit Plug-In Test )","title":"Running the Epsilon tests"},{"location":"doc/articles/simulink/","text":"Scripting Simulink models using Epsilon \u00b6 In this article we demonstrate how you can create, query and modify Simulink models in Epsilon programs. While the example in this article demonstrates using EOL to script Simulink models, it's worth stressing that Simulink models are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - Simulink or EMF-based -, or to text), compare and merge your Simulink models. Warning The Simulink driver only works with Java 8 for versions of MATLAB before 2021a. This is due to a limitation of the official MATLAB Java API . Installation \u00b6 The first time you run Eclipse after installing the Simulink driver you will need to point it to the location of your Matlab installation through the Eclipse Preferences\u2192Epsilon\u2192Simulink dialog. In particular, you need to specify the location of the <matlab-root>/bin/win64 (or /bin/maci64 if you are on Mac OS) directory and Matlab's engine.jar as shown below. Note that in most cases, if you installed MATLAB in the default location for your operating system, the paths should be automatically detected, and if not you should usually only need to set the MATLAB root directory in your preferences. Troubleshooting / Notes \u00b6 The driver has been developed and tested with Matlab_R2017a and may not work with older versions of Matlab ( engine.jar was introduced fairly recently). If you start getting strange errors about dynamic libraries, chances are that the Matlab paths above are wrong. If restarting Eclipse and correcting the paths doesn't solve this, please post a message to the forum. If you are on Windows, ensure that <matlab-root>/bin/win64 is in the system path (in Windows' Environment Variables). In some cases, you may need to use the same Java runtime (JRE) as your MATLAB installation. For example in Windows, the path to MATLAB's Java is <matlab-root>/sys/java/jre/win64/jre . To configure an alternative JRE, please set the MATLAB_JAVA environment variable to point to a compatible JRE, and ensure that both your Eclipse and MATLAB are using the same JRE version. If you are having trouble configuring the MATLAB paths from the UI (or no alternative configuration method is available), you can set the \"org.eclipse.epsilon.emc.matlab_path\" environment variable to point to your MATLAB installation. Quick start \u00b6 Create a new General project Create an empty Simulink model in the project (e.g. empty.slx ) Create a new EOL file (e.g. demo.eol ) and add the content below to it: // Create elements var sineWave = new `simulink/Sources/Sine Wave`; var gain = new `simulink/Math Operations/Gain`; var saturation = new `simulink/Discontinuities/Saturation`; var busCreator = new `simulink/Signal Routing/Bus Creator`; var scope = new `simulink/Sinks/Scope`; // Position them on the diagram sineWave.position = \"[100 100 130 130]\"; gain.position = \"[200 100 230 130]\"; saturation.position = \"[300 100 330 130]\"; busCreator.position = \"[400 70 410 300]\"; scope.position = \"[500 175 530 205]\"; // Set their properties gain.gain = 2; busCreator.inputs = 3; // Link them sineWave.link(gain); gain.link(saturation); saturation.link(busCreator); gain.linkTo(busCreator, 2); sineWave.linkTo(busCreator, 3); busCreator.link(scope); Create a new Run configuration for your EOL program and add a Simulink model to it, pointing at your .slx (e.g. empty.slx ) model Launch the Run configuration. Simulink should pop up and you should see the model below (which you can edit/run as normal)","title":"Scripting Simulink models using Epsilon"},{"location":"doc/articles/simulink/#scripting-simulink-models-using-epsilon","text":"In this article we demonstrate how you can create, query and modify Simulink models in Epsilon programs. While the example in this article demonstrates using EOL to script Simulink models, it's worth stressing that Simulink models are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models - Simulink or EMF-based -, or to text), compare and merge your Simulink models. Warning The Simulink driver only works with Java 8 for versions of MATLAB before 2021a. This is due to a limitation of the official MATLAB Java API .","title":"Scripting Simulink models using Epsilon"},{"location":"doc/articles/simulink/#installation","text":"The first time you run Eclipse after installing the Simulink driver you will need to point it to the location of your Matlab installation through the Eclipse Preferences\u2192Epsilon\u2192Simulink dialog. In particular, you need to specify the location of the <matlab-root>/bin/win64 (or /bin/maci64 if you are on Mac OS) directory and Matlab's engine.jar as shown below. Note that in most cases, if you installed MATLAB in the default location for your operating system, the paths should be automatically detected, and if not you should usually only need to set the MATLAB root directory in your preferences.","title":"Installation"},{"location":"doc/articles/simulink/#troubleshooting-notes","text":"The driver has been developed and tested with Matlab_R2017a and may not work with older versions of Matlab ( engine.jar was introduced fairly recently). If you start getting strange errors about dynamic libraries, chances are that the Matlab paths above are wrong. If restarting Eclipse and correcting the paths doesn't solve this, please post a message to the forum. If you are on Windows, ensure that <matlab-root>/bin/win64 is in the system path (in Windows' Environment Variables). In some cases, you may need to use the same Java runtime (JRE) as your MATLAB installation. For example in Windows, the path to MATLAB's Java is <matlab-root>/sys/java/jre/win64/jre . To configure an alternative JRE, please set the MATLAB_JAVA environment variable to point to a compatible JRE, and ensure that both your Eclipse and MATLAB are using the same JRE version. If you are having trouble configuring the MATLAB paths from the UI (or no alternative configuration method is available), you can set the \"org.eclipse.epsilon.emc.matlab_path\" environment variable to point to your MATLAB installation.","title":"Troubleshooting / Notes"},{"location":"doc/articles/simulink/#quick-start","text":"Create a new General project Create an empty Simulink model in the project (e.g. empty.slx ) Create a new EOL file (e.g. demo.eol ) and add the content below to it: // Create elements var sineWave = new `simulink/Sources/Sine Wave`; var gain = new `simulink/Math Operations/Gain`; var saturation = new `simulink/Discontinuities/Saturation`; var busCreator = new `simulink/Signal Routing/Bus Creator`; var scope = new `simulink/Sinks/Scope`; // Position them on the diagram sineWave.position = \"[100 100 130 130]\"; gain.position = \"[200 100 230 130]\"; saturation.position = \"[300 100 330 130]\"; busCreator.position = \"[400 70 410 300]\"; scope.position = \"[500 175 530 205]\"; // Set their properties gain.gain = 2; busCreator.inputs = 3; // Link them sineWave.link(gain); gain.link(saturation); saturation.link(busCreator); gain.linkTo(busCreator, 2); sineWave.linkTo(busCreator, 3); busCreator.link(scope); Create a new Run configuration for your EOL program and add a Simulink model to it, pointing at your .slx (e.g. empty.slx ) model Launch the Run configuration. Simulink should pop up and you should see the model below (which you can edit/run as normal)","title":"Quick start"},{"location":"doc/articles/simulink-stateflow/","text":"Managing Matlab Simulink/Stateflow models from Epsilon \u00b6 Epsilon supports Matlab Simulink models. This tutorial shows you how to manipulate Simulink and Stateflow blocks from within Epsilon. Warning The Simulink driver only works with Java 8 for versions of MATLAB before 2021a. This is due to a limitation of the official MATLAB Java API . Support for Java 11 with MATLAB >= 2021a was added in Epsilon 2.5. [Pre-requisite] Setting up your Eclipse Installation \u00b6 Help > Install New Software... In your eclipse installation make sure to go to Help > Install New Software... and in the pop up window add the Epsilon's Update Site and select the \"Epsilon Simulink Integration\" and proceed with the installation. Make sure that you have \"Epsilon Core\", \"Epsilon Core Developement Tools\" and their dependencies already Installed. Click here for more details. Once installed, make sure to add to the Eclipse Preferences (Eclipse > Preferences...) the path of the Simulink library directory and the Matlab Engine Jar. You will find them in the Preference dialog under the tabs Epsilon > Simulink. For MATLAB version R2017a, the OSX paths for both are those in the figure below, whereas for Windows machines, the paths are as follow: C:/Program Files/MATLAB/R2017b/bin/win64 C:/Program Files/MATLAB/R2017b/extern/engines/java/jar/engine.jar Loading/Creating a Simulink File as a model \u00b6 Depending on what epsilon language you would like to run (EOL, EGL, ETL, EVL, etc.) you will have to create the corresponding \"Run Configuration\" (EOL Program, EGL Generator, ETL Transformation, EVL validation, etc.) Different types of Run Configurations Once you create an epsilon-based run configuration, in the \"Models\" tab you should be able to add a Simulink Model. In the model configuration window you may choose: Simulink File: The simulink file to read from or to store after the execution. Hide Editor: Do not open the Matlab Simulink editor if it is closed. Either option won't close the editor if it is opened. Read on Load: read the contents of the file before the execution. Store on Disposal: close without saving the changes to the file after the execution Model configuration window Creating blocks \u00b6 Icon of the Simulink \"Library Browser\" The Step Block is found under Simulink/Sources/Step and therefore created as new simulink/Sources/Step ; To create Simulink Blocks you may instantiate them using the following syntax. The full path of the block matches their location in the Simulink \"Library Browser\". The EOL syntax to create this blocks is as follows: var step = new `simulink/Sources/Step`; var sum = new `simulink/Math Operations/Sum`; var chart = new `sflib/Chart`; In contrast to Simulink Blocks, Stateflow Blocks don't require the full library path but have to be instantiated with the Stateflow prefix (e.g. Stateflow.${Block_Type} ). These blocks also need to have a parent and there are three options to do this with the Epsilon driver. // Pass the parent as an argument of the constructor new `Stateflow.State`(parent); // Add the child to the parent var state= new `Stateflow.State`; parent.add(state); // Set the parent as an object attribute var state= new `Stateflow.State`; state.parent = parent; Child Blocks \u00b6 You can also retrieve the child blocks of a given Simulink or Stateflow block using either syntax for both kinds of blocks: state.getChildren(); chart.children; Note that Stateflow Blocks will return Stateflow Blocks as children and Simulink Blocks will return their Simulink children Blocks. Querying for existing blocks \u00b6 If your Simulink file had preexisting blocks or if you just created some with your EOL script, then you may query for all the blocks of a given type. For Simulink Blocks you may do this without having to specify their full path. // var sum = new `simulink/Math Operations/Sum`; // Full path var sumBlockList = Sum.all; // Type only For Stateflow Blocks you must specify the fully qualified type i.e. the same used for creation: // var state= new `Stateflow.State`; // Fully qualified type var stateBlockList = `Stateflow.State`.all; Be aware that some Simulink Blocks have different \"BlockTypes\" than the path used for their construction. var pidController = new `simulink/Continuous/PID Controller`; var subsystemBlockList = SubSystem.all; // Includes PID Controller // PIDController.all or `PID Controller`.all would return an error var transferFcn = new `simulink/Continuous/Transfer Fcn`; var transferFcnBlockList = TransferFcn.all; // Removed the space You may find the real Simulink Block type of the element by retrieving the \"BlockType\" property of the Simulink Block. var pidController = new `simulink/Continuous/PID Controller`; pidController.BlockType.println; // prints \"SubSystem\" Note that Simulink and Stateflow Block types are case sensitive for instantiation and collection. Reading and Updating the block properties \u00b6 You may read and update properties of Simulink and Stateflow blocks as follows: state.Name = \"State A\"; // Set state.name.println; // Get You may also set and get positioning attributes. state.Position = \"[50 50 310 200]\"; // Set (receives a string type) var seq = state.position; // Get position (returns a sequence type) assert(seq.at(0) = 50); // element 0 of state block position Note that properties are case insensitive. Deleting blocks \u00b6 You can also delete blocks using the following syntax: delete state; // `Stateflow.State` delete chart; // `sflib/Chart` Summary \u00b6 In this tutorial we've seen how to create, read, update, and delete Simulink and Stateflow block types in epsilon and also how to set up your eclipse installation to be able to run epsilon-based scripts on Simulink files loaded as models. For further information on how to perform more complex operations with epsilon have a look at Epsilon's website or Epsilon's book. For more examples with the Simulink/Stateflow Epsilon Driver have a look at this folder in the official epsilon repository.","title":"Managing Matlab Simulink/Stateflow models from Epsilon"},{"location":"doc/articles/simulink-stateflow/#managing-matlab-simulinkstateflow-models-from-epsilon","text":"Epsilon supports Matlab Simulink models. This tutorial shows you how to manipulate Simulink and Stateflow blocks from within Epsilon. Warning The Simulink driver only works with Java 8 for versions of MATLAB before 2021a. This is due to a limitation of the official MATLAB Java API . Support for Java 11 with MATLAB >= 2021a was added in Epsilon 2.5.","title":"Managing Matlab Simulink/Stateflow models from Epsilon"},{"location":"doc/articles/simulink-stateflow/#pre-requisite-setting-up-your-eclipse-installation","text":"Help > Install New Software... In your eclipse installation make sure to go to Help > Install New Software... and in the pop up window add the Epsilon's Update Site and select the \"Epsilon Simulink Integration\" and proceed with the installation. Make sure that you have \"Epsilon Core\", \"Epsilon Core Developement Tools\" and their dependencies already Installed. Click here for more details. Once installed, make sure to add to the Eclipse Preferences (Eclipse > Preferences...) the path of the Simulink library directory and the Matlab Engine Jar. You will find them in the Preference dialog under the tabs Epsilon > Simulink. For MATLAB version R2017a, the OSX paths for both are those in the figure below, whereas for Windows machines, the paths are as follow: C:/Program Files/MATLAB/R2017b/bin/win64 C:/Program Files/MATLAB/R2017b/extern/engines/java/jar/engine.jar","title":"[Pre-requisite] Setting up your Eclipse Installation"},{"location":"doc/articles/simulink-stateflow/#loadingcreating-a-simulink-file-as-a-model","text":"Depending on what epsilon language you would like to run (EOL, EGL, ETL, EVL, etc.) you will have to create the corresponding \"Run Configuration\" (EOL Program, EGL Generator, ETL Transformation, EVL validation, etc.) Different types of Run Configurations Once you create an epsilon-based run configuration, in the \"Models\" tab you should be able to add a Simulink Model. In the model configuration window you may choose: Simulink File: The simulink file to read from or to store after the execution. Hide Editor: Do not open the Matlab Simulink editor if it is closed. Either option won't close the editor if it is opened. Read on Load: read the contents of the file before the execution. Store on Disposal: close without saving the changes to the file after the execution Model configuration window","title":"Loading/Creating a Simulink File as a model"},{"location":"doc/articles/simulink-stateflow/#creating-blocks","text":"Icon of the Simulink \"Library Browser\" The Step Block is found under Simulink/Sources/Step and therefore created as new simulink/Sources/Step ; To create Simulink Blocks you may instantiate them using the following syntax. The full path of the block matches their location in the Simulink \"Library Browser\". The EOL syntax to create this blocks is as follows: var step = new `simulink/Sources/Step`; var sum = new `simulink/Math Operations/Sum`; var chart = new `sflib/Chart`; In contrast to Simulink Blocks, Stateflow Blocks don't require the full library path but have to be instantiated with the Stateflow prefix (e.g. Stateflow.${Block_Type} ). These blocks also need to have a parent and there are three options to do this with the Epsilon driver. // Pass the parent as an argument of the constructor new `Stateflow.State`(parent); // Add the child to the parent var state= new `Stateflow.State`; parent.add(state); // Set the parent as an object attribute var state= new `Stateflow.State`; state.parent = parent;","title":"Creating blocks"},{"location":"doc/articles/simulink-stateflow/#child-blocks","text":"You can also retrieve the child blocks of a given Simulink or Stateflow block using either syntax for both kinds of blocks: state.getChildren(); chart.children; Note that Stateflow Blocks will return Stateflow Blocks as children and Simulink Blocks will return their Simulink children Blocks.","title":"Child Blocks"},{"location":"doc/articles/simulink-stateflow/#querying-for-existing-blocks","text":"If your Simulink file had preexisting blocks or if you just created some with your EOL script, then you may query for all the blocks of a given type. For Simulink Blocks you may do this without having to specify their full path. // var sum = new `simulink/Math Operations/Sum`; // Full path var sumBlockList = Sum.all; // Type only For Stateflow Blocks you must specify the fully qualified type i.e. the same used for creation: // var state= new `Stateflow.State`; // Fully qualified type var stateBlockList = `Stateflow.State`.all; Be aware that some Simulink Blocks have different \"BlockTypes\" than the path used for their construction. var pidController = new `simulink/Continuous/PID Controller`; var subsystemBlockList = SubSystem.all; // Includes PID Controller // PIDController.all or `PID Controller`.all would return an error var transferFcn = new `simulink/Continuous/Transfer Fcn`; var transferFcnBlockList = TransferFcn.all; // Removed the space You may find the real Simulink Block type of the element by retrieving the \"BlockType\" property of the Simulink Block. var pidController = new `simulink/Continuous/PID Controller`; pidController.BlockType.println; // prints \"SubSystem\" Note that Simulink and Stateflow Block types are case sensitive for instantiation and collection.","title":"Querying for existing blocks"},{"location":"doc/articles/simulink-stateflow/#reading-and-updating-the-block-properties","text":"You may read and update properties of Simulink and Stateflow blocks as follows: state.Name = \"State A\"; // Set state.name.println; // Get You may also set and get positioning attributes. state.Position = \"[50 50 310 200]\"; // Set (receives a string type) var seq = state.position; // Get position (returns a sequence type) assert(seq.at(0) = 50); // element 0 of state block position Note that properties are case insensitive.","title":"Reading and Updating the block properties"},{"location":"doc/articles/simulink-stateflow/#deleting-blocks","text":"You can also delete blocks using the following syntax: delete state; // `Stateflow.State` delete chart; // `sflib/Chart`","title":"Deleting blocks"},{"location":"doc/articles/simulink-stateflow/#summary","text":"In this tutorial we've seen how to create, read, update, and delete Simulink and Stateflow block types in epsilon and also how to set up your eclipse installation to be able to run epsilon-based scripts on Simulink files loaded as models. For further information on how to perform more complex operations with epsilon have a look at Epsilon's website or Epsilon's book. For more examples with the Simulink/Stateflow Epsilon Driver have a look at this folder in the official epsilon repository.","title":"Summary"},{"location":"doc/articles/target-platform/","text":"Managing the target platform \u00b6 Epsilon stable and interim releases are built using Eclipse Tycho , which repurposes Apache Maven for automating the build of Eclipse plugins, features and update sites. Maven builds are launched automatically by the Epsilon Jenkins instance whenever a change in the main branch of the Epsilon Git repository is detected. Tycho requires defining a \"target platform\" with the Eclipse plugins and features that Epsilon should be compiled against. In the case of Epsilon, this target platform will usually include EMF, GMF, the Eclipse IDE and PDE, Emfatic, and then any other third-party components that might be useful (e.g. Sirius or Papyrus). The target platform is stored in the plugins/org.eclipse.epsilon.targetplatform.target project. The target platform is an XML file that lists features or plugins from one or more update sites. It can be edited by hand, but it is rather unwieldy, so it is better to open it from Eclipse. A working Internet connection is needed to edit these files. Once you open the file, Eclipse will spend some time downloading features and plugins from the update sites and resolving dependencies. After it is done, you should see something like this: In the picture, we can see three update sites (main Luna release, Luna updates and Emfatic), with some features pulled from them. In general, it is better to define target platforms at the feature level rather than at the plugin level, as they tend to be more stable across releases: it's better to pull in a few extra plugins than have the whole thing break because of a single missing plugin. One important restriction is that even though Eclipse allows for adding local folders as part of the target platform, these are rejected by Tycho. Tycho only supports URL-based update sites in target platform definitions: should you need a custom plugin for building Eclipse, it will have to be placed in an update site and hosted somewhere. If it is part of a well-known open source project, it may make sense to see if one of the Orbit update sites already has it: additionally, those bundles have already gone through the legal processes set by the Eclipse Foundation. To check if the target platform has everything we need, we should follow these steps: Import the rest of the Epsilon source code into our workspace. Go to the target platform editor after resolution is done and click on \"Set Target Platform\". Wait for everything to be rebuilt, and check there are no compilation errors due to missing dependencies. Should we miss some dependencies, we can either \"Edit...\" one of the locations to include more things from it, or we can \"Add...\" a location with new things. It is OK to add the same location multiple times. Keep in mind that recent versions of Eclipse have an issue with the \"Edit...\" button where you will need to wait a few seconds until Eclipse ticks again all the things we previously had from that location - if you don't wait, you will lose the features that were previously selected! After any changes are made to the target platform definition and saved, Eclipse will take a bit to resolve again everything. It's a good idea to make changes in small increments, in case there is a resolution problem and the definition has to be rolled back. Even if everything compiles, it's a good idea to double check in the \"Content\" tab if the specific plugins and versions we wanted are in there. Sometimes, it may not be obvious which features contribute which plugin. Once the target platform has been set through \"Set Target Platform\", it may also make sense to use the \"Target Platform State\" view to find plugins that are missing dependencies. The target platform resolves if we have all the things we asked for, but it does not check that the plugins we are fetching have all their dependencies sorted out. This view allows you to search through the contents of the current target platform, and to check how dependencies have been resolved between the plugins. There is a drop down menu with an option for only showing unresolved plugins: a good target platform should never have any listed in there, unless they happen to be platform-specific. For instance, it makes sense if a Mac-specific plugin (e.g. a Mac binary for launching Eclipse) does not resolve in a developer's Linux machine. Once the target platform has been revised and we have double-checked that everything compiles fine and that there are no unresolved plugins in the \"Target Platform State\" view, we should do one last check before pushing the changes to Git: making sure the Tycho build still works. To do so, we should go to the main folder of the Epsilon Git repository and run this command, assuming we have a recent version of Maven 3 installed and available from our PATH : mvn clean install If this command succeeds, it is ready to be pushed. Push the changes, wait until the build succeeds in the Epsilon Jenkins instance (Jenkins checks every 5 minutes or so for changes), and then you're done!","title":"Managing the target platform"},{"location":"doc/articles/target-platform/#managing-the-target-platform","text":"Epsilon stable and interim releases are built using Eclipse Tycho , which repurposes Apache Maven for automating the build of Eclipse plugins, features and update sites. Maven builds are launched automatically by the Epsilon Jenkins instance whenever a change in the main branch of the Epsilon Git repository is detected. Tycho requires defining a \"target platform\" with the Eclipse plugins and features that Epsilon should be compiled against. In the case of Epsilon, this target platform will usually include EMF, GMF, the Eclipse IDE and PDE, Emfatic, and then any other third-party components that might be useful (e.g. Sirius or Papyrus). The target platform is stored in the plugins/org.eclipse.epsilon.targetplatform.target project. The target platform is an XML file that lists features or plugins from one or more update sites. It can be edited by hand, but it is rather unwieldy, so it is better to open it from Eclipse. A working Internet connection is needed to edit these files. Once you open the file, Eclipse will spend some time downloading features and plugins from the update sites and resolving dependencies. After it is done, you should see something like this: In the picture, we can see three update sites (main Luna release, Luna updates and Emfatic), with some features pulled from them. In general, it is better to define target platforms at the feature level rather than at the plugin level, as they tend to be more stable across releases: it's better to pull in a few extra plugins than have the whole thing break because of a single missing plugin. One important restriction is that even though Eclipse allows for adding local folders as part of the target platform, these are rejected by Tycho. Tycho only supports URL-based update sites in target platform definitions: should you need a custom plugin for building Eclipse, it will have to be placed in an update site and hosted somewhere. If it is part of a well-known open source project, it may make sense to see if one of the Orbit update sites already has it: additionally, those bundles have already gone through the legal processes set by the Eclipse Foundation. To check if the target platform has everything we need, we should follow these steps: Import the rest of the Epsilon source code into our workspace. Go to the target platform editor after resolution is done and click on \"Set Target Platform\". Wait for everything to be rebuilt, and check there are no compilation errors due to missing dependencies. Should we miss some dependencies, we can either \"Edit...\" one of the locations to include more things from it, or we can \"Add...\" a location with new things. It is OK to add the same location multiple times. Keep in mind that recent versions of Eclipse have an issue with the \"Edit...\" button where you will need to wait a few seconds until Eclipse ticks again all the things we previously had from that location - if you don't wait, you will lose the features that were previously selected! After any changes are made to the target platform definition and saved, Eclipse will take a bit to resolve again everything. It's a good idea to make changes in small increments, in case there is a resolution problem and the definition has to be rolled back. Even if everything compiles, it's a good idea to double check in the \"Content\" tab if the specific plugins and versions we wanted are in there. Sometimes, it may not be obvious which features contribute which plugin. Once the target platform has been set through \"Set Target Platform\", it may also make sense to use the \"Target Platform State\" view to find plugins that are missing dependencies. The target platform resolves if we have all the things we asked for, but it does not check that the plugins we are fetching have all their dependencies sorted out. This view allows you to search through the contents of the current target platform, and to check how dependencies have been resolved between the plugins. There is a drop down menu with an option for only showing unresolved plugins: a good target platform should never have any listed in there, unless they happen to be platform-specific. For instance, it makes sense if a Mac-specific plugin (e.g. a Mac binary for launching Eclipse) does not resolve in a developer's Linux machine. Once the target platform has been revised and we have double-checked that everything compiles fine and that there are no unresolved plugins in the \"Target Platform State\" view, we should do one last check before pushing the changes to Git: making sure the Tycho build still works. To do so, we should go to the main folder of the Epsilon Git repository and run this command, assuming we have a recent version of Maven 3 installed and available from our PATH : mvn clean install If this command succeeds, it is ready to be pushed. Push the changes, wait until the build succeeds in the Epsilon Jenkins instance (Jenkins checks every 5 minutes or so for changes), and then you're done!","title":"Managing the target platform"},{"location":"doc/articles/troubleshooting/","text":"Troubleshooting \u00b6 Below are some common issues that (particularly new) users of Epsilon tend to run into. Line: 1, Reason: missing EOF at \u2018<' \u00b6 If you get this error message while you are trying to run your Epsilon program, chances are that in the Source tab of your run configuration, you have selected a model instead of the Epsilon program you are trying to run. Where is the \"Run\" button? \u00b6 If you cannot find the run button in the toolbar of your Eclipse, you need to activate the Epsilon perspective from the Window \u2192 Perspective \u2192 Open Perspective \u2192 Other menu or from the respective shortcut at the top-right corner of your Eclipse window. I see no files when I browse for a program/model file \u00b6 In the dialog that pops up after you have clicked the Browse button, please start typing the name of the file you are looking for (or * to see all files) in the search box on the top, and files should start appearing under the Matched items part of the dialog. Syntax highlighting doesn't work in the Epsilon/Emfatic editors \u00b6 Chances are that you don't have Epsilon installed in your Eclipse instance. To download Epsilon please follow these instructions .","title":"Troubleshooting"},{"location":"doc/articles/troubleshooting/#troubleshooting","text":"Below are some common issues that (particularly new) users of Epsilon tend to run into.","title":"Troubleshooting"},{"location":"doc/articles/troubleshooting/#line-1-reason-missing-eof-at","text":"If you get this error message while you are trying to run your Epsilon program, chances are that in the Source tab of your run configuration, you have selected a model instead of the Epsilon program you are trying to run.","title":"Line: 1, Reason: missing EOF at \u2018&lt;'"},{"location":"doc/articles/troubleshooting/#where-is-the-run-button","text":"If you cannot find the run button in the toolbar of your Eclipse, you need to activate the Epsilon perspective from the Window \u2192 Perspective \u2192 Open Perspective \u2192 Other menu or from the respective shortcut at the top-right corner of your Eclipse window.","title":"Where is the \"Run\" button?"},{"location":"doc/articles/troubleshooting/#i-see-no-files-when-i-browse-for-a-programmodel-file","text":"In the dialog that pops up after you have clicked the Browse button, please start typing the name of the file you are looking for (or * to see all files) in the search box on the top, and files should start appearing under the Matched items part of the dialog.","title":"I see no files when I browse for a program/model file"},{"location":"doc/articles/troubleshooting/#syntax-highlighting-doesnt-work-in-the-epsilonemfatic-editors","text":"Chances are that you don't have Epsilon installed in your Eclipse instance. To download Epsilon please follow these instructions .","title":"Syntax highlighting doesn't work in the Epsilon/Emfatic editors"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/","text":"Visualising Models with Picto and Sirius \u00b6 Graphical modelling frameworks such as Sirius allow for models to be visualised and edited as diagrams, tables and trees. Sometimes it may be beneficial to visualise parts of the model in a different format, such as graphs. By combining both Sirius and Picto , you can combine the benefits of graphical editing, with the flexibility of rendering views using HTML/SVG/JavaScript-based technologies. Example \u00b6 In this example, we will use the Sirius basicfamily example and render charts using ChartJS . Import the following projects using File\u2192New\u2192Other\u2192Examples\u2192Sirius Examples: Basic Family Metamodel Definition (If you cannot see the Sirius Examples, you will need to install the samples feature from here ) Import the org.eclipse.epsilon.examples.picto.sirius plug-in project from the Epsilon repository . Launch a new runtime instance of Eclipse. In the new runtime instance, import the following projects using File\u2192New\u2192Other\u2192Examples\u2192Sirius Examples: Advanced Tutorial Solution Basic Family Sample Model projects Open the Picto view (Window\u2192Show View\u2192Other\u2192Picto) In the basicfamily.sample project, create a new Persons diagram on the Family element. E.g. open the representations.aird file and do the following: and click Finish. When opened you should see charts showing the number of males and females in the family Now create a new Relationships diagram on Elias You should now see charts showing the number of male and female children of Elias Modifying the Example \u00b6 The org.eclipse.epsilon.examples.picto.sirius plug-in uses the pictoSource extension point and the BasicFamilyPictoSource class to allow Picto to obtain model elements and auto-refresh on save of the Sirius editor. This uses part of the Sirius API to get the root element of the diagram. protected EObject getRootOfDiagram ( IEditorPart editorPart ) { if ( isSiriusEditor ( editorPart )) { DDiagramEditor editor = ( DDiagramEditor ) editorPart ; DSemanticDiagramImpl diagram = ( DSemanticDiagramImpl ) editor . getRepresentation (); return diagram . getTarget (); } return null ; } protected boolean isSiriusEditor ( IEditorPart editorPart ) { return editorPart instanceof DDiagramEditor ; } The basicfamily.egx file (located in the resources directory of the org.eclipse.epsilon.examples.picto.sirius plug-in) coordinates the generation of the Picto views. The model2bar.egl and model2pie.egl files generate the respective bar and pie chart views using the ChartJS framework.","title":"Visualising Models with Picto and Sirius"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/#visualising-models-with-picto-and-sirius","text":"Graphical modelling frameworks such as Sirius allow for models to be visualised and edited as diagrams, tables and trees. Sometimes it may be beneficial to visualise parts of the model in a different format, such as graphs. By combining both Sirius and Picto , you can combine the benefits of graphical editing, with the flexibility of rendering views using HTML/SVG/JavaScript-based technologies.","title":"Visualising Models with Picto and Sirius"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/#example","text":"In this example, we will use the Sirius basicfamily example and render charts using ChartJS . Import the following projects using File\u2192New\u2192Other\u2192Examples\u2192Sirius Examples: Basic Family Metamodel Definition (If you cannot see the Sirius Examples, you will need to install the samples feature from here ) Import the org.eclipse.epsilon.examples.picto.sirius plug-in project from the Epsilon repository . Launch a new runtime instance of Eclipse. In the new runtime instance, import the following projects using File\u2192New\u2192Other\u2192Examples\u2192Sirius Examples: Advanced Tutorial Solution Basic Family Sample Model projects Open the Picto view (Window\u2192Show View\u2192Other\u2192Picto) In the basicfamily.sample project, create a new Persons diagram on the Family element. E.g. open the representations.aird file and do the following: and click Finish. When opened you should see charts showing the number of males and females in the family Now create a new Relationships diagram on Elias You should now see charts showing the number of male and female children of Elias","title":"Example"},{"location":"doc/articles/visualising-models-with-picto-and-sirius/#modifying-the-example","text":"The org.eclipse.epsilon.examples.picto.sirius plug-in uses the pictoSource extension point and the BasicFamilyPictoSource class to allow Picto to obtain model elements and auto-refresh on save of the Sirius editor. This uses part of the Sirius API to get the root element of the diagram. protected EObject getRootOfDiagram ( IEditorPart editorPart ) { if ( isSiriusEditor ( editorPart )) { DDiagramEditor editor = ( DDiagramEditor ) editorPart ; DSemanticDiagramImpl diagram = ( DSemanticDiagramImpl ) editor . getRepresentation (); return diagram . getTarget (); } return null ; } protected boolean isSiriusEditor ( IEditorPart editorPart ) { return editorPart instanceof DDiagramEditor ; } The basicfamily.egx file (located in the resources directory of the org.eclipse.epsilon.examples.picto.sirius plug-in) coordinates the generation of the Picto views. The model2bar.egl and model2pie.egl files generate the respective bar and pie chart views using the ChartJS framework.","title":"Modifying the Example"},{"location":"doc/articles/vscode/","text":"Epsilon in VS Code \u00b6 You can now edit and run Epsilon programs, and edit Flexmi models and Emfatic metamodels in VS Code as shown below. To do this you will need to install the following VS Code extensions: Eclipse Epsilon Languages : Syntax highlighting, terminal hyperlinking Gradle for Java : Support for running Gradle build files Give it a spin! \u00b6 Go to any example on the Epsilon Playground Download a zipped copy of the example (for Gradle) using the Download button Extract the downloaded zip file Open the folder using VS Code Go to the Gradle tab on the left hand side Run the run task under Tasks -> other as shown below","title":"Epsilon in VS Code"},{"location":"doc/articles/vscode/#epsilon-in-vs-code","text":"You can now edit and run Epsilon programs, and edit Flexmi models and Emfatic metamodels in VS Code as shown below. To do this you will need to install the following VS Code extensions: Eclipse Epsilon Languages : Syntax highlighting, terminal hyperlinking Gradle for Java : Support for running Gradle build files","title":"Epsilon in VS Code"},{"location":"doc/articles/vscode/#give-it-a-spin","text":"Go to any example on the Epsilon Playground Download a zipped copy of the example (for Gradle) using the Download button Extract the downloaded zip file Open the folder using VS Code Go to the Gradle tab on the left hand side Run the run task under Tasks -> other as shown below","title":"Give it a spin!"},{"location":"doc/articles/xsd-xml/","text":"Scripting XML documents that conform to an XSD schema using Epsilon \u00b6 In this article we demonstrate how you can create, query and modify XML documents backed by an XSD schema in Epsilon. Querying an XML document \u00b6 We use the following library.xml as a base for demonstrating the EOL syntax for querying XML documents. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library xsi:noNamespaceSchemaLocation= \"library.xsd\" > <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" > <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" > <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" > <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> The XSD schema library.xsd that backs the library.xml file is the following. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xs:schema xmlns:xs= \"http://www.w3.org/2001/XMLSchema\" elementFormDefault= \"qualified\" attributeFormDefault= \"unqualified\" > <!-- XML Schema Generated from XML Document with XmlGrid.net Free Online Service http://xmlgrid.net --> <xs:element name= \"library\" > <xs:complexType> <xs:sequence> <xs:element name= \"book\" maxOccurs= \"unbounded\" > <xs:complexType> <xs:sequence> <xs:element name= \"author\" maxOccurs= \"unbounded\" type= \"xs:string\" ></xs:element> <xs:element name= \"published\" type= \"xs:int\" ></xs:element> </xs:sequence> <xs:attribute name= \"title\" type= \"xs:string\" ></xs:attribute> <xs:attribute name= \"pages\" type= \"xs:int\" ></xs:attribute> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Querying XML documents in EOL \u00b6 The XML driver uses a predefined naming convention to allow developers to programmatically access complex types in XML documents. How can I query by element type? \u00b6 The word Type should be appended at the end of the name of the tag that is used to represent a type. In addition, the first letter of the tag should be capitalised (no matter if it is in lowercase in the schema/xml file). For instance, BookType.all() can be used to get all elements tagged as <book> in the document. Also, if b is an element with a <book> tag, then b.isTypeOf(BookType) shall return true. // Get the first library element in the document var library = LibraryType.all().first(); // Get all the books contained in this library var allBooks = library.book; // We can get all the books in the document by querying directly the book type var allBooksAlternative = BookType.all(); // Iterate through the collection of books, navigate the pages attribute and // return the title of the book if it has more than 700 pages for (aBook in allBooks) { if (aBook.pages > 700) { aBook.isTypeOf(BookType).println(); (\"The \" + aBook.title + \" is a large book!\").println(); } } How can I get/set the attributes of an element? \u00b6 You can use the attribute name as a property of the element object. For example, if b is the first book of library.xml , b.title will return EMF Eclipse Modeling Framework . Attribute properties are read/write. In this example, b.pages will return 744 as an integer. Thus, the following program will return the total number of pages of all the books in the library. // Get all the books contained in this library var allBooks = BookType.all(); // Print the total number of pages of all books var total = 0; for (aBook in allBooks) { total = total + aBook.pages; } (\"Total pages: \" + total).println(); // ... the same using collect() and sum() // instead of a for loop BookType.all().collect(b|b.pages).sum().println(); How can I set the text of an element? \u00b6 You can use the property name and the assignment symbol = for this. // Get the first book contained in the library var emfBook = BookType.all().first(); // Set the title to a new one emfBook.title = \"EMF Book\"; // Print the changed title (NB.: You need to have selected the \"Store on disposal\" // option in the run configuration to save changes to the XML file.) var changedEmfBook = BookType.all().first(); changedEmfBook.title.println(); How do I create an element and add it to an existing element? \u00b6 You can use the new operator for this. // Get all the books contained in this library var library = LibraryType.all().first(); var allBooks = library.book; // Print the current number of books allBooks.size().println(); // Create a new book var newBook: new BookType; newBook.title = \"MDE in Practice\"; // Add the book to the library library.book.add(newBook); // Get all books and print the new size BookType.all().size().println(); Adding an XML document to your launch configuration \u00b6 To add an XML document to your Epsilon launch configuration, you need to select \"XML document backed by XSD (EMF)\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. If you are making changes to the XML document, remember to tick the \"Store on disposal\" check box to save the changes in your document.","title":"Scripting XML documents that conform to an XSD schema using Epsilon"},{"location":"doc/articles/xsd-xml/#scripting-xml-documents-that-conform-to-an-xsd-schema-using-epsilon","text":"In this article we demonstrate how you can create, query and modify XML documents backed by an XSD schema in Epsilon.","title":"Scripting XML documents that conform to an XSD schema using Epsilon"},{"location":"doc/articles/xsd-xml/#querying-an-xml-document","text":"We use the following library.xml as a base for demonstrating the EOL syntax for querying XML documents. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library xsi:noNamespaceSchemaLocation= \"library.xsd\" > <book title= \"EMF Eclipse Modeling Framework\" pages= \"744\" > <author> Dave Steinberg </author> <author> Frank Budinsky </author> <author> Marcelo Paternostro </author> <author> Ed Merks </author> <published> 2009 </published> </book> <book title= \"Eclipse Modeling Project: A Domain-Specific Language (DSL) Toolkit\" pages= \"736\" > <author> Richard Gronback </author> <published> 2009 </published> </book> <book title= \"Official Eclipse 3.0 FAQs\" pages= \"432\" > <author> John Arthorne </author> <author> Chris Laffra </author> <published> 2004 </published> </book> </library> The XSD schema library.xsd that backs the library.xml file is the following. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xs:schema xmlns:xs= \"http://www.w3.org/2001/XMLSchema\" elementFormDefault= \"qualified\" attributeFormDefault= \"unqualified\" > <!-- XML Schema Generated from XML Document with XmlGrid.net Free Online Service http://xmlgrid.net --> <xs:element name= \"library\" > <xs:complexType> <xs:sequence> <xs:element name= \"book\" maxOccurs= \"unbounded\" > <xs:complexType> <xs:sequence> <xs:element name= \"author\" maxOccurs= \"unbounded\" type= \"xs:string\" ></xs:element> <xs:element name= \"published\" type= \"xs:int\" ></xs:element> </xs:sequence> <xs:attribute name= \"title\" type= \"xs:string\" ></xs:attribute> <xs:attribute name= \"pages\" type= \"xs:int\" ></xs:attribute> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> </xs:element> </xs:schema>","title":"Querying an XML document"},{"location":"doc/articles/xsd-xml/#querying-xml-documents-in-eol","text":"The XML driver uses a predefined naming convention to allow developers to programmatically access complex types in XML documents.","title":"Querying XML documents in EOL"},{"location":"doc/articles/xsd-xml/#how-can-i-query-by-element-type","text":"The word Type should be appended at the end of the name of the tag that is used to represent a type. In addition, the first letter of the tag should be capitalised (no matter if it is in lowercase in the schema/xml file). For instance, BookType.all() can be used to get all elements tagged as <book> in the document. Also, if b is an element with a <book> tag, then b.isTypeOf(BookType) shall return true. // Get the first library element in the document var library = LibraryType.all().first(); // Get all the books contained in this library var allBooks = library.book; // We can get all the books in the document by querying directly the book type var allBooksAlternative = BookType.all(); // Iterate through the collection of books, navigate the pages attribute and // return the title of the book if it has more than 700 pages for (aBook in allBooks) { if (aBook.pages > 700) { aBook.isTypeOf(BookType).println(); (\"The \" + aBook.title + \" is a large book!\").println(); } }","title":"How can I query by element type?"},{"location":"doc/articles/xsd-xml/#how-can-i-getset-the-attributes-of-an-element","text":"You can use the attribute name as a property of the element object. For example, if b is the first book of library.xml , b.title will return EMF Eclipse Modeling Framework . Attribute properties are read/write. In this example, b.pages will return 744 as an integer. Thus, the following program will return the total number of pages of all the books in the library. // Get all the books contained in this library var allBooks = BookType.all(); // Print the total number of pages of all books var total = 0; for (aBook in allBooks) { total = total + aBook.pages; } (\"Total pages: \" + total).println(); // ... the same using collect() and sum() // instead of a for loop BookType.all().collect(b|b.pages).sum().println();","title":"How can I get/set the attributes of an element?"},{"location":"doc/articles/xsd-xml/#how-can-i-set-the-text-of-an-element","text":"You can use the property name and the assignment symbol = for this. // Get the first book contained in the library var emfBook = BookType.all().first(); // Set the title to a new one emfBook.title = \"EMF Book\"; // Print the changed title (NB.: You need to have selected the \"Store on disposal\" // option in the run configuration to save changes to the XML file.) var changedEmfBook = BookType.all().first(); changedEmfBook.title.println();","title":"How can I set the text of an element?"},{"location":"doc/articles/xsd-xml/#how-do-i-create-an-element-and-add-it-to-an-existing-element","text":"You can use the new operator for this. // Get all the books contained in this library var library = LibraryType.all().first(); var allBooks = library.book; // Print the current number of books allBooks.size().println(); // Create a new book var newBook: new BookType; newBook.title = \"MDE in Practice\"; // Add the book to the library library.book.add(newBook); // Get all books and print the new size BookType.all().size().println();","title":"How do I create an element and add it to an existing element?"},{"location":"doc/articles/xsd-xml/#adding-an-xml-document-to-your-launch-configuration","text":"To add an XML document to your Epsilon launch configuration, you need to select \"XML document backed by XSD (EMF)\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. If you are making changes to the XML document, remember to tick the \"Store on disposal\" check box to save the changes in your document.","title":"Adding an XML document to your launch configuration"},{"location":"doc/articles/yaml-emc/","text":"Scripting YAML documents using Epsilon \u00b6 In this article we demonstrate how you can create, query and modify YAML documents in Epsilon programs using the YAML driver. All the examples in this article demonstrate using EOL to script YAML documents. However, it's worth stressing that YAML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models \u2013 XML, CSV or EMF-based, or to text), compare and merge your YAML documents. Querying a YAML document \u00b6 We use the following employees.yaml as a base for demonstrating the EOL syntax for querying YAML documents. - employeeId : 14623 address : country : England resident : true postcode : M1 1AG fullname : Michael Davidson role : Consultant industry : [ IoT , smart factories , signal analytics ] projects : - { name : SmartAutomation , budget : 25000 } - { name : FactoryAnalytics , budget : 20000 } - employeeId : 16431 address : { country : Germany } fullname : Arnold Wagner role : HR skills : - communication - coaching Querying/modifying YAML documents in EOL \u00b6 The YAML driver uses predefined naming conventions to allow developers to programmatically access and modify YAML documents in a concise way. A type of YAML node must be specified when accessing YAML nodes via the YAML driver. There are 3 types of nodes in YAML: Scalar Node . Scalar nodes are used to represent a single scalar value (e.g., string, boolean, integer). In the YAML driver, a scalar node consists of a key-value pair, in which the key represents the name of the scalar node, and the value represents the scalar value. Mapping Node . Mapping nodes are used to represent unordered collections of key-value pairs. In the YAML driver, a mapping node consists of a key-value pair, in which the key represents the name of the mapping node, and the value holds an unordered collection of key-value pairs, which in turn represent other nodes. List (Sequence) Node . List nodes are used to represent an ordered list of nodes or scalar values. In the YAML driver, a list node consists of a key-value pair, in which the key represents the name of the list node, and the value represents a list of nodes or scalar values. This section outlines the supported conventions in the form of questions and answers followed by relevant examples. How can I access all node elements? \u00b6 Retrieving all nodes, regardless of their type, is performed by using the keyword Node , followed by the property all . One can access all nodes of a specific type, by using the keyword ScalarNode for scalar nodes, MappingNode for mapping nodes, and ListNode for list nodes. // Get and print all nodes Node.all.println(); // Get and print all scalar nodes ScalarNode.all.println(); // Get and print all mapping nodes MappingNode.all.println(); // Get and print all list nodes ListNode.all.println(); How can I access nodes by name? \u00b6 The s_ prefix followed by the name of the node is used to access all scalar nodes with the specified name. Similarly, the m_ prefix is used for accessing mapping nodes, and the l_ prefix for list nodes. For instance, s_role.all can be used to get all scalar nodes named role , m_address.all can be used to get all mapping nodes named address , and l_industry.all can be used to get all list nodes named industry . // Get all scalar nodes with the name \"role\" and print the first one s_role.all.first().println(); // Get all mapping nodes with the name \"address\" and print the first one m_address.all.first().println(); // Get all list nodes with the name \"industry\" and print the first one l_industry.all.first().println(); How can I retrieve nodes as a sequence of elements or as a single element? \u00b6 One can specify how nodes can be retrieved, either as a sequence or as a single element. After the prefix of the node type (i.e., s for scalar node, m for mapping node, l for list node), one can use an additional prefix c_ to specify that nodes should be retrieved as a sequence, or can use e_ to specify that a single node should be retrieved. For instance, se_country specifies that a single scalar node named country should be retrieved, whereas sc_country specifies that the node named country should be retrieved in a sequence. Using the additional prefix e_ can eliminate the need for using further accessor functions (e.g., first , last , at ). // Get the first \"address\" mapping node var address = m_address.all.first(); // Get and print the \"country\" scalar node in a sequence (c_) address.sc_country.println(); // Get and print the \"country\" scalar node as a single element (e_) address.se_country.println(); How can I access the name of a node? \u00b6 One may be interested in verifying the name of a node for debugging programs, and for this purpose, the name property can be used. // Get the first \"industry\" list node var industry = l_industry.all.first(); // Get and print the name of the node industry.name.println(); How can I access the type of a node? \u00b6 One may be interested in verifying the type of a node for debugging programs, and for this purpose, the type property can be used. // Get the first \"role\" scalar node var role = s_role.all.first(); // Get and print the type of the node role.type.println(); // ScalarNode How can I access the value of a node? \u00b6 The value property can be used for accessing the value of a node. The value of a node can be converted into different types using the following prefixes: s_ for strings i_ for integers d_ for doubles f_ for floats b_ for booleans var employeeVal = s_employeeId.all.first().value; // 14623 var s_employeeVal = s_employeeId.all.first().s_value + 1; // 146231 var i_employeeVal = s_employeeId.all.first().i_value + 1; // 14624 var d_employeeVal = s_employeeId.all.first().d_value + 1; // 14624.0 var f_employeeVal = s_employeeId.all.first().f_value + 1; // 14624.0 var b_residentVal = s_resident.all.first().b_value; // true How can I create a node? \u00b6 To create a new node, you can use the new operator followed by the type of node (i.e., ScalarNode , MappingNode , ListNode ). Alternatively, the convention for accessing nodes can be used for creating nodes. For instance, one can use the new operator followed by s_role to create a scalar node named role . // scalar node named \"city\" with the value \"Berlin\" var cityNode1 = new ScalarNode(\"city\", \"Berlin\"); // city=Berlin var cityNode2 = new s_city(\"Berlin\"); // city=Berlin // empty mapping node named \"address\"; its value must be set later var addressNode1 = new MappingNode(\"address\"); // address={} var addressNode2 = new m_address; // address={} // empty list node named \"books\" that contains 5 entries; its values must be set later var booksNode1 = new ListNode(\"books\", 5); // books=[{}, {}, {}, {}, {}] var booksNode2 = new l_books(5); // books=[{}, {}, {}, {}, {}] How do I set the value of a node? \u00b6 For setting or changing the value of a node, the value property can be used, followed by the assignment operator (\u201c=\u201d) and a value or a node. If a node is specified after the assignment operator, then the name of that node will be ignored, and the value of that node will become the new value after the assignment operation. The function set(position, value) can be used for modifying the items of a list node. // changes the value of the first \"fullname\" scalar node to \"Jack\" s_fullname.all.at(0).value = \"Jack\"; // changes the value of the first \"role\" scalar node to \"Developer\" s_role.all.first().value = new ScalarNode(\"newNode\", \"Developer\"); // changes the value of the \"country\" scalar node to \"Turkey\" m_address.all.first().se_country.value = \"Turkey\"; // changes the last \"address\" mapping node into a scalar node with the value \"Street Broadway\" m_address.all.last().value = new s_newNode(\"Street Broadway\"); // changes the last \"role\" scalar node into an empty mapping node s_role.all.last().value = new MappingNode(); // changes the last \"employeeId\" scalar node into a list node that contains 3 empty entries s_employeeId.all.last().value = new ListNode(\"newNode\", 3); // changes in the \"skills\" list node the value of the item at position 1 to \"databases\" l_skills.all.first().value.set(1, \"databases\"); How do I add entries to a list node? \u00b6 The function add(value) can be used for adding an item to a list node that contains scalar values. The functions addRow() and addRows(size) can be used for adding empty entries to a list node that contains nodes. // add an item to the \"skills\" list node l_skills.all.first().value.add(\"analytics\"); // add 1 empty entry to the \"projects\" list node l_projects.all.first().value.addRow(); // add 3 empty entries to the \"projects\" list node l_projects.all.first().value.addRows(3); How do I add nodes to a mapping node? \u00b6 The appendNode(node) function can be used for adding new nodes into a mapping node. var address = m_address.all.last(); // add a new scalar node with the name \"city\" and value \"Berlin\" address.value.appendNode(new ScalarNode(\"city\", \"Berlin\")); How do I set the root node of a YAML document? \u00b6 The root property can be used for setting the root node of a YAML document. The root node of a YAML document can either be a mapping node or a list node. The setRootAsMap() function can be used for setting the root node into a mapping node. The setRootAsList() function can be used for setting the root node into a list node. // Set the root node into a mapping node YAMLDoc.setRootAsMap(); // Set the root node into a list node YAMLDoc.setRootAsList(); // Set the root node into a mapping node YAMLDoc.root.value = new MappingNode(); // Set the root node into a list node with 3 empty entries YAMLDoc.root.value = new ListNode(\"\", 3); How can I create a YAML document from scratch? \u00b6 The following code can be used for creating the employees.yaml file programmatically. YAMLDoc.setRootAsList(); var root = YAMLDoc.getRoot(); root.value.addRows(2); var rootFirstRow = root.value.at(0); var rootSecondRow = root.value.at(1); var addressNode1 = new MappingNode(\"address\"); var countryNode1 = new ScalarNode(\"country\", \"England\"); var residentNode = new ScalarNode(\"resident\", true); var postcodeNode = new ScalarNode(\"postcode\", \"M1 1AG\"); addressNode1.value.appendNode(countryNode1); addressNode1.value.appendNode(residentNode); addressNode1.value.appendNode(postcodeNode); var employeeIdNode1 = new ScalarNode(\"employeeId\", \"14623\"); var fullnameNode1 = new ScalarNode(\"fullname\", \"Michael Davidson\"); var roleNode1 = new ScalarNode(\"role\", \"Consultant\"); var industryNode = new ListNode(\"industry\", 3); industryNode.value = Sequence{\"IoT\", \"smart factories\", \"signal analytics\"}; var projectsNode = new ListNode(\"projects\", 2); var nameNode1 = new ScalarNode(\"name\", \"SmartAutomation\"); var nameNode2 = new ScalarNode(\"name\", \"FactoryAnalytics\"); var budgetNode1 = new ScalarNode(\"budget\", 25000); var budgetNode2 = new ScalarNode(\"budget\", 20000); projectsNode.value.at(0).appendNode(nameNode1); projectsNode.value.at(0).appendNode(budgetNode1); projectsNode.value.at(1).appendNode(nameNode2); projectsNode.value.at(1).appendNode(budgetNode2); var addressNode2 = new MappingNode(\"address\"); var countryNode2 = new ScalarNode(\"country\", \"Germany\"); addressNode2.value.appendNode(countryNode2); var employeeIdNode2 = new ScalarNode(\"employeeId\", \"16431\"); var fullnameNode2 = new ScalarNode(\"fullname\", \"Arnold Wagner\"); var roleNode2 = new ScalarNode(\"role\", \"HR\"); var skillsNode = new ListNode(\"skills\", 2); skillsNode.value = Sequence{\"communication\", \"coaching\"}; rootFirstRow.appendNode(employeeIdNode1); rootFirstRow.appendNode(addressNode1); rootFirstRow.appendNode(fullnameNode1); rootFirstRow.appendNode(roleNode1); rootFirstRow.appendNode(industryNode); rootFirstRow.appendNode(projectsNode); rootSecondRow.appendNode(employeeIdNode2); rootSecondRow.appendNode(addressNode2); rootSecondRow.appendNode(fullnameNode2); rootSecondRow.appendNode(roleNode2); rootSecondRow.appendNode(skillsNode); How can I delete nodes? \u00b6 To delete nodes, you can use the delete operator followed by the node(s) to be deleted. // delete all scalar nodes named \"role\" delete s_role.all; // delete the first mapping node named \"address\" delete m_address.all.first(); // delete all list nodes named \"skills\" delete l_skills.all; Adding a YAML document to your launch configuration \u00b6 To add a YAML document to your Epsilon launch configuration, you need to select \"YAML Document\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load a YAML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full URI for your document (e.g. http://api.twitter.com/followers/epsilonews.yaml or file:/c:/employees.yaml ). Loading a YAML document through Java code \u00b6 The following excerpt demonstrates using YAML models using Epsilon's Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); YamlModel model = new YamlModel (); model . setName ( \"YAMLDoc\" ); model . setFile ( new File ( \"...\" )); model . load (); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute (); Additional resources \u00b6 MDENet Community : Additional learning resources about MDE with the Epsilon Framework","title":"Scripting YAML documents using Epsilon"},{"location":"doc/articles/yaml-emc/#scripting-yaml-documents-using-epsilon","text":"In this article we demonstrate how you can create, query and modify YAML documents in Epsilon programs using the YAML driver. All the examples in this article demonstrate using EOL to script YAML documents. However, it's worth stressing that YAML documents are supported throughout Epsilon. Therefore, you can use Epsilon to (cross-)validate, transform (to other models \u2013 XML, CSV or EMF-based, or to text), compare and merge your YAML documents.","title":"Scripting YAML documents using Epsilon"},{"location":"doc/articles/yaml-emc/#querying-a-yaml-document","text":"We use the following employees.yaml as a base for demonstrating the EOL syntax for querying YAML documents. - employeeId : 14623 address : country : England resident : true postcode : M1 1AG fullname : Michael Davidson role : Consultant industry : [ IoT , smart factories , signal analytics ] projects : - { name : SmartAutomation , budget : 25000 } - { name : FactoryAnalytics , budget : 20000 } - employeeId : 16431 address : { country : Germany } fullname : Arnold Wagner role : HR skills : - communication - coaching","title":"Querying a YAML document"},{"location":"doc/articles/yaml-emc/#queryingmodifying-yaml-documents-in-eol","text":"The YAML driver uses predefined naming conventions to allow developers to programmatically access and modify YAML documents in a concise way. A type of YAML node must be specified when accessing YAML nodes via the YAML driver. There are 3 types of nodes in YAML: Scalar Node . Scalar nodes are used to represent a single scalar value (e.g., string, boolean, integer). In the YAML driver, a scalar node consists of a key-value pair, in which the key represents the name of the scalar node, and the value represents the scalar value. Mapping Node . Mapping nodes are used to represent unordered collections of key-value pairs. In the YAML driver, a mapping node consists of a key-value pair, in which the key represents the name of the mapping node, and the value holds an unordered collection of key-value pairs, which in turn represent other nodes. List (Sequence) Node . List nodes are used to represent an ordered list of nodes or scalar values. In the YAML driver, a list node consists of a key-value pair, in which the key represents the name of the list node, and the value represents a list of nodes or scalar values. This section outlines the supported conventions in the form of questions and answers followed by relevant examples.","title":"Querying/modifying YAML documents in EOL"},{"location":"doc/articles/yaml-emc/#how-can-i-access-all-node-elements","text":"Retrieving all nodes, regardless of their type, is performed by using the keyword Node , followed by the property all . One can access all nodes of a specific type, by using the keyword ScalarNode for scalar nodes, MappingNode for mapping nodes, and ListNode for list nodes. // Get and print all nodes Node.all.println(); // Get and print all scalar nodes ScalarNode.all.println(); // Get and print all mapping nodes MappingNode.all.println(); // Get and print all list nodes ListNode.all.println();","title":"How can I access all node elements?"},{"location":"doc/articles/yaml-emc/#how-can-i-access-nodes-by-name","text":"The s_ prefix followed by the name of the node is used to access all scalar nodes with the specified name. Similarly, the m_ prefix is used for accessing mapping nodes, and the l_ prefix for list nodes. For instance, s_role.all can be used to get all scalar nodes named role , m_address.all can be used to get all mapping nodes named address , and l_industry.all can be used to get all list nodes named industry . // Get all scalar nodes with the name \"role\" and print the first one s_role.all.first().println(); // Get all mapping nodes with the name \"address\" and print the first one m_address.all.first().println(); // Get all list nodes with the name \"industry\" and print the first one l_industry.all.first().println();","title":"How can I access nodes by name?"},{"location":"doc/articles/yaml-emc/#how-can-i-retrieve-nodes-as-a-sequence-of-elements-or-as-a-single-element","text":"One can specify how nodes can be retrieved, either as a sequence or as a single element. After the prefix of the node type (i.e., s for scalar node, m for mapping node, l for list node), one can use an additional prefix c_ to specify that nodes should be retrieved as a sequence, or can use e_ to specify that a single node should be retrieved. For instance, se_country specifies that a single scalar node named country should be retrieved, whereas sc_country specifies that the node named country should be retrieved in a sequence. Using the additional prefix e_ can eliminate the need for using further accessor functions (e.g., first , last , at ). // Get the first \"address\" mapping node var address = m_address.all.first(); // Get and print the \"country\" scalar node in a sequence (c_) address.sc_country.println(); // Get and print the \"country\" scalar node as a single element (e_) address.se_country.println();","title":"How can I retrieve nodes as a sequence of elements or as a single element?"},{"location":"doc/articles/yaml-emc/#how-can-i-access-the-name-of-a-node","text":"One may be interested in verifying the name of a node for debugging programs, and for this purpose, the name property can be used. // Get the first \"industry\" list node var industry = l_industry.all.first(); // Get and print the name of the node industry.name.println();","title":"How can I access the name of a node?"},{"location":"doc/articles/yaml-emc/#how-can-i-access-the-type-of-a-node","text":"One may be interested in verifying the type of a node for debugging programs, and for this purpose, the type property can be used. // Get the first \"role\" scalar node var role = s_role.all.first(); // Get and print the type of the node role.type.println(); // ScalarNode","title":"How can I access the type of a node?"},{"location":"doc/articles/yaml-emc/#how-can-i-access-the-value-of-a-node","text":"The value property can be used for accessing the value of a node. The value of a node can be converted into different types using the following prefixes: s_ for strings i_ for integers d_ for doubles f_ for floats b_ for booleans var employeeVal = s_employeeId.all.first().value; // 14623 var s_employeeVal = s_employeeId.all.first().s_value + 1; // 146231 var i_employeeVal = s_employeeId.all.first().i_value + 1; // 14624 var d_employeeVal = s_employeeId.all.first().d_value + 1; // 14624.0 var f_employeeVal = s_employeeId.all.first().f_value + 1; // 14624.0 var b_residentVal = s_resident.all.first().b_value; // true","title":"How can I access the value of a node?"},{"location":"doc/articles/yaml-emc/#how-can-i-create-a-node","text":"To create a new node, you can use the new operator followed by the type of node (i.e., ScalarNode , MappingNode , ListNode ). Alternatively, the convention for accessing nodes can be used for creating nodes. For instance, one can use the new operator followed by s_role to create a scalar node named role . // scalar node named \"city\" with the value \"Berlin\" var cityNode1 = new ScalarNode(\"city\", \"Berlin\"); // city=Berlin var cityNode2 = new s_city(\"Berlin\"); // city=Berlin // empty mapping node named \"address\"; its value must be set later var addressNode1 = new MappingNode(\"address\"); // address={} var addressNode2 = new m_address; // address={} // empty list node named \"books\" that contains 5 entries; its values must be set later var booksNode1 = new ListNode(\"books\", 5); // books=[{}, {}, {}, {}, {}] var booksNode2 = new l_books(5); // books=[{}, {}, {}, {}, {}]","title":"How can I create a node?"},{"location":"doc/articles/yaml-emc/#how-do-i-set-the-value-of-a-node","text":"For setting or changing the value of a node, the value property can be used, followed by the assignment operator (\u201c=\u201d) and a value or a node. If a node is specified after the assignment operator, then the name of that node will be ignored, and the value of that node will become the new value after the assignment operation. The function set(position, value) can be used for modifying the items of a list node. // changes the value of the first \"fullname\" scalar node to \"Jack\" s_fullname.all.at(0).value = \"Jack\"; // changes the value of the first \"role\" scalar node to \"Developer\" s_role.all.first().value = new ScalarNode(\"newNode\", \"Developer\"); // changes the value of the \"country\" scalar node to \"Turkey\" m_address.all.first().se_country.value = \"Turkey\"; // changes the last \"address\" mapping node into a scalar node with the value \"Street Broadway\" m_address.all.last().value = new s_newNode(\"Street Broadway\"); // changes the last \"role\" scalar node into an empty mapping node s_role.all.last().value = new MappingNode(); // changes the last \"employeeId\" scalar node into a list node that contains 3 empty entries s_employeeId.all.last().value = new ListNode(\"newNode\", 3); // changes in the \"skills\" list node the value of the item at position 1 to \"databases\" l_skills.all.first().value.set(1, \"databases\");","title":"How do I set the value of a node?"},{"location":"doc/articles/yaml-emc/#how-do-i-add-entries-to-a-list-node","text":"The function add(value) can be used for adding an item to a list node that contains scalar values. The functions addRow() and addRows(size) can be used for adding empty entries to a list node that contains nodes. // add an item to the \"skills\" list node l_skills.all.first().value.add(\"analytics\"); // add 1 empty entry to the \"projects\" list node l_projects.all.first().value.addRow(); // add 3 empty entries to the \"projects\" list node l_projects.all.first().value.addRows(3);","title":"How do I add entries to a list node?"},{"location":"doc/articles/yaml-emc/#how-do-i-add-nodes-to-a-mapping-node","text":"The appendNode(node) function can be used for adding new nodes into a mapping node. var address = m_address.all.last(); // add a new scalar node with the name \"city\" and value \"Berlin\" address.value.appendNode(new ScalarNode(\"city\", \"Berlin\"));","title":"How do I add nodes to a mapping node?"},{"location":"doc/articles/yaml-emc/#how-do-i-set-the-root-node-of-a-yaml-document","text":"The root property can be used for setting the root node of a YAML document. The root node of a YAML document can either be a mapping node or a list node. The setRootAsMap() function can be used for setting the root node into a mapping node. The setRootAsList() function can be used for setting the root node into a list node. // Set the root node into a mapping node YAMLDoc.setRootAsMap(); // Set the root node into a list node YAMLDoc.setRootAsList(); // Set the root node into a mapping node YAMLDoc.root.value = new MappingNode(); // Set the root node into a list node with 3 empty entries YAMLDoc.root.value = new ListNode(\"\", 3);","title":"How do I set the root node of a YAML document?"},{"location":"doc/articles/yaml-emc/#how-can-i-create-a-yaml-document-from-scratch","text":"The following code can be used for creating the employees.yaml file programmatically. YAMLDoc.setRootAsList(); var root = YAMLDoc.getRoot(); root.value.addRows(2); var rootFirstRow = root.value.at(0); var rootSecondRow = root.value.at(1); var addressNode1 = new MappingNode(\"address\"); var countryNode1 = new ScalarNode(\"country\", \"England\"); var residentNode = new ScalarNode(\"resident\", true); var postcodeNode = new ScalarNode(\"postcode\", \"M1 1AG\"); addressNode1.value.appendNode(countryNode1); addressNode1.value.appendNode(residentNode); addressNode1.value.appendNode(postcodeNode); var employeeIdNode1 = new ScalarNode(\"employeeId\", \"14623\"); var fullnameNode1 = new ScalarNode(\"fullname\", \"Michael Davidson\"); var roleNode1 = new ScalarNode(\"role\", \"Consultant\"); var industryNode = new ListNode(\"industry\", 3); industryNode.value = Sequence{\"IoT\", \"smart factories\", \"signal analytics\"}; var projectsNode = new ListNode(\"projects\", 2); var nameNode1 = new ScalarNode(\"name\", \"SmartAutomation\"); var nameNode2 = new ScalarNode(\"name\", \"FactoryAnalytics\"); var budgetNode1 = new ScalarNode(\"budget\", 25000); var budgetNode2 = new ScalarNode(\"budget\", 20000); projectsNode.value.at(0).appendNode(nameNode1); projectsNode.value.at(0).appendNode(budgetNode1); projectsNode.value.at(1).appendNode(nameNode2); projectsNode.value.at(1).appendNode(budgetNode2); var addressNode2 = new MappingNode(\"address\"); var countryNode2 = new ScalarNode(\"country\", \"Germany\"); addressNode2.value.appendNode(countryNode2); var employeeIdNode2 = new ScalarNode(\"employeeId\", \"16431\"); var fullnameNode2 = new ScalarNode(\"fullname\", \"Arnold Wagner\"); var roleNode2 = new ScalarNode(\"role\", \"HR\"); var skillsNode = new ListNode(\"skills\", 2); skillsNode.value = Sequence{\"communication\", \"coaching\"}; rootFirstRow.appendNode(employeeIdNode1); rootFirstRow.appendNode(addressNode1); rootFirstRow.appendNode(fullnameNode1); rootFirstRow.appendNode(roleNode1); rootFirstRow.appendNode(industryNode); rootFirstRow.appendNode(projectsNode); rootSecondRow.appendNode(employeeIdNode2); rootSecondRow.appendNode(addressNode2); rootSecondRow.appendNode(fullnameNode2); rootSecondRow.appendNode(roleNode2); rootSecondRow.appendNode(skillsNode);","title":"How can I create a YAML document from scratch?"},{"location":"doc/articles/yaml-emc/#how-can-i-delete-nodes","text":"To delete nodes, you can use the delete operator followed by the node(s) to be deleted. // delete all scalar nodes named \"role\" delete s_role.all; // delete the first mapping node named \"address\" delete m_address.all.first(); // delete all list nodes named \"skills\" delete l_skills.all;","title":"How can I delete nodes?"},{"location":"doc/articles/yaml-emc/#adding-a-yaml-document-to-your-launch-configuration","text":"To add a YAML document to your Epsilon launch configuration, you need to select \"YAML Document\" from the list of available model types. Then you can configure the details of your document (name, file etc.) in the screen that pops up. To load a YAML document that is not in the Eclipse workspace, untick the \"Workspace file\" check box and provide a full URI for your document (e.g. http://api.twitter.com/followers/epsilonews.yaml or file:/c:/employees.yaml ).","title":"Adding a YAML document to your launch configuration"},{"location":"doc/articles/yaml-emc/#loading-a-yaml-document-through-java-code","text":"The following excerpt demonstrates using YAML models using Epsilon's Java API. EolModule module = new EolModule (); module . parse ( new File ( \"...\" )); YamlModel model = new YamlModel (); model . setName ( \"YAMLDoc\" ); model . setFile ( new File ( \"...\" )); model . load (); module . getContext (). getModelRepository (). addModel ( model ); module . getContext (). setModule ( module ); module . execute ();","title":"Loading a YAML document through Java code"},{"location":"doc/articles/yaml-emc/#additional-resources","text":"MDENet Community : Additional learning resources about MDE with the Epsilon Framework","title":"Additional resources"},{"location":"doc/book/","text":"Epsilon Book \u00b6 Following a major redesign of the website in June 2020, we decided to retire the Epsilon Book and to weave its contents into the website for better long-term maintenance. The final version of the PDF book is available here . The content of the book has been merged into the website as follows: Chapter 2: The Epsilon Model Connectivity Layer (EMC) Chapter 3: The Epsilon Object Language (EOL) Chapter 4: The Epsilon Validation Language (EVL) Chapter 5: The Epsilon Transformation Language (ETL) Chapter 6: The Epsilon Wizard Language (EWL) Chapter 7: The Epsilon Generation Language (EGL) Chapter 8: The Epsilon Comparison Language (ECL) Chapter 9: The Epsilon Merging Language (EML) Chapter 10: Epsilon Flock for Model Migration Chapter 11: The Epsilon Pattern Language (EPL) Chapter 12: The Epsilon Model Generation Language (EMG) Chapter 14: Orchestration Workflow Chapter 15: The Epsilon Unit Testing Framework (EUnit)","title":"Epsilon Book"},{"location":"doc/book/#epsilon-book","text":"Following a major redesign of the website in June 2020, we decided to retire the Epsilon Book and to weave its contents into the website for better long-term maintenance. The final version of the PDF book is available here . The content of the book has been merged into the website as follows: Chapter 2: The Epsilon Model Connectivity Layer (EMC) Chapter 3: The Epsilon Object Language (EOL) Chapter 4: The Epsilon Validation Language (EVL) Chapter 5: The Epsilon Transformation Language (ETL) Chapter 6: The Epsilon Wizard Language (EWL) Chapter 7: The Epsilon Generation Language (EGL) Chapter 8: The Epsilon Comparison Language (ECL) Chapter 9: The Epsilon Merging Language (EML) Chapter 10: Epsilon Flock for Model Migration Chapter 11: The Epsilon Pattern Language (EPL) Chapter 12: The Epsilon Model Generation Language (EMG) Chapter 14: Orchestration Workflow Chapter 15: The Epsilon Unit Testing Framework (EUnit)","title":"Epsilon Book"},{"location":"doc/eugenia/","text":"Graphical Model Editor development with Eugenia/GMF \u00b6 Eugenia is a tool that simplifies the development of GMF-based graphical model editors by automatically generating the .gmfgraph , .gmftool and .gmfmap models needed by GMF editor from a single annotated Ecore metamodel. For example, from the following annotated EMF metamodel (expressed using Emfatic; an Ecore version is available here ) it can generate a fully functional GMF editor, a screenshot of which is displayed below. The Filesystem metamodel \u00b6 @namespace(uri=\"filesystem\", prefix=\"filesystem\") @gmf package filesystem; @gmf.diagram class Filesystem { val Drive[*] drives; val Sync[*] syncs; } class Drive extends Folder { } class Folder extends File { @gmf.compartment val File[*] contents; } class Shortcut extends File { @gmf.link(target.decoration=\"arrow\", style=\"dash\") ref File target; } @gmf.link(source=\"source\", target=\"target\", style=\"dot\", width=\"2\") class Sync { ref File source; ref File target; } @gmf.node(label = \"name\") class File { attr String name; } The generated editor \u00b6 Supported Annotations \u00b6 Eugenia supports the following annotations on Ecore elements. gmf \u00b6 Applies to the top EPackage only and denotes that GMF-related annotations are expected in its elements. This doesn't affect the forthcoming model transformations, only the Ecore validation process. gmf.diagram \u00b6 Denotes the root object of the metamodel. Only one (non-abstract) EClass must be annotated as gmf.diagram . Accepts the following details: diagram.extension (optional) : the file extension for the diagram file model.extension (optional) : the file extension for the domain model. To make the generated tree-based editor work with the same extension, you need to add an @emf.gen(fileExtensions=\"model-file-extension\") annotation to the root package of your metamodel. onefile (optional) : a value of true specifies that the domain model and the diagram should be stored in the same file rcp (optional) : a value of true specifies that the editor is intended to be part of a RCP product (printing is disabled) units (optional) : the units for the diagram (e.g. Pixels ) gmf.node \u00b6 Applies to an EClass and denotes that it should appear on the diagram as a node. Accepts the following details: border.color (optional) : an RGB color that will be set as the node's border color. border.style (optional) : the style of the node's border. Can be set to solid (default), dash or dot . border.width (optional) : an integer that specifies the width of the node's border. color (optional) : an RGB color that will be set as the node's background color (e.g. 255,0,0 ). figure (optional) : the figure that will represent the node. Can be set to rectangle , ellipse , rounded (default), svg (see svg.uri ), polygon (see polygon.x and polygon.y ) or the fully qualified name of a Java class that implements Figure. label : the name(s) of the EAttribute (s) of the EClass , the value(s) of which will be displayed as the label of the node. If label.placement is set to none , this detail is not required. label.color (optional, since 1.5.0) : an RGB color that will be set as the node's foreground color. Labels will have a fixed font of this color. label.icon (optional) : if set to true (default) a small icon appears on the left of the label. label.parser (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat -based parser is generated, but it can be manually customized after generation. label.edit.pattern (optional) : like label.pattern , but only for editing the label. label.pattern (optional) : if more than one attributes are specified in the label, the format detail is necessary to show how their values will be rendered in the label. The format follows the Java Message Format style (e.g. {0} : {1} ). The same pattern is used for editing and viewing the label. label.view.pattern (optional) : like label.pattern , but only for viewing the label. label.placement (optional) : defines the placement of the label in relation to the node. Can be set to internal , external or none (no label will be shown). ''(The default distance of an external label in GMF is 20pt which is a bit too far away for my taste. Read more about fixing this without changing the generated code every time)''. label.text (optional) : defines the default text to be used when the EAttribute (s) in label are not set. By default, it is set to the name of the EClass . label.readOnly (optional) : a value of true denotes that the label cannot be changed in the generated diagram editor. margin (optional) : inset margin (5 units by default) for the node. phantom (optional) : defines if the node is phantom ( true / false ). Phantom nodes are particularly useful in order to visualize containment references using links instead of spatial containment ( read more... ). polygon.x (when figure is set to polygon ) : list of space-separated integers with the X coordinates of the polygon used as figure. polygon.y (when figure is set to polygon ) : list of space-separated integers with the Y coordinates of the polygon used as figure. resizable (optional) : a value of false disables all the resize handles for the node size (optional) : a GMF dimension that will be used as the node's preferred size (e.g. 10,5 ). Width is specified before height. svg.uri (when figure is set to svg ) : URI of the .svg file to be used as figure for the node. For instance, platform:/plugin/my.plugin/my.svg will access the my.svg file in the my.plugin plugin. Note: until Kepler, using SVG figures required the GMF Tooling Experimental SDK (available from this update site ). Remember to add the .svg file to the binary builds of your plugin. tool.description (optional) : the description of the creation tool. tool.large.bundle (optional) : the bundle of the large icon of the creation tool. tool.large.path (optional) : the path of the large icon of the creation tool. tool.name (optional) : the name of the creation tool. tool.small.bundle (optional) : the bundle of the small icon of the creation tool. tool.small.path (optional) : the path of the small icon of the creation tool. gmf.link \u00b6 Applies to EClass es that should appear on the diagram as links and to non-containment EReference s. gmf.link (for EClass) \u00b6 It accepts the following details: color (optional) : the RGB color of the link. incoming (optional) : Boolean value which specifies whether the generated editor should allow links to be created from target to source. Defaults to false . label (optional) : the names of the EAttribute s of the EClass the value of which will be displayed as the label of the link. label.parser (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat -based parser is generated, but it can be manually customized after generation. source : the source non-containment EReference of the link. source.constraint (optional) : OCL assertion that should be checked by the graphical editor when creating a link. For instance, self <> oppositeEnd would forbid users for creating a link from a node to itself (a self-loop): self is the source of the link, and oppositeEnd is the target of the link. source.decoration (optional) : the decoration of the source end of the link. Can be set to none , arrow , rhomb , filledrhomb , square , filledsquare , closedarrow , filledclosedarrow , or the fully qualified name of a Java class that implements the org.eclipse.draw2d.RotatableDecoration interface style (optional) : the style of the link (see border.style above). target : the target non-containment EReference of the link. target.constraint (optional) : OCL assertion that should be checked by the graphical editor when creating a link. For instance, self <> oppositeEnd would forbid users for creating a link from a node to itself (a self-loop): self is the target of the link, and oppositeEnd is the source of the link. target.decoration (optional) : See source.decoration . tool.description (optional) : the description of the creation tool. tool.large.bundle (optional) : the bundle of the large icon of the creation tool. tool.large.path (optional) : the path of the large icon of the creation tool. tool.name (optional) : the name of the creation tool. tool.small.bundle (optional) : the bundle of the small icon of the creation tool. tool.small.path (optional) : the path of the small icon of the creation tool. width (optional) : the width of the link. For an example see the Sync class in the filesystem metamodel gmf.link (for non-containment EReference) \u00b6 It accepts the following details: color (optional) : the RGB color of the link label (optional) : The static text that will be displayed as the label of the link. If no label is specified, the name of the reference is displayed instead. label.text (optional) : equivalent to label in this case. source.decoration (optional) : The decoration of the source end of the link. Can be set to none , arrow , rhomb , filledrhomb , square , filledsquare , closedarrow , filledclosedarrow , or the fully qualified name of a Java class that implements an appropriate interface style (optional) : the style of the link (see border.style above) target.decoration (optional) : As above. tool.description (optional) : the description of the creation tool tool.large.bundle (optional) : The bundle of the large icon of the creation tool tool.large.path (optional) : The path of the large icon of the creation tool tool.name (optional) : the name of the creation tool tool.small.bundle (optional) : The bundle of the small icon of the creation tool tool.small.path (optional) : The path of the small icon of the creation tool width (optional) : the width of the link gmf.compartment (for containment EReference) \u00b6 Defines that the containment reference will create a compartment where model elements that conform to the type of the reference can be placed. It accepts the following details: collapsible (optional) : Set to false to prevent the compartment from collapsing (default is true ) layout (optional) : The layout of the compartment. Can be set to free (default) or list gmf.affixed (for containment EReference) \u00b6 Defines that the containment reference will create nodes which are affixed to the edges of the containing node. See an example . gmf.label (for EAttribute) \u00b6 Defines additional labels for the containing EClass . These labels will be displayed underneath the default label for the containing EClass . It accepts the following details: label.edit.pattern (optional) : like label.pattern , but only for editing the label. label.parser (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat -based parser is generated, but it can be manually customized after generation. label.pattern (optional) : if more than one attributes are specified in the label, the format detail is necessary to show how their values will be rendered in the label. The format follows the Java Message Format style (e.g. {0} : {1} ). The same pattern is used for editing and viewing the label. label.readOnly (optional) : A value of true denotes that the label cannot be changed in the generated diagram editor. label.text (optional) : defines the default text to be used when the attribute is not set. label.view.pattern (optional) : like label.pattern , but only for viewing the label. Installing Eugenia \u00b6 Eugenia is a part of the main Epsilon distribution, available from its update site . Detailed installation instructions are available. Although not necessary, the Emfatic toolkit mentioned above is heavily recommended: install it from its update site . Running Eugenia \u00b6 To run Eugenia you need to do the following: Create a new general project Create and annotate your Emfatic (or Ecore) metamodel in the root of your project Right-click your Emfatic (or Ecore) metamodel and select Eugenia \u2192 Generate GMF editor Launch a new Eclipse instance from the Run \u2192 Eclipse Application right-click menu of the project that contains your metamodel In the new Eclipse instance create a new General \u2192 Project and in it create a new Filesystem diagram through the File \u2192 New \u2192 Other... dialog Re-running Eugenia \u00b6 If you now change your metamodel you'll have to rerun Eugenia to generate your updated editor: Right-click your Ecore metamodel (or Emfatic file) and select Eugenia \u2192 Generate GMF editor Run a new instance of Eclipse (Please note that any changes you have made manually to the editor's .gmfgraph , .gmftool and .gmfmap models will be overwritten . Have a look here for an alternative way to customize these models) Troubleshooting \u00b6 Certain versions of Emfatic do not support annotations without details (e.g. @gmf or @gmf.diagram ). You can use dummy details as a workaround (e.g. @gmf(foo=\"bar\") ) Should you run across the \"Node is referenced from multiple containers with different 'List Layout' values\" message during validation please ignore it and proceed with the editor code generation. Eugenia does not work with Ecore metamodels that span across multiple files/sub-packages Ensure that the name of your package is different to the names of the classes it contains (i.e. a package Foo should not contain a Foo class) Recipes \u00b6 Nodes with user defined images (e.g. jpg, png, gif) Nodes with user defined images at runtime Customizing your editor \u00b6 Click here to find out how you can further customize the generated .gmfgraph , .gmfmap and .gmftool models in ways that are not supported by the annotations provided by Eugenia, and still preserve the customizations when Eugenia is re-invoked. Adding Copyright \u00b6 To add copyright information to your generated .gmfgen model, simply create a file named copyright.txt next to it. Next time you invoke Eugenia \u2192 Synchronize GMF gen model , Eugenia will pick it up and place its contents in the root GenDiagramEditor of your .gmfgen model. If you have added the copyright.txt file, you can also inject its contents to your .genmodel model (EMF generator model) by right-clicking it and invoking Eugenia \u2192 Synchronize EMF gen model . Next Steps \u00b6 Now that you've learned how to generate a GMF-based editor using Eugenia, you may also want to add some constraints to your editor, which you can then evaluate (explicitly or on-save) to check the correctness/consistency of your models : Eugenia and GMF Tooling \u00b6 Eugenia builds on top of the GMF Tooling framework, which is no longer actively maintained. While you can still use Eugenia/GMF to develop fully-functional editors, you may want to consider more actively-maintained tools such as Eclipse Sirius if you need to develop a graphical editor, or Picto if you are only interested in producing read-only views from models.","title":"Eugenia"},{"location":"doc/eugenia/#graphical-model-editor-development-with-eugeniagmf","text":"Eugenia is a tool that simplifies the development of GMF-based graphical model editors by automatically generating the .gmfgraph , .gmftool and .gmfmap models needed by GMF editor from a single annotated Ecore metamodel. For example, from the following annotated EMF metamodel (expressed using Emfatic; an Ecore version is available here ) it can generate a fully functional GMF editor, a screenshot of which is displayed below.","title":"Graphical Model Editor development with Eugenia/GMF"},{"location":"doc/eugenia/#the-filesystem-metamodel","text":"@namespace(uri=\"filesystem\", prefix=\"filesystem\") @gmf package filesystem; @gmf.diagram class Filesystem { val Drive[*] drives; val Sync[*] syncs; } class Drive extends Folder { } class Folder extends File { @gmf.compartment val File[*] contents; } class Shortcut extends File { @gmf.link(target.decoration=\"arrow\", style=\"dash\") ref File target; } @gmf.link(source=\"source\", target=\"target\", style=\"dot\", width=\"2\") class Sync { ref File source; ref File target; } @gmf.node(label = \"name\") class File { attr String name; }","title":"The Filesystem metamodel"},{"location":"doc/eugenia/#the-generated-editor","text":"","title":"The generated editor"},{"location":"doc/eugenia/#supported-annotations","text":"Eugenia supports the following annotations on Ecore elements.","title":"Supported Annotations"},{"location":"doc/eugenia/#gmf","text":"Applies to the top EPackage only and denotes that GMF-related annotations are expected in its elements. This doesn't affect the forthcoming model transformations, only the Ecore validation process.","title":"gmf"},{"location":"doc/eugenia/#gmfdiagram","text":"Denotes the root object of the metamodel. Only one (non-abstract) EClass must be annotated as gmf.diagram . Accepts the following details: diagram.extension (optional) : the file extension for the diagram file model.extension (optional) : the file extension for the domain model. To make the generated tree-based editor work with the same extension, you need to add an @emf.gen(fileExtensions=\"model-file-extension\") annotation to the root package of your metamodel. onefile (optional) : a value of true specifies that the domain model and the diagram should be stored in the same file rcp (optional) : a value of true specifies that the editor is intended to be part of a RCP product (printing is disabled) units (optional) : the units for the diagram (e.g. Pixels )","title":"gmf.diagram"},{"location":"doc/eugenia/#gmfnode","text":"Applies to an EClass and denotes that it should appear on the diagram as a node. Accepts the following details: border.color (optional) : an RGB color that will be set as the node's border color. border.style (optional) : the style of the node's border. Can be set to solid (default), dash or dot . border.width (optional) : an integer that specifies the width of the node's border. color (optional) : an RGB color that will be set as the node's background color (e.g. 255,0,0 ). figure (optional) : the figure that will represent the node. Can be set to rectangle , ellipse , rounded (default), svg (see svg.uri ), polygon (see polygon.x and polygon.y ) or the fully qualified name of a Java class that implements Figure. label : the name(s) of the EAttribute (s) of the EClass , the value(s) of which will be displayed as the label of the node. If label.placement is set to none , this detail is not required. label.color (optional, since 1.5.0) : an RGB color that will be set as the node's foreground color. Labels will have a fixed font of this color. label.icon (optional) : if set to true (default) a small icon appears on the left of the label. label.parser (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat -based parser is generated, but it can be manually customized after generation. label.edit.pattern (optional) : like label.pattern , but only for editing the label. label.pattern (optional) : if more than one attributes are specified in the label, the format detail is necessary to show how their values will be rendered in the label. The format follows the Java Message Format style (e.g. {0} : {1} ). The same pattern is used for editing and viewing the label. label.view.pattern (optional) : like label.pattern , but only for viewing the label. label.placement (optional) : defines the placement of the label in relation to the node. Can be set to internal , external or none (no label will be shown). ''(The default distance of an external label in GMF is 20pt which is a bit too far away for my taste. Read more about fixing this without changing the generated code every time)''. label.text (optional) : defines the default text to be used when the EAttribute (s) in label are not set. By default, it is set to the name of the EClass . label.readOnly (optional) : a value of true denotes that the label cannot be changed in the generated diagram editor. margin (optional) : inset margin (5 units by default) for the node. phantom (optional) : defines if the node is phantom ( true / false ). Phantom nodes are particularly useful in order to visualize containment references using links instead of spatial containment ( read more... ). polygon.x (when figure is set to polygon ) : list of space-separated integers with the X coordinates of the polygon used as figure. polygon.y (when figure is set to polygon ) : list of space-separated integers with the Y coordinates of the polygon used as figure. resizable (optional) : a value of false disables all the resize handles for the node size (optional) : a GMF dimension that will be used as the node's preferred size (e.g. 10,5 ). Width is specified before height. svg.uri (when figure is set to svg ) : URI of the .svg file to be used as figure for the node. For instance, platform:/plugin/my.plugin/my.svg will access the my.svg file in the my.plugin plugin. Note: until Kepler, using SVG figures required the GMF Tooling Experimental SDK (available from this update site ). Remember to add the .svg file to the binary builds of your plugin. tool.description (optional) : the description of the creation tool. tool.large.bundle (optional) : the bundle of the large icon of the creation tool. tool.large.path (optional) : the path of the large icon of the creation tool. tool.name (optional) : the name of the creation tool. tool.small.bundle (optional) : the bundle of the small icon of the creation tool. tool.small.path (optional) : the path of the small icon of the creation tool.","title":"gmf.node"},{"location":"doc/eugenia/#gmflink","text":"Applies to EClass es that should appear on the diagram as links and to non-containment EReference s.","title":"gmf.link"},{"location":"doc/eugenia/#gmflink-for-eclass","text":"It accepts the following details: color (optional) : the RGB color of the link. incoming (optional) : Boolean value which specifies whether the generated editor should allow links to be created from target to source. Defaults to false . label (optional) : the names of the EAttribute s of the EClass the value of which will be displayed as the label of the link. label.parser (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat -based parser is generated, but it can be manually customized after generation. source : the source non-containment EReference of the link. source.constraint (optional) : OCL assertion that should be checked by the graphical editor when creating a link. For instance, self <> oppositeEnd would forbid users for creating a link from a node to itself (a self-loop): self is the source of the link, and oppositeEnd is the target of the link. source.decoration (optional) : the decoration of the source end of the link. Can be set to none , arrow , rhomb , filledrhomb , square , filledsquare , closedarrow , filledclosedarrow , or the fully qualified name of a Java class that implements the org.eclipse.draw2d.RotatableDecoration interface style (optional) : the style of the link (see border.style above). target : the target non-containment EReference of the link. target.constraint (optional) : OCL assertion that should be checked by the graphical editor when creating a link. For instance, self <> oppositeEnd would forbid users for creating a link from a node to itself (a self-loop): self is the target of the link, and oppositeEnd is the source of the link. target.decoration (optional) : See source.decoration . tool.description (optional) : the description of the creation tool. tool.large.bundle (optional) : the bundle of the large icon of the creation tool. tool.large.path (optional) : the path of the large icon of the creation tool. tool.name (optional) : the name of the creation tool. tool.small.bundle (optional) : the bundle of the small icon of the creation tool. tool.small.path (optional) : the path of the small icon of the creation tool. width (optional) : the width of the link. For an example see the Sync class in the filesystem metamodel","title":"gmf.link (for EClass)"},{"location":"doc/eugenia/#gmflink-for-non-containment-ereference","text":"It accepts the following details: color (optional) : the RGB color of the link label (optional) : The static text that will be displayed as the label of the link. If no label is specified, the name of the reference is displayed instead. label.text (optional) : equivalent to label in this case. source.decoration (optional) : The decoration of the source end of the link. Can be set to none , arrow , rhomb , filledrhomb , square , filledsquare , closedarrow , filledclosedarrow , or the fully qualified name of a Java class that implements an appropriate interface style (optional) : the style of the link (see border.style above) target.decoration (optional) : As above. tool.description (optional) : the description of the creation tool tool.large.bundle (optional) : The bundle of the large icon of the creation tool tool.large.path (optional) : The path of the large icon of the creation tool tool.name (optional) : the name of the creation tool tool.small.bundle (optional) : The bundle of the small icon of the creation tool tool.small.path (optional) : The path of the small icon of the creation tool width (optional) : the width of the link","title":"gmf.link (for non-containment EReference)"},{"location":"doc/eugenia/#gmfcompartment-for-containment-ereference","text":"Defines that the containment reference will create a compartment where model elements that conform to the type of the reference can be placed. It accepts the following details: collapsible (optional) : Set to false to prevent the compartment from collapsing (default is true ) layout (optional) : The layout of the compartment. Can be set to free (default) or list","title":"gmf.compartment (for containment EReference)"},{"location":"doc/eugenia/#gmfaffixed-for-containment-ereference","text":"Defines that the containment reference will create nodes which are affixed to the edges of the containing node. See an example .","title":"gmf.affixed (for containment EReference)"},{"location":"doc/eugenia/#gmflabel-for-eattribute","text":"Defines additional labels for the containing EClass . These labels will be displayed underneath the default label for the containing EClass . It accepts the following details: label.edit.pattern (optional) : like label.pattern , but only for editing the label. label.parser (optional) : indicates the unqualified name of the class that will parse the text entered by the user into the label. By default, a MessageFormat -based parser is generated, but it can be manually customized after generation. label.pattern (optional) : if more than one attributes are specified in the label, the format detail is necessary to show how their values will be rendered in the label. The format follows the Java Message Format style (e.g. {0} : {1} ). The same pattern is used for editing and viewing the label. label.readOnly (optional) : A value of true denotes that the label cannot be changed in the generated diagram editor. label.text (optional) : defines the default text to be used when the attribute is not set. label.view.pattern (optional) : like label.pattern , but only for viewing the label.","title":"gmf.label (for EAttribute)"},{"location":"doc/eugenia/#installing-eugenia","text":"Eugenia is a part of the main Epsilon distribution, available from its update site . Detailed installation instructions are available. Although not necessary, the Emfatic toolkit mentioned above is heavily recommended: install it from its update site .","title":"Installing Eugenia"},{"location":"doc/eugenia/#running-eugenia","text":"To run Eugenia you need to do the following: Create a new general project Create and annotate your Emfatic (or Ecore) metamodel in the root of your project Right-click your Emfatic (or Ecore) metamodel and select Eugenia \u2192 Generate GMF editor Launch a new Eclipse instance from the Run \u2192 Eclipse Application right-click menu of the project that contains your metamodel In the new Eclipse instance create a new General \u2192 Project and in it create a new Filesystem diagram through the File \u2192 New \u2192 Other... dialog","title":"Running Eugenia"},{"location":"doc/eugenia/#re-running-eugenia","text":"If you now change your metamodel you'll have to rerun Eugenia to generate your updated editor: Right-click your Ecore metamodel (or Emfatic file) and select Eugenia \u2192 Generate GMF editor Run a new instance of Eclipse (Please note that any changes you have made manually to the editor's .gmfgraph , .gmftool and .gmfmap models will be overwritten . Have a look here for an alternative way to customize these models)","title":"Re-running Eugenia"},{"location":"doc/eugenia/#troubleshooting","text":"Certain versions of Emfatic do not support annotations without details (e.g. @gmf or @gmf.diagram ). You can use dummy details as a workaround (e.g. @gmf(foo=\"bar\") ) Should you run across the \"Node is referenced from multiple containers with different 'List Layout' values\" message during validation please ignore it and proceed with the editor code generation. Eugenia does not work with Ecore metamodels that span across multiple files/sub-packages Ensure that the name of your package is different to the names of the classes it contains (i.e. a package Foo should not contain a Foo class)","title":"Troubleshooting"},{"location":"doc/eugenia/#recipes","text":"Nodes with user defined images (e.g. jpg, png, gif) Nodes with user defined images at runtime","title":"Recipes"},{"location":"doc/eugenia/#customizing-your-editor","text":"Click here to find out how you can further customize the generated .gmfgraph , .gmfmap and .gmftool models in ways that are not supported by the annotations provided by Eugenia, and still preserve the customizations when Eugenia is re-invoked.","title":"Customizing your editor"},{"location":"doc/eugenia/#adding-copyright","text":"To add copyright information to your generated .gmfgen model, simply create a file named copyright.txt next to it. Next time you invoke Eugenia \u2192 Synchronize GMF gen model , Eugenia will pick it up and place its contents in the root GenDiagramEditor of your .gmfgen model. If you have added the copyright.txt file, you can also inject its contents to your .genmodel model (EMF generator model) by right-clicking it and invoking Eugenia \u2192 Synchronize EMF gen model .","title":"Adding Copyright"},{"location":"doc/eugenia/#next-steps","text":"Now that you've learned how to generate a GMF-based editor using Eugenia, you may also want to add some constraints to your editor, which you can then evaluate (explicitly or on-save) to check the correctness/consistency of your models :","title":"Next Steps"},{"location":"doc/eugenia/#eugenia-and-gmf-tooling","text":"Eugenia builds on top of the GMF Tooling framework, which is no longer actively maintained. While you can still use Eugenia/GMF to develop fully-functional editors, you may want to consider more actively-maintained tools such as Eclipse Sirius if you need to develop a graphical editor, or Picto if you are only interested in producing read-only views from models.","title":"Eugenia and GMF Tooling"},{"location":"doc/exeed/","text":"Exeed (Extended EMF Editor) \u00b6 Exeed is an extended version of the built-in tree-based reflective editor provided by EMF. The aim of Exeed is to enable developers to customize the appearance of the editor (labels and icons) by annotating Ecore metamodels. As a result, developers can enjoy the benefits of a customized editor for their models without needing to generate one and then customize it using Java. Plain Reflective Editor Exeed Exeed Annotations Keys \u00b6 The source for exeed annotations is exeed . Exeed annotations are only supported in EClass , EEnumLiteral and EStructuralFeature elements of the metamodel. For each element the following keys are supported: EClass \u00b6 label : Defines the label that will be used to for the element when it is displayed on all views related to the editor (editing tree, properties view, etc.) referenceLabel : Defines the label for a reference to an instance of this EClass ((e.g. in the properties view). icon : Defines the icon to use to display alongside the element on all views related to the editor (editing tree, properties view, etc.). If specified, it overrides the classIcon annotation. classIcon : Defines the icon of the instances of the EClass . EEnumLiteral \u00b6 label : Defines the label that will be used for the enumeration literal when it is displayed on all views related to the editor (editing tree, properties view, etc.) EStructuralFeature \u00b6 featureLabel : Defines the label that will be used for the structural feature when it is displayed on all views related to the editor (editing tree, properties view, etc.) Exeed Annotations Values \u00b6 All keys, except for classIcon , accept an EOL script as their value. This allows labels and icons to be dynamically allocated based on the properties of the instance. The EOL script is evaluated in the context of each instance, that is, the current instance can be accessed via the self keyword. Further, all other model elements are accessible via navigation (i.e. references from the instance) or by getting all elements of a type (e.g. MyType.all). For the icon and classIcon keys the expected value is the name of one of the icons available in Exeed. Thus, for icon the EOL script must return a string with the name of the icon and for classIcon the value must be the name of the icon. The following icons are available (the extension should not be included): Example \u00b6 The images show the tree view of a OO Model with the EMF Reflective Editor (left) and the Exeed Editor (right). The following code presents the annotated OO metamodel (in Emfatic) that was used to obtain the Exeed result above (the example is available from the examples folder of the Git repository): @namespace(uri=\"OO\", prefix=\"\") package OO; @exeed(classIcon=\"model\") class Model extends Package { } @exeed(referenceLabel=\" var str : String; str = self.closure(pe:PackageableElement|pe.package).collect(p|p.name).invert().concat('.'); if (self.package.isDefined()){ str = str + '.'; } str = str + self.name; return str; \") abstract class PackageableElement extends NamedElement { ref Package#contents ~package; } abstract class AnnotatedElement { val Annotation[*] annotations; } @exeed(label=\"return self.key + ' -> ' + self.value;\", classIcon=\"annotation\") class Annotation { attr String key; attr String value; } @exeed(label=\"return self.name;\") abstract class NamedElement extends AnnotatedElement { attr String name; } @exeed(classIcon=\"package\", label=\"return self.name;\") class Package extends PackageableElement { val PackageableElement[*]#~package contents; ref Package[*] uses; } abstract class Classifier extends PackageableElement { } class ExternalClass extends Class { } @exeed(classIcon=\"class\", label=\" var label : String; label = self.name; if (self.extends.isDefined()){ label = label + ' extends ' + self.extends.name; } return label; \") class Class extends Classifier { ref Class#extendedBy ~extends; ref Class[*]#~extends extendedBy; val Feature[*]#owner features; attr Boolean isAbstract; } @exeed(classIcon=\"datatype\") class Datatype extends Classifier { } abstract class Feature extends NamedElement { ref Class#features owner; ref Classifier type; attr VisibilityEnum visibility; } @exeed(label=\" var label : String; label = self.name; if (self.type.isDefined()){ if (self.isMany) { label = label + ' [*]'; } label = label + ' : ' + self.type.name; } return label;\", icon=\" if (self.visibility = VisibilityEnum#private) { return 'private'; } else { return 'public'; } \") abstract class StructuralFeature extends Feature { attr Boolean isMany; } @exeed(label=\" var label : String; label = self.name + ' ('; for (p in self.parameters) { label = label + p.name; if (p.type.isDefined()) { label = label + ' : ' + p.type.name; } if (hasMore) { label = label + ', '; } } label = label + ')'; if (self.type.isDefined()) { label = label + ' : ' + self.type.name; } return label; \", classIcon=\"operation\") class Operation extends Feature { val Parameter[*]#owner parameters; } @exeed(label=\" var label : String; label = self.name; if (self.type.isDefined()){ label = label + ' : ' + self.type.name; } return label; \", classIcon=\"parameter\") class Parameter extends NamedElement { ref Classifier type; ref Operation#parameters owner; } class Reference extends StructuralFeature { } class Attribute extends StructuralFeature { } enum VisibilityEnum { public = 1; private = 2; } Resources \u00b6 Article: Inspecting EMF Models with Exeed","title":"Exeed"},{"location":"doc/exeed/#exeed-extended-emf-editor","text":"Exeed is an extended version of the built-in tree-based reflective editor provided by EMF. The aim of Exeed is to enable developers to customize the appearance of the editor (labels and icons) by annotating Ecore metamodels. As a result, developers can enjoy the benefits of a customized editor for their models without needing to generate one and then customize it using Java. Plain Reflective Editor Exeed","title":"Exeed (Extended EMF Editor)"},{"location":"doc/exeed/#exeed-annotations-keys","text":"The source for exeed annotations is exeed . Exeed annotations are only supported in EClass , EEnumLiteral and EStructuralFeature elements of the metamodel. For each element the following keys are supported:","title":"Exeed Annotations Keys"},{"location":"doc/exeed/#eclass","text":"label : Defines the label that will be used to for the element when it is displayed on all views related to the editor (editing tree, properties view, etc.) referenceLabel : Defines the label for a reference to an instance of this EClass ((e.g. in the properties view). icon : Defines the icon to use to display alongside the element on all views related to the editor (editing tree, properties view, etc.). If specified, it overrides the classIcon annotation. classIcon : Defines the icon of the instances of the EClass .","title":"EClass"},{"location":"doc/exeed/#eenumliteral","text":"label : Defines the label that will be used for the enumeration literal when it is displayed on all views related to the editor (editing tree, properties view, etc.)","title":"EEnumLiteral"},{"location":"doc/exeed/#estructuralfeature","text":"featureLabel : Defines the label that will be used for the structural feature when it is displayed on all views related to the editor (editing tree, properties view, etc.)","title":"EStructuralFeature"},{"location":"doc/exeed/#exeed-annotations-values","text":"All keys, except for classIcon , accept an EOL script as their value. This allows labels and icons to be dynamically allocated based on the properties of the instance. The EOL script is evaluated in the context of each instance, that is, the current instance can be accessed via the self keyword. Further, all other model elements are accessible via navigation (i.e. references from the instance) or by getting all elements of a type (e.g. MyType.all). For the icon and classIcon keys the expected value is the name of one of the icons available in Exeed. Thus, for icon the EOL script must return a string with the name of the icon and for classIcon the value must be the name of the icon. The following icons are available (the extension should not be included):","title":"Exeed Annotations Values"},{"location":"doc/exeed/#example","text":"The images show the tree view of a OO Model with the EMF Reflective Editor (left) and the Exeed Editor (right). The following code presents the annotated OO metamodel (in Emfatic) that was used to obtain the Exeed result above (the example is available from the examples folder of the Git repository): @namespace(uri=\"OO\", prefix=\"\") package OO; @exeed(classIcon=\"model\") class Model extends Package { } @exeed(referenceLabel=\" var str : String; str = self.closure(pe:PackageableElement|pe.package).collect(p|p.name).invert().concat('.'); if (self.package.isDefined()){ str = str + '.'; } str = str + self.name; return str; \") abstract class PackageableElement extends NamedElement { ref Package#contents ~package; } abstract class AnnotatedElement { val Annotation[*] annotations; } @exeed(label=\"return self.key + ' -> ' + self.value;\", classIcon=\"annotation\") class Annotation { attr String key; attr String value; } @exeed(label=\"return self.name;\") abstract class NamedElement extends AnnotatedElement { attr String name; } @exeed(classIcon=\"package\", label=\"return self.name;\") class Package extends PackageableElement { val PackageableElement[*]#~package contents; ref Package[*] uses; } abstract class Classifier extends PackageableElement { } class ExternalClass extends Class { } @exeed(classIcon=\"class\", label=\" var label : String; label = self.name; if (self.extends.isDefined()){ label = label + ' extends ' + self.extends.name; } return label; \") class Class extends Classifier { ref Class#extendedBy ~extends; ref Class[*]#~extends extendedBy; val Feature[*]#owner features; attr Boolean isAbstract; } @exeed(classIcon=\"datatype\") class Datatype extends Classifier { } abstract class Feature extends NamedElement { ref Class#features owner; ref Classifier type; attr VisibilityEnum visibility; } @exeed(label=\" var label : String; label = self.name; if (self.type.isDefined()){ if (self.isMany) { label = label + ' [*]'; } label = label + ' : ' + self.type.name; } return label;\", icon=\" if (self.visibility = VisibilityEnum#private) { return 'private'; } else { return 'public'; } \") abstract class StructuralFeature extends Feature { attr Boolean isMany; } @exeed(label=\" var label : String; label = self.name + ' ('; for (p in self.parameters) { label = label + p.name; if (p.type.isDefined()) { label = label + ' : ' + p.type.name; } if (hasMore) { label = label + ', '; } } label = label + ')'; if (self.type.isDefined()) { label = label + ' : ' + self.type.name; } return label; \", classIcon=\"operation\") class Operation extends Feature { val Parameter[*]#owner parameters; } @exeed(label=\" var label : String; label = self.name; if (self.type.isDefined()){ label = label + ' : ' + self.type.name; } return label; \", classIcon=\"parameter\") class Parameter extends NamedElement { ref Classifier type; ref Operation#parameters owner; } class Reference extends StructuralFeature { } class Attribute extends StructuralFeature { } enum VisibilityEnum { public = 1; private = 2; }","title":"Example"},{"location":"doc/exeed/#resources","text":"Article: Inspecting EMF Models with Exeed","title":"Resources"},{"location":"doc/flexmi/","text":"Flexmi \u00b6 Flexmi (pronounced flex-em-eye ) is a reflective textual syntax for EMF models . Flexmi supports an XML-based and a YAML-based flavour and offers features such as fuzzy matching of tags and attributes against Ecore class/feature names, support for embedding EOL expressions in models and for defining and instantiating model element templates. For example, the following XML document ( acme.flexmi ): <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <effort person= \"Alice\" /> </task> <task title= \"Design\" start= \"4\" dur= \"6\" > <effort person= \"Bob\" /> </task> <task title= \"Implementation\" start= \"7\" dur= \"3\" > <effort person= \"Bob\" perc= \"50\" /> <effort person= \"Alice\" perc= \"50\" /> </task> </project> is a valid instance of the Ecore metamodel (in Emfatic) below ( psl stands for Project Scheduling Language): @namespace(uri=\"psl\", prefix=\"\") package psl; class Project { attr String name; attr String description; val Task[*] tasks; val Person[*] people; } class Task { attr String title; attr int start; attr int duration; val Effort[*] effort; } class Person { attr String name; ref Skill[*] skills; } class Effort { ref Person person; attr int percentage = 100; } class Skill { attr String name; } Getting started \u00b6 Create a text file named psl.emf in your workspace and place the Emfatic content above in it. Convert it into Ecore and register the produced Ecore metamodel ( psl.ecore ) as shown here . Create a new text file named acme.flexmi and place the XML content above in it. The result should look like the screenshot below. Fuzzy Parsing \u00b6 The Flexmi parser uses fuzzy matching to map the tags in the XML document to instances of EClasses in the target metamodel. In Flexmi, attributes and non-containment references are captured using XML attributes. Multiple values can be captured in a single XML attribute as comma-delimited strings as shown below. <?nsuri psl?> <_> <person name= \"Alice\" skills= \"Java, HTML\" /> <skill name= \"Java\" /> <skill name= \"HTML\" /> </_> Containment references are captured using XML element containment. If an XML element has attributes, the Flexmi parser will compare its tag against EClass/EReference names expected in the context and choose the best match. For example, when it encounters the <person> element below, knowing that it is already in the context of Project it will match the name person against the names of the containment references of Project ( tasks , people ) and (all the sub-types of) their types ( Person , Task ) and will decide that the best match for it is Person . <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> ... </project> As such, it will create an instance of Person and will then try to find a suitable containment reference for it ( people ). If there were multiple containment references of type Person in class Project , we could help the Flexmi parser by either using the name of the target reference instead or person , or by using an empty container element as follows. <?nsuri psl?> <project title= \"ACME\" > <people> <person name= \"Alice\" /> </people> </project> Non-Containment Reference Resolution \u00b6 To resolve non-containment references, Flexmi needs target elements to have some kind of ID. If a class has an EAttribute marked as id , Flexmi will use that to identify its instances, otherwise, it will use the value of the name attribute, if present. Fully-qualified ID paths, separated by . are also supported. Long Attribute Values \u00b6 XML elements can also be used instead of XML attributes to capture long/multiline EAttributes. For example, we can use a <description> nested element instead of an attribute as below. <?nsuri psl?> <project title= \"ACME\" > <description> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. </description> </project> To keep very long values out of Flexmi models altogether, appending an _ to the name of an attribute will instruct the Flexmi parser to look for a file with that name and parse its content as the value of the attribute as shown below. <?nsuri psl?> <project title= \"ACME\" description_= \"readme.txt\" > </project> Attribute Assignment \u00b6 The Flexmi parser uses an implementation of the Hungarian algorithm to decide the best match of XML attribute names to EAttribute and non-containment EReference names. Containment EReference names are currently ignored during matching. Executable Attributes \u00b6 Prepending : to the name of an attribute instructs the Flexmi parser to interpret its value as an executable EOL expression instead of a literal value. Also, Flexmi supports attaching a :var or a :global attribute to XML elements, to declare local/global variables that can be used in EOL expressions. The scope of local variables includes siblings of the element, and their descendants, while global variables can be accessed from anywhere in the model. For example, in the Flexmi model below, the Design task is assigned to a local variable named design , which is then used to compute the value of the start time of the implementation task. <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <effort person= \"Alice\" /> </task> <task title= \"Design\" start= \"4\" dur= \"6\" :var= \"design\" > <effort person= \"Bob\" /> </task> <task title= \"Implementation\" :start= \"design.start + design.duration + 1\" dur= \"3\" > <effort person= \"Bob\" perc= \"50\" /> <effort person= \"Alice\" perc= \"50\" /> </task> </project> You can also use :var / :global and EOL attributes to refer to model elements without using names/ids as identifiers. For example, in the version, below, Alice is attached to the local variable name alice , which is then used in the :person reference of the second effort of the Implementation task. <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" :var= \"alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <effort person= \"Alice\" /> </task> <task title= \"Design\" start= \"4\" dur= \"6\" :var= \"design\" > <effort person= \"Bob\" /> </task> <task title= \"Implementation\" :start= \"design.start+design.duration+1\" dur= \"3\" > <effort person= \"Bob\" perc= \"50\" /> <effort :person= \"alice\" perc= \"50\" /> </task> </project> Object Initialization \u00b6 An XML element representing an object can have an :init child with complex EOL-based initialization logic. For example, this would initialize the \"Analysis\" task to have an Effort child pointing to the first Person in the model: <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <:init> var effort = new Effort(); self.effort.add(effort); effort.person = Person.all.first(); </:init> </task> </project> ITool instances not available Since Flexmi is designed to work from outside Eclipse, Eclipse extension point-based tools are not available from Flexmi EOL code. Including and Importing other Flexmi Models \u00b6 Flexmi supports the <?import other.flexmi?> and <?include other.flexmi?> processing instructions. import creates a new resource for other.flexmi while include parses the contents of other.flexmi as if they were embedded in the Flexmi model that contains the include processing instruction. Instantiating Types from Multiple Ecore Metamodels \u00b6 Multiple <?nsuri metamodeluri?> processing instructions can be used in the preamble of a Flexmi model, allowing it to instantiate multiple Ecore metamodels. However, in case of name clashes between them, there's no good way for disambiguation. Models with Multiple Root Elements \u00b6 If you need to have multiple top-level elements in your model, you can add them under a <_> root element, which has no other semantics. Reusable Templates \u00b6 Flexmi supports defining reusable templates through the reserved <:template> XML tag. For example, when designing one-person projects where all tasks take place in sequence, we can omit all the repetitive <effort> elements that refer to the same person, and we can automate the calculation of the start date of each task using a simpletask template, as shown below. <?nsuri psl?> <_> <project title= \"ACME\" > <person name= \"Alice\" /> <simpletask title= \"Analysis\" dur= \"3\" /> <simpletask title= \"Design\" dur= \"3\" /> <simpletask title= \"Implementation\" dur= \"6\" /> </project> <:template name= \"simpletask\" > <content> <task :start= \"Task.all.indexOf(self).asVar('index') == 0 ? 1 : Task.all.get(index-1).asVar('previous').start + previous.duration\" > <effort :person= \"Person.all.first()\" /> </task> </content> </:template> </_> Parameters \u00b6 Flexmi templates also support parameters, which can be used to configure the content they produce when they are invoked. An example is shown below: <?nsuri psl?> <_> <project title= \"ACME\" > <person name= \"Alice\" /> <design dur= \"3\" person= \"Alice\" /> </project> <:template name= \"design\" > <parameter name= \"person\" /> <content> <task name= \"Design\" > <effort person= \"${person}\" /> </task> </content> </:template> </_> Dynamic Templates and Slots \u00b6 To further customise the content that Flexmi templates produce, one can use an EGL template that produces XML as the value of the <content> element of the template, by setting it's language to EGL as shown below. Also Flexmi supports a <:slot> element in the content of templates, which specifies where any nested elements of the caller should be placed in the produced XML as shown below. <?nsuri psl?> <_> <project title= \"ACME\" > <person name= \"Alice\" /> <longtask title= \"Implementation\" years= \"2\" > <effort person= \"Alice\" /> </longtask> </project> <:template name= \"longtask\" > <parameter name= \"years\" /> <content language= \"EGL\" > <![CDATA[ <task duration=\"[%=years.asInteger()*12%]\"> <:slot/> </task> ]]> </content> </:template> </_> Reusing Templates in Different Flexmi Models \u00b6 Templates can be stored in separate Flexmi files and be imported from different models using Flexmi's <?include ?> processing instruction. Use in Epsilon and Java \u00b6 Flexmi offers and registers an implementation of EMF's Resource interface ( FlexmiResource ), and can be used like any other EMF resource implementation. For example, you can add .flexmi models as regular EMF models to the run configuration of your Epsilon program. An example of using Flexmi from Java follows. ResourceSet resourceSet = new ResourceSetImpl (); resourceSet . getResourceFactoryRegistry (). getExtensionToFactoryMap (). put ( \"flexmi\" , new FlexmiResourceFactory ()); Resource resource = resourceSet . createResource ( URI . createFileURI ( \"/../acme.flexmi\" )); resource . load ( null ); Converting to XMI \u00b6 You can convert a Flexmi model to standard XMI (with no templates, executable attributes etc.) by right-clicking on it in the Project Explorer view and selecting Generate XMI . Converting an XMI model to Flexmi on the other hand is not supported as there's no unique mapping in this direction. YAML Flavour \u00b6 Since Epsilon 2.3.0, Flexmi also supports a YAML flavour. Equivalent YAML representations for the XML-based model at the top of this page are shown below. Info The YAML flavour of Flexmi supports all the features of the XML flavour, including plain and dynamic templates , and executable attributes . Also, it is worth noting that YAML is a superset of JSON. Indentation-based ?nsuri : psl project : - name : ACME - person : { name : Alice } - person : { name : Bob } - task : - title : Analysis - start : 1 - dur : 3 - effort : { person : Alice } - task : - title : Design - start : 4 - dur : 6 - effort : { person : Bob } - task : - title : Implementation - start : 7 - dur : 3 - effort : { person : Bob , perc : 50 } - effort : { person : Alice , perc : 50 } Curly brackets-based ?nsuri : psl project : { name : ACME , person : { name : Alice }, person : { name : Bob }, task : { title : Analysis , start : 1 , dur : 3 , effort : { person : Alice } }, task : { title : Design , start : 4 , dur : 6 , effort : { person : Bob } }, task : { title : Implementation , start : 7 , dur : 3 , effort : { person : Bob , perc : 50 }, effort : { person : Alice , perc : 50 } } } For multi-valued attributes and non-containment references, comma-separated values, or lists of scalars can be used as shown below. - ?nsuri : psl - person : - name : Alice - skills : Java, HTML # Comma-separated - person : - name : Bob - skills : # List of scalars - Java - HTML - skill : { name : Java } - skill : { name : HTML } Tabs vs. Spaces If your YAML-flavoured Flexmi model doesn't parse (i.e. the outline view of the Flexmi editor is empty), you may want to check that you have not accidentally used tabs instead of spaces for indentation. The Flexmi parser auto-detects whether a file is XML-based or YAML-based and parses it accordingly. As such, you should be able to edit YAML-flavoured *.flexmi files in the Flexmi editor. Additional examples of YAML-flavoured Flexmi models are available in this test project (look for *.yaml files). Dynamic Templates in YAML \u00b6 The YAML flavour requires a script attribute in the content of dynamic templates, that holds the EGL script used to dynamically produce the YAML content. The YAML equivalent of the XML-based dynamic template shown above is as follows. - ?nsuri : psl - project : - title : ACME - person : - name : Alice - longtask : - title : Implementation - years : 2 - effort : - person : Alice - :template : - name : longtask - parameter : - name : years - content : - language : EGL - script : |- # Multi-line EGL script - task: - duration: [%=years.asInteger()*12%] - :slot Philosophy \u00b6 Flexmi was originally developed as a quick and dirty way to type in EMF models without having to define an Xtext grammar or adhere to the rigid naming rules of XMI or HUTN. The name is a combination of the word \"flexible\" and the \"XMI\" acronym. Limitations \u00b6 Flexmi resources can't be saved programmatically (i.e. trying to call resource.save(...) will do nothing). There is no code completion in the Flexmi editor at the moment. Resources \u00b6 More examples of using Flexmi can be found in projects containing flexmi in their name, under the examples folder of Epsilon's Git repository. This article shows how to use Flexmi models in ANT/Gradle/Maven builds Flexmi and relevant underpinning research is further described in the following papers: Towards Flexible Parsing of StructuredTextual Model Representations Towards a Modular and Flexible Human-UsableTextual Syntax for EMF Models Type Inference in Flexible Model-Driven Engineering using Classification Algorithms","title":"Flexmi"},{"location":"doc/flexmi/#flexmi","text":"Flexmi (pronounced flex-em-eye ) is a reflective textual syntax for EMF models . Flexmi supports an XML-based and a YAML-based flavour and offers features such as fuzzy matching of tags and attributes against Ecore class/feature names, support for embedding EOL expressions in models and for defining and instantiating model element templates. For example, the following XML document ( acme.flexmi ): <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <effort person= \"Alice\" /> </task> <task title= \"Design\" start= \"4\" dur= \"6\" > <effort person= \"Bob\" /> </task> <task title= \"Implementation\" start= \"7\" dur= \"3\" > <effort person= \"Bob\" perc= \"50\" /> <effort person= \"Alice\" perc= \"50\" /> </task> </project> is a valid instance of the Ecore metamodel (in Emfatic) below ( psl stands for Project Scheduling Language): @namespace(uri=\"psl\", prefix=\"\") package psl; class Project { attr String name; attr String description; val Task[*] tasks; val Person[*] people; } class Task { attr String title; attr int start; attr int duration; val Effort[*] effort; } class Person { attr String name; ref Skill[*] skills; } class Effort { ref Person person; attr int percentage = 100; } class Skill { attr String name; }","title":"Flexmi"},{"location":"doc/flexmi/#getting-started","text":"Create a text file named psl.emf in your workspace and place the Emfatic content above in it. Convert it into Ecore and register the produced Ecore metamodel ( psl.ecore ) as shown here . Create a new text file named acme.flexmi and place the XML content above in it. The result should look like the screenshot below.","title":"Getting started"},{"location":"doc/flexmi/#fuzzy-parsing","text":"The Flexmi parser uses fuzzy matching to map the tags in the XML document to instances of EClasses in the target metamodel. In Flexmi, attributes and non-containment references are captured using XML attributes. Multiple values can be captured in a single XML attribute as comma-delimited strings as shown below. <?nsuri psl?> <_> <person name= \"Alice\" skills= \"Java, HTML\" /> <skill name= \"Java\" /> <skill name= \"HTML\" /> </_> Containment references are captured using XML element containment. If an XML element has attributes, the Flexmi parser will compare its tag against EClass/EReference names expected in the context and choose the best match. For example, when it encounters the <person> element below, knowing that it is already in the context of Project it will match the name person against the names of the containment references of Project ( tasks , people ) and (all the sub-types of) their types ( Person , Task ) and will decide that the best match for it is Person . <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> ... </project> As such, it will create an instance of Person and will then try to find a suitable containment reference for it ( people ). If there were multiple containment references of type Person in class Project , we could help the Flexmi parser by either using the name of the target reference instead or person , or by using an empty container element as follows. <?nsuri psl?> <project title= \"ACME\" > <people> <person name= \"Alice\" /> </people> </project>","title":"Fuzzy Parsing"},{"location":"doc/flexmi/#non-containment-reference-resolution","text":"To resolve non-containment references, Flexmi needs target elements to have some kind of ID. If a class has an EAttribute marked as id , Flexmi will use that to identify its instances, otherwise, it will use the value of the name attribute, if present. Fully-qualified ID paths, separated by . are also supported.","title":"Non-Containment Reference Resolution"},{"location":"doc/flexmi/#long-attribute-values","text":"XML elements can also be used instead of XML attributes to capture long/multiline EAttributes. For example, we can use a <description> nested element instead of an attribute as below. <?nsuri psl?> <project title= \"ACME\" > <description> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. </description> </project> To keep very long values out of Flexmi models altogether, appending an _ to the name of an attribute will instruct the Flexmi parser to look for a file with that name and parse its content as the value of the attribute as shown below. <?nsuri psl?> <project title= \"ACME\" description_= \"readme.txt\" > </project>","title":"Long Attribute Values"},{"location":"doc/flexmi/#attribute-assignment","text":"The Flexmi parser uses an implementation of the Hungarian algorithm to decide the best match of XML attribute names to EAttribute and non-containment EReference names. Containment EReference names are currently ignored during matching.","title":"Attribute Assignment"},{"location":"doc/flexmi/#executable-attributes","text":"Prepending : to the name of an attribute instructs the Flexmi parser to interpret its value as an executable EOL expression instead of a literal value. Also, Flexmi supports attaching a :var or a :global attribute to XML elements, to declare local/global variables that can be used in EOL expressions. The scope of local variables includes siblings of the element, and their descendants, while global variables can be accessed from anywhere in the model. For example, in the Flexmi model below, the Design task is assigned to a local variable named design , which is then used to compute the value of the start time of the implementation task. <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <effort person= \"Alice\" /> </task> <task title= \"Design\" start= \"4\" dur= \"6\" :var= \"design\" > <effort person= \"Bob\" /> </task> <task title= \"Implementation\" :start= \"design.start + design.duration + 1\" dur= \"3\" > <effort person= \"Bob\" perc= \"50\" /> <effort person= \"Alice\" perc= \"50\" /> </task> </project> You can also use :var / :global and EOL attributes to refer to model elements without using names/ids as identifiers. For example, in the version, below, Alice is attached to the local variable name alice , which is then used in the :person reference of the second effort of the Implementation task. <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" :var= \"alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <effort person= \"Alice\" /> </task> <task title= \"Design\" start= \"4\" dur= \"6\" :var= \"design\" > <effort person= \"Bob\" /> </task> <task title= \"Implementation\" :start= \"design.start+design.duration+1\" dur= \"3\" > <effort person= \"Bob\" perc= \"50\" /> <effort :person= \"alice\" perc= \"50\" /> </task> </project>","title":"Executable Attributes"},{"location":"doc/flexmi/#object-initialization","text":"An XML element representing an object can have an :init child with complex EOL-based initialization logic. For example, this would initialize the \"Analysis\" task to have an Effort child pointing to the first Person in the model: <?nsuri psl?> <project title= \"ACME\" > <person name= \"Alice\" /> <person name= \"Bob\" /> <task title= \"Analysis\" start= \"1\" dur= \"3\" > <:init> var effort = new Effort(); self.effort.add(effort); effort.person = Person.all.first(); </:init> </task> </project> ITool instances not available Since Flexmi is designed to work from outside Eclipse, Eclipse extension point-based tools are not available from Flexmi EOL code.","title":"Object Initialization"},{"location":"doc/flexmi/#including-and-importing-other-flexmi-models","text":"Flexmi supports the <?import other.flexmi?> and <?include other.flexmi?> processing instructions. import creates a new resource for other.flexmi while include parses the contents of other.flexmi as if they were embedded in the Flexmi model that contains the include processing instruction.","title":"Including and Importing other Flexmi Models"},{"location":"doc/flexmi/#instantiating-types-from-multiple-ecore-metamodels","text":"Multiple <?nsuri metamodeluri?> processing instructions can be used in the preamble of a Flexmi model, allowing it to instantiate multiple Ecore metamodels. However, in case of name clashes between them, there's no good way for disambiguation.","title":"Instantiating Types from Multiple Ecore Metamodels"},{"location":"doc/flexmi/#models-with-multiple-root-elements","text":"If you need to have multiple top-level elements in your model, you can add them under a <_> root element, which has no other semantics.","title":"Models with Multiple Root Elements"},{"location":"doc/flexmi/#reusable-templates","text":"Flexmi supports defining reusable templates through the reserved <:template> XML tag. For example, when designing one-person projects where all tasks take place in sequence, we can omit all the repetitive <effort> elements that refer to the same person, and we can automate the calculation of the start date of each task using a simpletask template, as shown below. <?nsuri psl?> <_> <project title= \"ACME\" > <person name= \"Alice\" /> <simpletask title= \"Analysis\" dur= \"3\" /> <simpletask title= \"Design\" dur= \"3\" /> <simpletask title= \"Implementation\" dur= \"6\" /> </project> <:template name= \"simpletask\" > <content> <task :start= \"Task.all.indexOf(self).asVar('index') == 0 ? 1 : Task.all.get(index-1).asVar('previous').start + previous.duration\" > <effort :person= \"Person.all.first()\" /> </task> </content> </:template> </_>","title":"Reusable Templates"},{"location":"doc/flexmi/#parameters","text":"Flexmi templates also support parameters, which can be used to configure the content they produce when they are invoked. An example is shown below: <?nsuri psl?> <_> <project title= \"ACME\" > <person name= \"Alice\" /> <design dur= \"3\" person= \"Alice\" /> </project> <:template name= \"design\" > <parameter name= \"person\" /> <content> <task name= \"Design\" > <effort person= \"${person}\" /> </task> </content> </:template> </_>","title":"Parameters"},{"location":"doc/flexmi/#dynamic-templates-and-slots","text":"To further customise the content that Flexmi templates produce, one can use an EGL template that produces XML as the value of the <content> element of the template, by setting it's language to EGL as shown below. Also Flexmi supports a <:slot> element in the content of templates, which specifies where any nested elements of the caller should be placed in the produced XML as shown below. <?nsuri psl?> <_> <project title= \"ACME\" > <person name= \"Alice\" /> <longtask title= \"Implementation\" years= \"2\" > <effort person= \"Alice\" /> </longtask> </project> <:template name= \"longtask\" > <parameter name= \"years\" /> <content language= \"EGL\" > <![CDATA[ <task duration=\"[%=years.asInteger()*12%]\"> <:slot/> </task> ]]> </content> </:template> </_>","title":"Dynamic Templates and Slots"},{"location":"doc/flexmi/#reusing-templates-in-different-flexmi-models","text":"Templates can be stored in separate Flexmi files and be imported from different models using Flexmi's <?include ?> processing instruction.","title":"Reusing Templates in Different Flexmi Models"},{"location":"doc/flexmi/#use-in-epsilon-and-java","text":"Flexmi offers and registers an implementation of EMF's Resource interface ( FlexmiResource ), and can be used like any other EMF resource implementation. For example, you can add .flexmi models as regular EMF models to the run configuration of your Epsilon program. An example of using Flexmi from Java follows. ResourceSet resourceSet = new ResourceSetImpl (); resourceSet . getResourceFactoryRegistry (). getExtensionToFactoryMap (). put ( \"flexmi\" , new FlexmiResourceFactory ()); Resource resource = resourceSet . createResource ( URI . createFileURI ( \"/../acme.flexmi\" )); resource . load ( null );","title":"Use in Epsilon and Java"},{"location":"doc/flexmi/#converting-to-xmi","text":"You can convert a Flexmi model to standard XMI (with no templates, executable attributes etc.) by right-clicking on it in the Project Explorer view and selecting Generate XMI . Converting an XMI model to Flexmi on the other hand is not supported as there's no unique mapping in this direction.","title":"Converting to XMI"},{"location":"doc/flexmi/#yaml-flavour","text":"Since Epsilon 2.3.0, Flexmi also supports a YAML flavour. Equivalent YAML representations for the XML-based model at the top of this page are shown below. Info The YAML flavour of Flexmi supports all the features of the XML flavour, including plain and dynamic templates , and executable attributes . Also, it is worth noting that YAML is a superset of JSON. Indentation-based ?nsuri : psl project : - name : ACME - person : { name : Alice } - person : { name : Bob } - task : - title : Analysis - start : 1 - dur : 3 - effort : { person : Alice } - task : - title : Design - start : 4 - dur : 6 - effort : { person : Bob } - task : - title : Implementation - start : 7 - dur : 3 - effort : { person : Bob , perc : 50 } - effort : { person : Alice , perc : 50 } Curly brackets-based ?nsuri : psl project : { name : ACME , person : { name : Alice }, person : { name : Bob }, task : { title : Analysis , start : 1 , dur : 3 , effort : { person : Alice } }, task : { title : Design , start : 4 , dur : 6 , effort : { person : Bob } }, task : { title : Implementation , start : 7 , dur : 3 , effort : { person : Bob , perc : 50 }, effort : { person : Alice , perc : 50 } } } For multi-valued attributes and non-containment references, comma-separated values, or lists of scalars can be used as shown below. - ?nsuri : psl - person : - name : Alice - skills : Java, HTML # Comma-separated - person : - name : Bob - skills : # List of scalars - Java - HTML - skill : { name : Java } - skill : { name : HTML } Tabs vs. Spaces If your YAML-flavoured Flexmi model doesn't parse (i.e. the outline view of the Flexmi editor is empty), you may want to check that you have not accidentally used tabs instead of spaces for indentation. The Flexmi parser auto-detects whether a file is XML-based or YAML-based and parses it accordingly. As such, you should be able to edit YAML-flavoured *.flexmi files in the Flexmi editor. Additional examples of YAML-flavoured Flexmi models are available in this test project (look for *.yaml files).","title":"YAML Flavour"},{"location":"doc/flexmi/#dynamic-templates-in-yaml","text":"The YAML flavour requires a script attribute in the content of dynamic templates, that holds the EGL script used to dynamically produce the YAML content. The YAML equivalent of the XML-based dynamic template shown above is as follows. - ?nsuri : psl - project : - title : ACME - person : - name : Alice - longtask : - title : Implementation - years : 2 - effort : - person : Alice - :template : - name : longtask - parameter : - name : years - content : - language : EGL - script : |- # Multi-line EGL script - task: - duration: [%=years.asInteger()*12%] - :slot","title":"Dynamic Templates in YAML"},{"location":"doc/flexmi/#philosophy","text":"Flexmi was originally developed as a quick and dirty way to type in EMF models without having to define an Xtext grammar or adhere to the rigid naming rules of XMI or HUTN. The name is a combination of the word \"flexible\" and the \"XMI\" acronym.","title":"Philosophy"},{"location":"doc/flexmi/#limitations","text":"Flexmi resources can't be saved programmatically (i.e. trying to call resource.save(...) will do nothing). There is no code completion in the Flexmi editor at the moment.","title":"Limitations"},{"location":"doc/flexmi/#resources","text":"More examples of using Flexmi can be found in projects containing flexmi in their name, under the examples folder of Epsilon's Git repository. This article shows how to use Flexmi models in ANT/Gradle/Maven builds Flexmi and relevant underpinning research is further described in the following papers: Towards Flexible Parsing of StructuredTextual Model Representations Towards a Modular and Flexible Human-UsableTextual Syntax for EMF Models Type Inference in Flexible Model-Driven Engineering using Classification Algorithms","title":"Resources"},{"location":"doc/modelink/","text":"Modelink \u00b6 ModeLink is an editor consisting of 2-3 side-by-side EMF tree-based editors, and in combination with the reflective Exeed editor, it is very convenient for establishing links between different models using drag-and-drop. ModeLink uses native EMF cross-resource references to capture links between different models and as such, models constructed with it can be then used by any EMF-compliant tool/language.","title":"Modelink"},{"location":"doc/modelink/#modelink","text":"ModeLink is an editor consisting of 2-3 side-by-side EMF tree-based editors, and in combination with the reflective Exeed editor, it is very convenient for establishing links between different models using drag-and-drop. ModeLink uses native EMF cross-resource references to capture links between different models and as such, models constructed with it can be then used by any EMF-compliant tool/language.","title":"Modelink"},{"location":"doc/picto/","text":"Visualising Models with Picto \u00b6 Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. Compared to existing graphical modelling frameworks such as Sirius and GMF/Eugenia , the main appeal of Picto is that model visualisation takes place in an embedded browser and therefore you can leverage any HTML/SVG/JavaScript-based technology such as D3.js , mxGraph and JointJS . Picto also provides built-in support for the powerful Graphviz and PlantUML textual syntaxes (which are transformed to SVG via the respective tools). A distinguishing feature of Picto is that it does not require running multiple Eclipse instances as the metamodels, models and visualisation transformations can all reside in the same workspace. Tip As Picto uses EGL for model-to-text transformation, it is not limited to EMF-based models and can be used to visualise the contents of Simulink models, XML documents, spreadsheets, and any other type of artefact supported by an Epsilon EMC driver . Citing Picto in a publication? If you are referring to Picto in a publication, please cite this paper instead of the website URL. A pre-print of the paper is available here . On the flip side, Picto displays read-only views of models and as such it is not a good fit if diagram-based model editing capabilities are required. In this article we demonstrate Picto through a small social network example. The complete source code of the example is available here . Metamodel \u00b6 We start with the metamodel of our social network DSL expressed in Emfatic (the .ecore version of the metamodel is also provided in the repository). The DSL allows modelling people in a network and likes/dislikes relationships between them. @namespace(uri=\"socialnetwork\", prefix=\"\") package socialnetwork; class SocialNetwork { val Person[*] people; } class Person { attr String name; ref Person[*] likes; ref Person[*] dislikes; } Model \u00b6 Below is a model that conforms to the social network metamodel. The model is defined for convenience in Flexmi , however Picto also works with XMI-based models (see below). <?nsuri socialnetwork?> <?render-egx picto/socialnetwork.egx?> <socialnetwork> <person name= \"Alice\" likes= \"Bob, Charlie\" /> <person name= \"Bob\" likes= \"Enid, Alice\" dislikes= \"Fred, Charlie\" /> <person name= \"Charlie\" likes= \"Fred, Alice\" dislikes= \"Dawn, Enid\" /> <person name= \"Dawn\" likes= \"Bob\" dislikes= \"Fred\" /> <person name= \"Enid\" likes= \"Charlie\" dislikes= \"Alice\" /> <person name= \"Fred\" dislikes= \"Bob\" likes= \"Enid, Alice\" /> </socialnetwork> In line 2 of the model, notice the render-egx processing instruction, which specifies a model-to-text transformation written in EGX/EGL , that Picto should use to visualise this model. Model-to-Text Transformation \u00b6 The socialnetwork.egx EGX model-to-text transformation is as follows: rule Network2Graphviz transform n : socialnetwork::SocialNetwork { template : \"socialnetwork2graphviz.egl\" parameters : Map{ \"path\" = Sequence{\"Social Network\"}, \"icon\" = \"diagram-ffffff\", \"format\" = \"graphviz-circo\", \"layers\" = Sequence { Map {\"id\"=\"likes\", \"title\"=\"Likes\", \"active\"=true}, Map {\"id\"=\"dislikes\", \"title\"=\"Dislikes\", \"active\"=true} }, \"people\" = n.people } } rule Person2Graphviz transform p : socialnetwork::Person { template : \"socialnetwork2graphviz.egl\" parameters : Map{ \"path\" = Sequence{\"Social Network\", p.name}, \"icon\" = \"diagram-c0c0c0\", \"format\" = \"graphviz-dot\", \"layers\" = Sequence { Map {\"id\"=\"likes\", \"title\"=\"Likes\", \"active\"=true}, Map {\"id\"=\"dislikes\", \"title\"=\"Dislikes\", \"active\"=true} }, \"people\" = Sequence{p} } } The transformation consists of two rules: Network2Graphviz which will be executed once and will produce a Graphviz graph for the entire network Person2Graphviz which will be executed for every person in the network and produce the person's own local likes/dislikes graph Each rule specifies the EGL template that it will invoke ( socialnetwork2graphviz.egl in both cases here) as well as a set of parameters that Picto needs. The parameters are as follows: path : A collection of strings that specify the path of the produced view in the Picto tree icon : The icon of the view on the Picto tree. Allowed values at the moment are file names (without the extension) of all icon files under this folder , as well as diagram-rrggbb values where rrggbb is a hex colour. Additionally, you can extend the available set of icons by populating an icons folder next to the model-to-text transformation file that defines your Picto visualisation (e.g. next to socialnetwork.egx ) format : The format of the view that the EGL transformation will produce. Built-in formats supported in Epsilon 2.4.0 are graphviz-dot , graphviz-circo , graphviz-neato , graphviz-fdp , plantuml , text , html and svg . Epsilon 2.5.0 will add integration with Kroki servers (both public and self-hosted): the Kroki /FORMAT/svg endpoint is available as kroki-FORMAT (e.g. kroki-plantuml , kroki-structurizr , or kroki-mermaid ). layers : A sequence of maps, each of which represents a layer of the view. Each layer needs to define an id , a title and (optionally), whether it is active by default The EGL template socialnetwork2graphviz.egl is as follows: digraph G { node[shape=rectangle, fontname=Tahoma, fontsize=10, style=\"filled\", gradientangle=\"270\", fillcolor=\"bisque\"] edge[penwidth=3, style=tapered, arrowhead=none] [%for (p in people){%] [%=p.name%] [%if (people.size()==1){%][fillcolor=\"azure2\"][%}%] [%if (isLayerActive(\"likes\")){%] [%for (l in p.likes){%] [%=p.name%] -> [%=l.name%] [color=\"#2A6C41\"] [%}%] [%}%] [%if (isLayerActive(\"dislikes\")){%] [%for (l in p.dislikes){%] [%=p.name%] -> [%=l.name%] [color=\"#B43431\"] [%}%] [%}%] [%}%] } [% operation isLayerActive(id : String) { var layer = layers.selectOne(l|l.id = id); if (layer.isDefined()) { return layer.active; } else { return true; } } %] Result \u00b6 Every time socialnetwork.flexmi is saved, Picto will run the EGX/EGL transformation and display the results in a view that consists of a tree viewer and a browser. For this model, Picto produces 7 diagrams; one for the network as a whole through the application of the Network2Graphviz rule and one for each person in the network through the application of the Person2Graphviz rule. Screenshots of the populated Picto view appear below. Layers \u00b6 Picto supports the concept of layers to allow users to show/hide information on a diagram. Both EGX rules specify a \"likes\" and a \"dislikes\" layer (lines 11-12 and 29-30) which the user can turn on/off to show/hide like/dislike relationships in the current diagram. Hiding the \"dislikes\" layer, makes the network-level diagram look like this. Scalability \u00b6 Picto works in a lazy way and initially computes only the details needed to show the tree of views (view paths and icons) on its left-hand side. The content of individual views is computed on demand when a user clicks on a view in the Picto tree. We have used Picto with models and visualisation transformations that produce hundreds of deeply nested views without performance issues. Having said that, as models grow in size, the time it takes the underlying modelling framework (e.g. EMF) to load them into memory and the time it takes EGL to process them are also bound to grow. In such cases, consider fragmenting your models across many files. It is also important to try and do as little work as possible at the EGX level and carry out any expensive computations within the EGL templates instead. When targeting Graphviz or PlantUML it is also advisable to keep your generated diagrams relatively small as auto-layout is computationally expensive (particularly routing edges) and rendering your views can take a long time. For example, generating the Graphviz representation of the full UML metamodel class diagram (260+ classes/650+ references) is instantaneous but getting Graphviz's dot program to render it takes hours. In any event, such a diagram would have been unreadable, and hence pointless (see the 20-class/50-references diagram of Ecore.ecore below, which is generated and rendered instantaneously). To \"protect\" your visualisation rules from input that is bound to generate meaningless output you can use guards as shown below. rule ClassDiagram { guard : EClass.all.size() < 30 parameters : Map { \"classes\" = EClass.all, \"format\" = \"graphviz-dot\", \"path\" = List{\"Model\", \"(All Classes)\"}, \"icon\" = \"diagram-ff0000\" } template: \"ecore2dot.egl\" } In such cases, it is preferable to generate many smaller diagrams; for this example, a class diagram for each class of the metamodel, surrounded by its super/sub/referenced types. Interactive Diagrams \u00b6 Diagrams can also be linked to each other and link back to the models from which they were generated. For example, clicking any of the yellow classes in the diagram below takes you to the respective diagram and clicking on the green EClassifer class, takes you to the class definition in the Ecore editor. This is achieved through two built-in JavaScript functions below, which are showcased here . Signature Description showView(String[] path) Shows the view with the specified path - e.g. top.showView(['Model', 'Classes', 'EClassifier']) showElement(String elementId, String resourceUri) Selects the specified element in its Eclipse-based editor (e.g. the EMF tree-based editor) Multiple Picto Views \u00b6 It is possible to open several Picto views in the same Eclipse workbench, which can be pinned to the same or different model editors. In the image below, the class diagram on the bottom left is pinned to the Social Network metamodel shown in the top left. The three Picto windows on the bottom right contain different views of the social network model shown in the tree editor of the top right. Editors supported by Picto \u00b6 Any editor that implements EMF's IEditingDomainProvider interface (e.g. the reflective Ecore editor, Exeed) as long as next to the edited file there is a file with the same name and a .picto suffix providing the format of the visualisation and the EGL template to be used (see the XMI-based socialnetwork.model and socialnetwork.model.picto files in the example directory) Flexmi editor: as long as the Flexmi model contains a <?render-xxx ?> processing instruction Emfatic editor Default text editor editing files with .html , .svg , .dot , .neato file extensions (mainly for debugging) Extending Picto \u00b6 Picto provides the following extension points that can be used to extend its functionality. Extension Point Description org.eclipse.epsilon.picto.pictoSource Bind Picto to a type of Eclipse-based editors so that Picto auto-refreshes every time a file in an editor of this type is saved org.eclipse.epsilon.picto.browserFunction Add a custom Javascript function that generated diagrams can call (much like the showView and showElement functions above) org.eclipse.epsilon.picto.browserScript Add a Javascript that executes when the Picto browser loads org.eclipse.epsilon.picto.viewContentTransformer Transform a custom content type to HTML, or to a content type that another ViewContentTransformer can transform. See MarkdownContentTransformer as an example. org.eclipse.epsilon.picto.htmlElementTransformer Add support for custom HTML elements to Picto. See PictoViewElementTransformer as an example, which adds a new <picto-view path=\"...\"/> HTML tag to Picto, that supports embedding Picto views within other Picto views . Please see this plugin.xml , which shows how some of these extension points were used to integrate Picto with different technologies, such as PlantUML or Mermaid . Using Picto in standalone mode / with many models \u00b6 Picto also suports a standalone mode, where the details of the models to be visualised are provided within the .picto file itself. An example of visualising socialnetwork.model in standalone mode (without the model being open in a tree editor) is below and in socialnetwork-standalone.picto in the example folder. <?nsuri picto?> <picto format= \"egx\" transformation= \"picto/socialnetwork.egx\" standalone= \"true\" > <model type= \"EMF\" > <parameter name= \"name\" value= \"M\" /> <parameter name= \"metamodelUri\" value= \"socialnetwork\" /> <parameter name= \"modelFile\" file= \"socialnetwork.model\" /> </model> </picto> Troubleshooting \u00b6 If you can't find the Picto view, you will need to upgrade to a version of Epsilon >= 2.0 Graphviz (on which the PlantUML integration also depends) does not ship as part of Picto. You will need to install it manually on your computer. Philosophy \u00b6 While EMF provides support for reflective model instantiation within the same Eclipse workspace, graphical and textual modelling frameworks that sit on top of it such as GMF, Sirius and Xtext involve code generation and/or contributing to Eclipse extension points and hence require spawning a new Eclipse instance. While this inconvenience can pay off for large DSLs, it feels like an overkill when one needs to throw together a small DSL in situ. The original aim of Picto was to complement Flexmi in this respect by contributing model visualisation capabilities where creating a new dedicated graphical editor is considered to be an overkill. Gallery \u00b6 Additional Resources \u00b6 Additional resources about Picto are available here .","title":"Picto"},{"location":"doc/picto/#visualising-models-with-picto","text":"Picto is an Eclipse view for visualising models via model-to-text transformation to SVG/HTML. Compared to existing graphical modelling frameworks such as Sirius and GMF/Eugenia , the main appeal of Picto is that model visualisation takes place in an embedded browser and therefore you can leverage any HTML/SVG/JavaScript-based technology such as D3.js , mxGraph and JointJS . Picto also provides built-in support for the powerful Graphviz and PlantUML textual syntaxes (which are transformed to SVG via the respective tools). A distinguishing feature of Picto is that it does not require running multiple Eclipse instances as the metamodels, models and visualisation transformations can all reside in the same workspace. Tip As Picto uses EGL for model-to-text transformation, it is not limited to EMF-based models and can be used to visualise the contents of Simulink models, XML documents, spreadsheets, and any other type of artefact supported by an Epsilon EMC driver . Citing Picto in a publication? If you are referring to Picto in a publication, please cite this paper instead of the website URL. A pre-print of the paper is available here . On the flip side, Picto displays read-only views of models and as such it is not a good fit if diagram-based model editing capabilities are required. In this article we demonstrate Picto through a small social network example. The complete source code of the example is available here .","title":"Visualising Models with Picto"},{"location":"doc/picto/#metamodel","text":"We start with the metamodel of our social network DSL expressed in Emfatic (the .ecore version of the metamodel is also provided in the repository). The DSL allows modelling people in a network and likes/dislikes relationships between them. @namespace(uri=\"socialnetwork\", prefix=\"\") package socialnetwork; class SocialNetwork { val Person[*] people; } class Person { attr String name; ref Person[*] likes; ref Person[*] dislikes; }","title":"Metamodel"},{"location":"doc/picto/#model","text":"Below is a model that conforms to the social network metamodel. The model is defined for convenience in Flexmi , however Picto also works with XMI-based models (see below). <?nsuri socialnetwork?> <?render-egx picto/socialnetwork.egx?> <socialnetwork> <person name= \"Alice\" likes= \"Bob, Charlie\" /> <person name= \"Bob\" likes= \"Enid, Alice\" dislikes= \"Fred, Charlie\" /> <person name= \"Charlie\" likes= \"Fred, Alice\" dislikes= \"Dawn, Enid\" /> <person name= \"Dawn\" likes= \"Bob\" dislikes= \"Fred\" /> <person name= \"Enid\" likes= \"Charlie\" dislikes= \"Alice\" /> <person name= \"Fred\" dislikes= \"Bob\" likes= \"Enid, Alice\" /> </socialnetwork> In line 2 of the model, notice the render-egx processing instruction, which specifies a model-to-text transformation written in EGX/EGL , that Picto should use to visualise this model.","title":"Model"},{"location":"doc/picto/#model-to-text-transformation","text":"The socialnetwork.egx EGX model-to-text transformation is as follows: rule Network2Graphviz transform n : socialnetwork::SocialNetwork { template : \"socialnetwork2graphviz.egl\" parameters : Map{ \"path\" = Sequence{\"Social Network\"}, \"icon\" = \"diagram-ffffff\", \"format\" = \"graphviz-circo\", \"layers\" = Sequence { Map {\"id\"=\"likes\", \"title\"=\"Likes\", \"active\"=true}, Map {\"id\"=\"dislikes\", \"title\"=\"Dislikes\", \"active\"=true} }, \"people\" = n.people } } rule Person2Graphviz transform p : socialnetwork::Person { template : \"socialnetwork2graphviz.egl\" parameters : Map{ \"path\" = Sequence{\"Social Network\", p.name}, \"icon\" = \"diagram-c0c0c0\", \"format\" = \"graphviz-dot\", \"layers\" = Sequence { Map {\"id\"=\"likes\", \"title\"=\"Likes\", \"active\"=true}, Map {\"id\"=\"dislikes\", \"title\"=\"Dislikes\", \"active\"=true} }, \"people\" = Sequence{p} } } The transformation consists of two rules: Network2Graphviz which will be executed once and will produce a Graphviz graph for the entire network Person2Graphviz which will be executed for every person in the network and produce the person's own local likes/dislikes graph Each rule specifies the EGL template that it will invoke ( socialnetwork2graphviz.egl in both cases here) as well as a set of parameters that Picto needs. The parameters are as follows: path : A collection of strings that specify the path of the produced view in the Picto tree icon : The icon of the view on the Picto tree. Allowed values at the moment are file names (without the extension) of all icon files under this folder , as well as diagram-rrggbb values where rrggbb is a hex colour. Additionally, you can extend the available set of icons by populating an icons folder next to the model-to-text transformation file that defines your Picto visualisation (e.g. next to socialnetwork.egx ) format : The format of the view that the EGL transformation will produce. Built-in formats supported in Epsilon 2.4.0 are graphviz-dot , graphviz-circo , graphviz-neato , graphviz-fdp , plantuml , text , html and svg . Epsilon 2.5.0 will add integration with Kroki servers (both public and self-hosted): the Kroki /FORMAT/svg endpoint is available as kroki-FORMAT (e.g. kroki-plantuml , kroki-structurizr , or kroki-mermaid ). layers : A sequence of maps, each of which represents a layer of the view. Each layer needs to define an id , a title and (optionally), whether it is active by default The EGL template socialnetwork2graphviz.egl is as follows: digraph G { node[shape=rectangle, fontname=Tahoma, fontsize=10, style=\"filled\", gradientangle=\"270\", fillcolor=\"bisque\"] edge[penwidth=3, style=tapered, arrowhead=none] [%for (p in people){%] [%=p.name%] [%if (people.size()==1){%][fillcolor=\"azure2\"][%}%] [%if (isLayerActive(\"likes\")){%] [%for (l in p.likes){%] [%=p.name%] -> [%=l.name%] [color=\"#2A6C41\"] [%}%] [%}%] [%if (isLayerActive(\"dislikes\")){%] [%for (l in p.dislikes){%] [%=p.name%] -> [%=l.name%] [color=\"#B43431\"] [%}%] [%}%] [%}%] } [% operation isLayerActive(id : String) { var layer = layers.selectOne(l|l.id = id); if (layer.isDefined()) { return layer.active; } else { return true; } } %]","title":"Model-to-Text Transformation"},{"location":"doc/picto/#result","text":"Every time socialnetwork.flexmi is saved, Picto will run the EGX/EGL transformation and display the results in a view that consists of a tree viewer and a browser. For this model, Picto produces 7 diagrams; one for the network as a whole through the application of the Network2Graphviz rule and one for each person in the network through the application of the Person2Graphviz rule. Screenshots of the populated Picto view appear below.","title":"Result"},{"location":"doc/picto/#layers","text":"Picto supports the concept of layers to allow users to show/hide information on a diagram. Both EGX rules specify a \"likes\" and a \"dislikes\" layer (lines 11-12 and 29-30) which the user can turn on/off to show/hide like/dislike relationships in the current diagram. Hiding the \"dislikes\" layer, makes the network-level diagram look like this.","title":"Layers"},{"location":"doc/picto/#scalability","text":"Picto works in a lazy way and initially computes only the details needed to show the tree of views (view paths and icons) on its left-hand side. The content of individual views is computed on demand when a user clicks on a view in the Picto tree. We have used Picto with models and visualisation transformations that produce hundreds of deeply nested views without performance issues. Having said that, as models grow in size, the time it takes the underlying modelling framework (e.g. EMF) to load them into memory and the time it takes EGL to process them are also bound to grow. In such cases, consider fragmenting your models across many files. It is also important to try and do as little work as possible at the EGX level and carry out any expensive computations within the EGL templates instead. When targeting Graphviz or PlantUML it is also advisable to keep your generated diagrams relatively small as auto-layout is computationally expensive (particularly routing edges) and rendering your views can take a long time. For example, generating the Graphviz representation of the full UML metamodel class diagram (260+ classes/650+ references) is instantaneous but getting Graphviz's dot program to render it takes hours. In any event, such a diagram would have been unreadable, and hence pointless (see the 20-class/50-references diagram of Ecore.ecore below, which is generated and rendered instantaneously). To \"protect\" your visualisation rules from input that is bound to generate meaningless output you can use guards as shown below. rule ClassDiagram { guard : EClass.all.size() < 30 parameters : Map { \"classes\" = EClass.all, \"format\" = \"graphviz-dot\", \"path\" = List{\"Model\", \"(All Classes)\"}, \"icon\" = \"diagram-ff0000\" } template: \"ecore2dot.egl\" } In such cases, it is preferable to generate many smaller diagrams; for this example, a class diagram for each class of the metamodel, surrounded by its super/sub/referenced types.","title":"Scalability"},{"location":"doc/picto/#interactive-diagrams","text":"Diagrams can also be linked to each other and link back to the models from which they were generated. For example, clicking any of the yellow classes in the diagram below takes you to the respective diagram and clicking on the green EClassifer class, takes you to the class definition in the Ecore editor. This is achieved through two built-in JavaScript functions below, which are showcased here . Signature Description showView(String[] path) Shows the view with the specified path - e.g. top.showView(['Model', 'Classes', 'EClassifier']) showElement(String elementId, String resourceUri) Selects the specified element in its Eclipse-based editor (e.g. the EMF tree-based editor)","title":"Interactive Diagrams"},{"location":"doc/picto/#multiple-picto-views","text":"It is possible to open several Picto views in the same Eclipse workbench, which can be pinned to the same or different model editors. In the image below, the class diagram on the bottom left is pinned to the Social Network metamodel shown in the top left. The three Picto windows on the bottom right contain different views of the social network model shown in the tree editor of the top right.","title":"Multiple Picto Views"},{"location":"doc/picto/#editors-supported-by-picto","text":"Any editor that implements EMF's IEditingDomainProvider interface (e.g. the reflective Ecore editor, Exeed) as long as next to the edited file there is a file with the same name and a .picto suffix providing the format of the visualisation and the EGL template to be used (see the XMI-based socialnetwork.model and socialnetwork.model.picto files in the example directory) Flexmi editor: as long as the Flexmi model contains a <?render-xxx ?> processing instruction Emfatic editor Default text editor editing files with .html , .svg , .dot , .neato file extensions (mainly for debugging)","title":"Editors supported by Picto"},{"location":"doc/picto/#extending-picto","text":"Picto provides the following extension points that can be used to extend its functionality. Extension Point Description org.eclipse.epsilon.picto.pictoSource Bind Picto to a type of Eclipse-based editors so that Picto auto-refreshes every time a file in an editor of this type is saved org.eclipse.epsilon.picto.browserFunction Add a custom Javascript function that generated diagrams can call (much like the showView and showElement functions above) org.eclipse.epsilon.picto.browserScript Add a Javascript that executes when the Picto browser loads org.eclipse.epsilon.picto.viewContentTransformer Transform a custom content type to HTML, or to a content type that another ViewContentTransformer can transform. See MarkdownContentTransformer as an example. org.eclipse.epsilon.picto.htmlElementTransformer Add support for custom HTML elements to Picto. See PictoViewElementTransformer as an example, which adds a new <picto-view path=\"...\"/> HTML tag to Picto, that supports embedding Picto views within other Picto views . Please see this plugin.xml , which shows how some of these extension points were used to integrate Picto with different technologies, such as PlantUML or Mermaid .","title":"Extending Picto"},{"location":"doc/picto/#using-picto-in-standalone-mode-with-many-models","text":"Picto also suports a standalone mode, where the details of the models to be visualised are provided within the .picto file itself. An example of visualising socialnetwork.model in standalone mode (without the model being open in a tree editor) is below and in socialnetwork-standalone.picto in the example folder. <?nsuri picto?> <picto format= \"egx\" transformation= \"picto/socialnetwork.egx\" standalone= \"true\" > <model type= \"EMF\" > <parameter name= \"name\" value= \"M\" /> <parameter name= \"metamodelUri\" value= \"socialnetwork\" /> <parameter name= \"modelFile\" file= \"socialnetwork.model\" /> </model> </picto>","title":"Using Picto in standalone mode / with many models"},{"location":"doc/picto/#troubleshooting","text":"If you can't find the Picto view, you will need to upgrade to a version of Epsilon >= 2.0 Graphviz (on which the PlantUML integration also depends) does not ship as part of Picto. You will need to install it manually on your computer.","title":"Troubleshooting"},{"location":"doc/picto/#philosophy","text":"While EMF provides support for reflective model instantiation within the same Eclipse workspace, graphical and textual modelling frameworks that sit on top of it such as GMF, Sirius and Xtext involve code generation and/or contributing to Eclipse extension points and hence require spawning a new Eclipse instance. While this inconvenience can pay off for large DSLs, it feels like an overkill when one needs to throw together a small DSL in situ. The original aim of Picto was to complement Flexmi in this respect by contributing model visualisation capabilities where creating a new dedicated graphical editor is considered to be an overkill.","title":"Philosophy"},{"location":"doc/picto/#gallery","text":"","title":"Gallery"},{"location":"doc/picto/#additional-resources","text":"Additional resources about Picto are available here .","title":"Additional Resources"},{"location":"doc/pinset/","text":"Dataset Extraction (Pinset) \u00b6 The Pinset language offers specific syntax constructs to extract table-like datasets from models . The main objective of Pinset is to facilitate the analysis of models data via conventional data mining and machine learning techniques, which impose a tabular input format. In addition, tables can be useful as an extra viewpoint when creating model visualisations. Model example \u00b6 We use as running example a course model, which contains the enrolled students along with their grades. All models and Pinset scripts shown in this documentation can be found in an example project in the Epsilon repository. All Pinset scripts query the following metamodel: classDiagram class Course { name: String } class Student { ID: String name: String isRemote: Boolean } class ContactDetails { email: String phone: String } class EvaluationItem { name: String percentage: int } class Grade { points: int } Course *--> Student: students * Course *--> EvaluationItem: items * Student *--> ContactDetails: contact Student *--> Grade: grades * Grade --> EvaluationItem: item As for the data shown as a result of the Pinset scripts, we use the following Flexmi model, which conforms to the metamodel above: <?nsuri grades?> <course name= \"Model-Driven Engineering\" > <item name= \"Lab 1\" perc= \"15\" /> <item name= \"Lab 2\" perc= \"15\" /> <item name= \"Partial Test\" perc= \"20\" /> <item name= \"Final Exam\" perc= \"50\" /> <student id= \"S1\" name= \"Alice\" > <contact email= \"alice@university.com\" phone= \"+44 101\" /> <grade item= \"Lab 1\" points= \"60\" /> <grade item= \"Lab 2\" points= \"90\" /> <grade item= \"Partial Test\" points= \"80\" /> <grade item= \"Final Exam\" points= \"85\" /> </student> <student id= \"S2\" name= \"Bob\" remote= \"true\" > <contact email= \"bob@university.com\" phone= \"+44 654\" /> <grade item= \"Lab 1\" points= \"60\" /> <grade item= \"Final Exam\" points= \"100\" /> </student> <student id= \"S3\" name= \"Charlie\" remote= \"true\" > <contact email= \"charlie@university.com\" phone= \"+44 333\" /> <grade item= \"Lab 1\" points= \"50\" /> <grade item= \"Lab 2\" points= \"35\" /> <grade item= \"Partial Test\" points= \"20\" /> </student> <student id= \"S4\" name= \"Dana\" > <contact email= \"dana@university.com\" /> <grade item= \"Lab 1\" points= \"100\" /> <grade item= \"Lab 2\" points= \"90\" /> <grade item= \"Partial Test\" points= \"70\" /> <grade item= \"Final Exam\" points= \"95\" /> </student> </course> Overview \u00b6 This first Pinset example defines a dataset from students data, containing some basic information such as name and student ID, contact details, the number of completed evaluation items, and the final grade for the course: dataset studentsSummary over s : Student { column id: s.ID column name: s.name column phone: s.contact.phone column items_completed: s.grades.size column final_grade : s.getFinalGrade() column course_outcome { if (final_grade < 50) { return \"fail\"; } else if (final_grade < 70) { return \"good\"; } else if (final_grade < 90) { return \"notable\"; } else { return \"excellent\"; } } } @cached operation Student getFinalGrade() { return self.grades .collect(g | g.points * g.item.percentage) .sum() / 100; } From that Pinset script, the following dataset is generated: id name phone items_completed final_grade course_outcome S1 Alice +44 101 4 81 notable S2 Bob +44 654 2 59 good S3 Charlie +44 333 3 16 fail S4 Dana 4 90 excellent As the above example shows, Pinset offers a rule-based syntax to declare datasets. These rules are specified as a set of column generators that capture data from instances of a type included in an input model. That type is defined as a parameter, after the over keyword. In the example, the chosen type is Student , which by default means that each Student instance of the input model will be used to populate a row of the output dataset. Pinset offers different column generators. This first example uses the column one, which is composed of the name of the column header and an EOL expression to calculate the cell value over the row element. Other common EOL constructs are also available in Pinset scripts. For instance, an EOL block can be used for those column calculations that might be better organised in an imperative set of statements, such as the course_outcome column that shows the final course result in a textual format as used in the Spanish education system. In addition, external operations can be invoked in the column expressions, such as the getFinalGrade() operation used in the example. As a last comment for the column generator, values of previously calculated columns of an element can be used in subsequent definitions. For instance, the course_outcome column uses the finalGrade After this overview, next sections describe extra column generators, as well as on other functionalities offered by Pinset for an easier dataset extraction specification. Properties accessors \u00b6 As a way to facilitate the definition of columns that simply hold element properties, Pinset offers some column generators to access these properties: dataset studentsContact over s : Student { properties [ID as StudentId, name] reference contact[email, phone] } The previous dataset rule results in: StudentId name contact_email contact_phone S1 Alice alice@university.com +44 101 S2 Bob bob@university.com +44 654 S3 Charlie charlie@university.com +44 333 S4 Dana dana@university.com Precisely, Pinset offers two property accessors: the properties generator can be used to generate columns for attributes of the selected type (e.g. ID and name in the example), while the references one allows getting attributes from single references (i.e. upper bound of 1) of the type, such as contact . When using the properties accessor, the name of the attribute is used as column name, while for the references accessor a combination of the name of the reference with the name of the attribute is used (e.g. contact_phone ). This default behaviour can be altered by using the as keyword. These accessors also offer null safety. If any attributes or the traversed reference point to null, Pinset automatically inserts a blank value in the cell. Row filtering \u00b6 By default, all elements of the selected type are processed into rows. As this might sometimes not be desired, Pinset offers some ways to filter out rows from the resulting dataset: dataset remoteStudents over s : Student { guard: s.isRemote properties[ID, name] } dataset finalExamAssistants over s : Student from : Student.all.select(s | s.grades.exists(g | g.item.name == \"Final Exam\")) { properties[ID, name] } These dataset rules show the two ways that can be used to perform filtering in Pinset: The remoteStudents dataset uses a guard to limit the processed students to the remote ones (based in their boolean attribute). Any element not meeting the guard requirements is excluded from the dataset generation step. The finalExamAssistants dataset uses a from expression to only include those students that took the final exam of the course. A from expression must return a collection of elements of the selected type to be used for the dataset generation. Therefore, this expression can be used for row filtering, and for other things such as performance improvements (i.e. calculate a collection, and use it for multiple dataset generations). If necessary, both filtering mechanisms can be used simultaneously. For instance, if we combine the guard and from expressions shown above, we would obtain a dataset with the remote students that took the final exam of the course. Multiple columns: grid \u00b6 In some cases, we might want to generate a set of columns that are calculated using the same expression, just by changing the parameter(s) of such expression. In the course example, this happens when generating a table including the detailed grades of the students for all the evaluated items of the course, such as the following: ID name Lab_1 Lab_2 Partial_Test Final_Exam final_grade S1 Alice 60 90 80 85 81 S2 Bob 60 100 59 S3 Charlie 50 35 20 16 S4 Dana 100 90 70 95 90 Defining this table with the column generator would quickly become very verbose and tedious, as we would need to use one expression for each evaluated item of the course. Also, using that strategy would match the Pinset script to the specific course, as the script would include the name of the grades that are being represented as columns. Any new item added to future editions of the course, or any new course we might want to suport, would require updating the Pinset script / creating a new one. To prevent this, Pinset offers the grid generator, which allows the batch-definition of similar columns. A grid has three components: keys : determine the elements to use as seeds or parameters of each column. header : used to create the name or header of the column, based on the value of each individual key . body : used to calculate the value of each cell of the column. Generally, both the row element and the grid key intervene here. This generator is used in the following dataset rule, which generates the grades table depicted above: dataset studentGrades over s : Student { properties[ID, name] grid { keys: EvaluationItem.all header: key.name body: s.grades.selectOne(g | g.item == key)?.points } column final_grade : s.getFinalGrade() } In that grid generator, the course evaluation items are used as keys , which means that each one of these items would be evaluated over the header and body expressions to generate a new column. The header of the columns uses the item name, and the body is calculated by looking for a grade of the student for the evaluation item. The body uses the ?. safe null navigation operator in case the student does not have a grade for certain item. Typeless dataset rules \u00b6 The from expression presented above to filter rows during the generation can be also used to define datasets where the row elements are not instances coming from an input model. This can be useful to perform data aggregations, or to generate synthetic tables starting from a custom collection of values. The following dataset rule generates a basic table using a sequence of numbers as row elements and different column generators: dataset numbers over n from : 1.to(5) { column number : n column squared : n * n grid { keys: 2.to(5) header: \"times_\" + key body: n * key } } number squared times_2 times_3 times_4 times_5 1 1 2 3 4 5 2 4 4 6 8 10 3 9 6 9 12 15 4 16 8 12 16 20 5 25 10 15 20 25 Nested column generators \u00b6 When certain intermediate value has to be used in several column calculations, Pinset offers a nested, composite column generator. This generator is defined by a from expression that calculates a value, followed by a block containing column generators that can use that value: dataset gradesDetails over g : Grade { properties[points] reference item[name] from student : g.eContainer { column id : student.ID column final_grade : student.getFinalGrade() column grade_lowerthan_final : g.points < final_grade } } The rule above generates a dataset with one row per grade in the course. The rule includes a from expression, which obtains the student that obtained the grade through the containment reference. Then, it is used to obtain the student id and final grade, and an extra column that determines whether a grade contributed negatively to the final grade of the student, by checking if it has less points than the final grade. The names of the nested column generators are prefixed with the name given to the object calculated by the from expression: points item_name student_id student_final_grade student_grade_lowerthan_final 60 Lab 1 S1 81 true 90 Lab 2 S1 81 false 80 Partial Test S1 81 true 85 Final Exam S1 81 false 60 Lab 1 S2 59 false 100 Final Exam S2 59 false 50 Lab 1 S3 16 false 35 Lab 2 S3 16 false 20 Partial Test S3 16 false 100 Lab 1 S4 90 false 90 Lab 2 S4 90 false 70 Partial Test S4 90 true 95 Final Exam S4 90 false Column post-processing \u00b6 Pinset offers some column post-processing operations that are frequently used to prepare a dataset for an analysis. These operations are invoked by annotating the column generators. dataset studentGradesPostProcessed over s : Student { properties[ID] @fillNulls 0 grid { keys: EvaluationItem.all header: key.name body: s.grades.selectOne(g | g.item == key)?.points } column final_grade : s.getFinalGrade() @normalize 100 column final_grade_normalized : final_grade } ID Lab_1 Lab_2 Partial_Test Final_Exam final_grade final_grade_normalized S1 60 90 80 85 81 0.81 S2 60 0 0 100 59 0.59 S3 50 35 20 0 16 0.16 S4 100 90 70 95 90 0.9 Fill nulls \u00b6 It is possible to @fillNulls with a custom value, or with a special and sometimes used value, such as the mean or the mode of the column values. The following dataset rule By annotating the grid in the detailed grades example, we can fill with zeros those cells where a student did not took an evaluation item. Normalisation \u00b6 We can @normalize data columns between the [0,1] interval (useful when applying distance-based algorithms with numeric columns in different scales). A value can be provided to the annotation to perform the normalisation. If no value is given, the maximum value encountered in the column is used instead. The dataset rule above contains a column with the normalised final grade of the course. Picto Integration \u00b6 Check out this article to learn how Pinset can be used to generate Picto table visualisations.","title":"Dataset Extraction (Pinset)"},{"location":"doc/pinset/#dataset-extraction-pinset","text":"The Pinset language offers specific syntax constructs to extract table-like datasets from models . The main objective of Pinset is to facilitate the analysis of models data via conventional data mining and machine learning techniques, which impose a tabular input format. In addition, tables can be useful as an extra viewpoint when creating model visualisations.","title":"Dataset Extraction (Pinset)"},{"location":"doc/pinset/#model-example","text":"We use as running example a course model, which contains the enrolled students along with their grades. All models and Pinset scripts shown in this documentation can be found in an example project in the Epsilon repository. All Pinset scripts query the following metamodel: classDiagram class Course { name: String } class Student { ID: String name: String isRemote: Boolean } class ContactDetails { email: String phone: String } class EvaluationItem { name: String percentage: int } class Grade { points: int } Course *--> Student: students * Course *--> EvaluationItem: items * Student *--> ContactDetails: contact Student *--> Grade: grades * Grade --> EvaluationItem: item As for the data shown as a result of the Pinset scripts, we use the following Flexmi model, which conforms to the metamodel above: <?nsuri grades?> <course name= \"Model-Driven Engineering\" > <item name= \"Lab 1\" perc= \"15\" /> <item name= \"Lab 2\" perc= \"15\" /> <item name= \"Partial Test\" perc= \"20\" /> <item name= \"Final Exam\" perc= \"50\" /> <student id= \"S1\" name= \"Alice\" > <contact email= \"alice@university.com\" phone= \"+44 101\" /> <grade item= \"Lab 1\" points= \"60\" /> <grade item= \"Lab 2\" points= \"90\" /> <grade item= \"Partial Test\" points= \"80\" /> <grade item= \"Final Exam\" points= \"85\" /> </student> <student id= \"S2\" name= \"Bob\" remote= \"true\" > <contact email= \"bob@university.com\" phone= \"+44 654\" /> <grade item= \"Lab 1\" points= \"60\" /> <grade item= \"Final Exam\" points= \"100\" /> </student> <student id= \"S3\" name= \"Charlie\" remote= \"true\" > <contact email= \"charlie@university.com\" phone= \"+44 333\" /> <grade item= \"Lab 1\" points= \"50\" /> <grade item= \"Lab 2\" points= \"35\" /> <grade item= \"Partial Test\" points= \"20\" /> </student> <student id= \"S4\" name= \"Dana\" > <contact email= \"dana@university.com\" /> <grade item= \"Lab 1\" points= \"100\" /> <grade item= \"Lab 2\" points= \"90\" /> <grade item= \"Partial Test\" points= \"70\" /> <grade item= \"Final Exam\" points= \"95\" /> </student> </course>","title":"Model example"},{"location":"doc/pinset/#overview","text":"This first Pinset example defines a dataset from students data, containing some basic information such as name and student ID, contact details, the number of completed evaluation items, and the final grade for the course: dataset studentsSummary over s : Student { column id: s.ID column name: s.name column phone: s.contact.phone column items_completed: s.grades.size column final_grade : s.getFinalGrade() column course_outcome { if (final_grade < 50) { return \"fail\"; } else if (final_grade < 70) { return \"good\"; } else if (final_grade < 90) { return \"notable\"; } else { return \"excellent\"; } } } @cached operation Student getFinalGrade() { return self.grades .collect(g | g.points * g.item.percentage) .sum() / 100; } From that Pinset script, the following dataset is generated: id name phone items_completed final_grade course_outcome S1 Alice +44 101 4 81 notable S2 Bob +44 654 2 59 good S3 Charlie +44 333 3 16 fail S4 Dana 4 90 excellent As the above example shows, Pinset offers a rule-based syntax to declare datasets. These rules are specified as a set of column generators that capture data from instances of a type included in an input model. That type is defined as a parameter, after the over keyword. In the example, the chosen type is Student , which by default means that each Student instance of the input model will be used to populate a row of the output dataset. Pinset offers different column generators. This first example uses the column one, which is composed of the name of the column header and an EOL expression to calculate the cell value over the row element. Other common EOL constructs are also available in Pinset scripts. For instance, an EOL block can be used for those column calculations that might be better organised in an imperative set of statements, such as the course_outcome column that shows the final course result in a textual format as used in the Spanish education system. In addition, external operations can be invoked in the column expressions, such as the getFinalGrade() operation used in the example. As a last comment for the column generator, values of previously calculated columns of an element can be used in subsequent definitions. For instance, the course_outcome column uses the finalGrade After this overview, next sections describe extra column generators, as well as on other functionalities offered by Pinset for an easier dataset extraction specification.","title":"Overview"},{"location":"doc/pinset/#properties-accessors","text":"As a way to facilitate the definition of columns that simply hold element properties, Pinset offers some column generators to access these properties: dataset studentsContact over s : Student { properties [ID as StudentId, name] reference contact[email, phone] } The previous dataset rule results in: StudentId name contact_email contact_phone S1 Alice alice@university.com +44 101 S2 Bob bob@university.com +44 654 S3 Charlie charlie@university.com +44 333 S4 Dana dana@university.com Precisely, Pinset offers two property accessors: the properties generator can be used to generate columns for attributes of the selected type (e.g. ID and name in the example), while the references one allows getting attributes from single references (i.e. upper bound of 1) of the type, such as contact . When using the properties accessor, the name of the attribute is used as column name, while for the references accessor a combination of the name of the reference with the name of the attribute is used (e.g. contact_phone ). This default behaviour can be altered by using the as keyword. These accessors also offer null safety. If any attributes or the traversed reference point to null, Pinset automatically inserts a blank value in the cell.","title":"Properties accessors"},{"location":"doc/pinset/#row-filtering","text":"By default, all elements of the selected type are processed into rows. As this might sometimes not be desired, Pinset offers some ways to filter out rows from the resulting dataset: dataset remoteStudents over s : Student { guard: s.isRemote properties[ID, name] } dataset finalExamAssistants over s : Student from : Student.all.select(s | s.grades.exists(g | g.item.name == \"Final Exam\")) { properties[ID, name] } These dataset rules show the two ways that can be used to perform filtering in Pinset: The remoteStudents dataset uses a guard to limit the processed students to the remote ones (based in their boolean attribute). Any element not meeting the guard requirements is excluded from the dataset generation step. The finalExamAssistants dataset uses a from expression to only include those students that took the final exam of the course. A from expression must return a collection of elements of the selected type to be used for the dataset generation. Therefore, this expression can be used for row filtering, and for other things such as performance improvements (i.e. calculate a collection, and use it for multiple dataset generations). If necessary, both filtering mechanisms can be used simultaneously. For instance, if we combine the guard and from expressions shown above, we would obtain a dataset with the remote students that took the final exam of the course.","title":"Row filtering"},{"location":"doc/pinset/#multiple-columns-grid","text":"In some cases, we might want to generate a set of columns that are calculated using the same expression, just by changing the parameter(s) of such expression. In the course example, this happens when generating a table including the detailed grades of the students for all the evaluated items of the course, such as the following: ID name Lab_1 Lab_2 Partial_Test Final_Exam final_grade S1 Alice 60 90 80 85 81 S2 Bob 60 100 59 S3 Charlie 50 35 20 16 S4 Dana 100 90 70 95 90 Defining this table with the column generator would quickly become very verbose and tedious, as we would need to use one expression for each evaluated item of the course. Also, using that strategy would match the Pinset script to the specific course, as the script would include the name of the grades that are being represented as columns. Any new item added to future editions of the course, or any new course we might want to suport, would require updating the Pinset script / creating a new one. To prevent this, Pinset offers the grid generator, which allows the batch-definition of similar columns. A grid has three components: keys : determine the elements to use as seeds or parameters of each column. header : used to create the name or header of the column, based on the value of each individual key . body : used to calculate the value of each cell of the column. Generally, both the row element and the grid key intervene here. This generator is used in the following dataset rule, which generates the grades table depicted above: dataset studentGrades over s : Student { properties[ID, name] grid { keys: EvaluationItem.all header: key.name body: s.grades.selectOne(g | g.item == key)?.points } column final_grade : s.getFinalGrade() } In that grid generator, the course evaluation items are used as keys , which means that each one of these items would be evaluated over the header and body expressions to generate a new column. The header of the columns uses the item name, and the body is calculated by looking for a grade of the student for the evaluation item. The body uses the ?. safe null navigation operator in case the student does not have a grade for certain item.","title":"Multiple columns: grid"},{"location":"doc/pinset/#typeless-dataset-rules","text":"The from expression presented above to filter rows during the generation can be also used to define datasets where the row elements are not instances coming from an input model. This can be useful to perform data aggregations, or to generate synthetic tables starting from a custom collection of values. The following dataset rule generates a basic table using a sequence of numbers as row elements and different column generators: dataset numbers over n from : 1.to(5) { column number : n column squared : n * n grid { keys: 2.to(5) header: \"times_\" + key body: n * key } } number squared times_2 times_3 times_4 times_5 1 1 2 3 4 5 2 4 4 6 8 10 3 9 6 9 12 15 4 16 8 12 16 20 5 25 10 15 20 25","title":"Typeless dataset rules"},{"location":"doc/pinset/#nested-column-generators","text":"When certain intermediate value has to be used in several column calculations, Pinset offers a nested, composite column generator. This generator is defined by a from expression that calculates a value, followed by a block containing column generators that can use that value: dataset gradesDetails over g : Grade { properties[points] reference item[name] from student : g.eContainer { column id : student.ID column final_grade : student.getFinalGrade() column grade_lowerthan_final : g.points < final_grade } } The rule above generates a dataset with one row per grade in the course. The rule includes a from expression, which obtains the student that obtained the grade through the containment reference. Then, it is used to obtain the student id and final grade, and an extra column that determines whether a grade contributed negatively to the final grade of the student, by checking if it has less points than the final grade. The names of the nested column generators are prefixed with the name given to the object calculated by the from expression: points item_name student_id student_final_grade student_grade_lowerthan_final 60 Lab 1 S1 81 true 90 Lab 2 S1 81 false 80 Partial Test S1 81 true 85 Final Exam S1 81 false 60 Lab 1 S2 59 false 100 Final Exam S2 59 false 50 Lab 1 S3 16 false 35 Lab 2 S3 16 false 20 Partial Test S3 16 false 100 Lab 1 S4 90 false 90 Lab 2 S4 90 false 70 Partial Test S4 90 true 95 Final Exam S4 90 false","title":"Nested column generators"},{"location":"doc/pinset/#column-post-processing","text":"Pinset offers some column post-processing operations that are frequently used to prepare a dataset for an analysis. These operations are invoked by annotating the column generators. dataset studentGradesPostProcessed over s : Student { properties[ID] @fillNulls 0 grid { keys: EvaluationItem.all header: key.name body: s.grades.selectOne(g | g.item == key)?.points } column final_grade : s.getFinalGrade() @normalize 100 column final_grade_normalized : final_grade } ID Lab_1 Lab_2 Partial_Test Final_Exam final_grade final_grade_normalized S1 60 90 80 85 81 0.81 S2 60 0 0 100 59 0.59 S3 50 35 20 0 16 0.16 S4 100 90 70 95 90 0.9","title":"Column post-processing"},{"location":"doc/pinset/#fill-nulls","text":"It is possible to @fillNulls with a custom value, or with a special and sometimes used value, such as the mean or the mode of the column values. The following dataset rule By annotating the grid in the detailed grades example, we can fill with zeros those cells where a student did not took an evaluation item.","title":"Fill nulls"},{"location":"doc/pinset/#normalisation","text":"We can @normalize data columns between the [0,1] interval (useful when applying distance-based algorithms with numeric columns in different scales). A value can be provided to the annotation to perform the normalisation. If no value is given, the maximum value encountered in the column is used instead. The dataset rule above contains a column with the normalised final grade of the course.","title":"Normalisation"},{"location":"doc/pinset/#picto-integration","text":"Check out this article to learn how Pinset can be used to generate Picto table visualisations.","title":"Picto Integration"},{"location":"download/","text":"Download \u00b6 The simplest way to get a copy of Eclipse with Epsilon 2.4 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Architecture Eclipse Installer Windows x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Mac AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac-aarch64.dmg Linux x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Linux AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux-aarch64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product. Update Sites \u00b6 Alternatively, you can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Warning Please note that updates in recent (2022) versions of Eclipse have broken Eugenia . If you need to install Eugenia, please use an older version of Eclipse. Site Location Stable http://download.eclipse.org/epsilon/updates/2.4/ Interim http://download.eclipse.org/epsilon/interim/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . How often is the interim update site rebuilt? The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here Archived Update Sites \u00b6 Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.4/epsilon-2.4-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip Eclipse Marketplace \u00b6 If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop into a running instance of Eclipse. Source Code \u00b6 The source code of Epsilon is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.4 Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs . Maven \u00b6 Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.4.0 </version> </dependency> </dependencies> To use the latest SNAPSHOT (interim) version of Epsilon, you should add the Sonatype snapshots repository to your pom.xml and set the version of the Epsilon libraries to 2.5.0-SNAPSHOT as shown below. <repositories> <repository> <id> ossrh </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.5.0-SNAPSHOT </version> </dependency> </dependencies> Older versions \u00b6 Previous stable versions of Epsilon are available here . This website \u00b6 This article demonstrates how to download and manage the Epsilon website in your machine.","title":"Download"},{"location":"download/#download","text":"The simplest way to get a copy of Eclipse with Epsilon 2.4 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Architecture Eclipse Installer Windows x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Mac AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac-aarch64.dmg Linux x86_64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Linux AArch64 http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux-aarch64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.","title":"Download"},{"location":"download/#update-sites","text":"Alternatively, you can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Warning Please note that updates in recent (2022) versions of Eclipse have broken Eugenia . If you need to install Eugenia, please use an older version of Eclipse. Site Location Stable http://download.eclipse.org/epsilon/updates/2.4/ Interim http://download.eclipse.org/epsilon/interim/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . How often is the interim update site rebuilt? The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here","title":"Update Sites"},{"location":"download/#archived-update-sites","text":"Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.4/epsilon-2.4-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip","title":"Archived Update Sites"},{"location":"download/#eclipse-marketplace","text":"If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop into a running instance of Eclipse.","title":"Eclipse Marketplace"},{"location":"download/#source-code","text":"The source code of Epsilon is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.4 Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs .","title":"Source Code "},{"location":"download/#maven","text":"Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.4.0 </version> </dependency> </dependencies> To use the latest SNAPSHOT (interim) version of Epsilon, you should add the Sonatype snapshots repository to your pom.xml and set the version of the Epsilon libraries to 2.5.0-SNAPSHOT as shown below. <repositories> <repository> <id> ossrh </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.5.0-SNAPSHOT </version> </dependency> </dependencies>","title":"Maven"},{"location":"download/#older-versions","text":"Previous stable versions of Epsilon are available here .","title":"Older versions"},{"location":"download/#this-website","text":"This article demonstrates how to download and manage the Epsilon website in your machine.","title":"This website"},{"location":"download/1.x/","text":"Epsilon 1.x \u00b6 img { box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } Distributions \u00b6 Ready-to-use Eclipse distributions containing a stable 1.x version of Epsilon and all its mandatory and optional dependencies. You will only need a Java Runtime Environment . Version Location 1.5 https://archive.eclipse.org/epsilon/1.5/distributions/ (Once you have downloaded the 1.5 distribution, please update Epsilon from the update site below to version 1.5.1, which contains a fix for a regression that affects the properties view of Exeed.) 1.4 https://archive.eclipse.org/epsilon/1.4/distributions/ 1.3 https://archive.eclipse.org/epsilon/1.3/distributions/ 1.2 https://archive.eclipse.org/epsilon/1.2/distributions/ 1.1_SR1 https://archive.eclipse.org/epsilon/1.1_SR1/distributions/ 1.1 https://archive.eclipse.org/epsilon/1.1/distributions/ 1.0 https://archive.eclipse.org/epsilon/1.0/distributions/ Prerequisites \u00b6 The development tools of Epsilon come as a set of Eclipse plugins and therefore, unless you download one of the ready-made distributions above, to install Epsilon you need to download and install a Java Runtime Environment and Eclipse first. The Eclipse Modeling Tools distribution contains most of the necessary prerequisites for Epsilon 1.x. See this page to find out which modeling tools distribution matches the version of Epsilon you wish to install. Update Site \u00b6 You can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Please untick the Show only the latest versions of available software check box, as shown below, to reveal older versions of Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/ Dependencies \u00b6 Dependency Update Site Notes Emfatic http://download.eclipse.org/emfatic/update/ None. GMF Tooling http://download.eclipse.org/modeling/gmp/gmf-tooling/updates/releases/ Install Graphical Modelling Framework (GMF) Tooling SDK. Required for Eugenia. QVTo http://download.eclipse.org/mmt/qvto/updates/releases/latest/ Versions of QVTo >= 3.9.1 should all work with with GMF Tooling Archived Update Sites \u00b6 Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive 1.5 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.5/epsilon-1.5-site.zip 1.4 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.4/epsilon-1.4-site.zip 1.3 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.3/epsilon-1.3-site.zip 1.2 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.2/epsilon-1.2-site.zip Source Code \u00b6 The source code of 1.x versions of Epsilon can be obtained by checking out the respective tag listed under https://github.com/eclipse/epsilon/tags (e.g. https://github.com/eclipse/epsilon/releases/tag/1.4 for 1.4) Maven \u00b6 Older versions of Epsilon JARs are available from Maven Central . Note that prior to 2.0, the structure was different (less modular). For instance, to use the epsilon-core JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> epsilon-core </artifactId> <version> 1.5.1 </version> </dependency> ... </dependencies>","title":"Epsilon 1.x"},{"location":"download/1.x/#epsilon-1x","text":"img { box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); }","title":"Epsilon 1.x"},{"location":"download/1.x/#distributions","text":"Ready-to-use Eclipse distributions containing a stable 1.x version of Epsilon and all its mandatory and optional dependencies. You will only need a Java Runtime Environment . Version Location 1.5 https://archive.eclipse.org/epsilon/1.5/distributions/ (Once you have downloaded the 1.5 distribution, please update Epsilon from the update site below to version 1.5.1, which contains a fix for a regression that affects the properties view of Exeed.) 1.4 https://archive.eclipse.org/epsilon/1.4/distributions/ 1.3 https://archive.eclipse.org/epsilon/1.3/distributions/ 1.2 https://archive.eclipse.org/epsilon/1.2/distributions/ 1.1_SR1 https://archive.eclipse.org/epsilon/1.1_SR1/distributions/ 1.1 https://archive.eclipse.org/epsilon/1.1/distributions/ 1.0 https://archive.eclipse.org/epsilon/1.0/distributions/","title":"Distributions"},{"location":"download/1.x/#prerequisites","text":"The development tools of Epsilon come as a set of Eclipse plugins and therefore, unless you download one of the ready-made distributions above, to install Epsilon you need to download and install a Java Runtime Environment and Eclipse first. The Eclipse Modeling Tools distribution contains most of the necessary prerequisites for Epsilon 1.x. See this page to find out which modeling tools distribution matches the version of Epsilon you wish to install.","title":"Prerequisites"},{"location":"download/1.x/#update-site","text":"You can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Please untick the Show only the latest versions of available software check box, as shown below, to reveal older versions of Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/","title":"Update Site"},{"location":"download/1.x/#dependencies","text":"Dependency Update Site Notes Emfatic http://download.eclipse.org/emfatic/update/ None. GMF Tooling http://download.eclipse.org/modeling/gmp/gmf-tooling/updates/releases/ Install Graphical Modelling Framework (GMF) Tooling SDK. Required for Eugenia. QVTo http://download.eclipse.org/mmt/qvto/updates/releases/latest/ Versions of QVTo >= 3.9.1 should all work with with GMF Tooling","title":"Dependencies"},{"location":"download/1.x/#archived-update-sites","text":"Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive 1.5 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.5/epsilon-1.5-site.zip 1.4 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.4/epsilon-1.4-site.zip 1.3 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.3/epsilon-1.3-site.zip 1.2 https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/1.2/epsilon-1.2-site.zip","title":"Archived Update Sites"},{"location":"download/1.x/#source-code","text":"The source code of 1.x versions of Epsilon can be obtained by checking out the respective tag listed under https://github.com/eclipse/epsilon/tags (e.g. https://github.com/eclipse/epsilon/releases/tag/1.4 for 1.4)","title":"Source Code"},{"location":"download/1.x/#maven","text":"Older versions of Epsilon JARs are available from Maven Central . Note that prior to 2.0, the structure was different (less modular). For instance, to use the epsilon-core JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> epsilon-core </artifactId> <version> 1.5.1 </version> </dependency> ... </dependencies>","title":"Maven"},{"location":"download/2.1/","text":"Epsilon 2.1 \u00b6 The simplest way to get a copy of Eclipse with Epsilon 2.1 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product. Update Sites \u00b6 Alternatively, you can use the following update site through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/2.1/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . Archived Update Sites \u00b6 Below is also a link to a compressed version of the Epsilon 2.1 update site for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.1/epsilon-2.1-site.zip Source Code \u00b6 The source code of Epsilon 2.1 is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.1 Maven \u00b6 Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.1.0 </version> </dependency> ... </dependencies>","title":"Epsilon 2.1"},{"location":"download/2.1/#epsilon-21","text":"The simplest way to get a copy of Eclipse with Epsilon 2.1 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.","title":"Epsilon 2.1"},{"location":"download/2.1/#update-sites","text":"Alternatively, you can use the following update site through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/2.1/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum .","title":"Update Sites"},{"location":"download/2.1/#archived-update-sites","text":"Below is also a link to a compressed version of the Epsilon 2.1 update site for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.1/epsilon-2.1-site.zip","title":"Archived Update Sites"},{"location":"download/2.1/#source-code","text":"The source code of Epsilon 2.1 is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.1","title":"Source Code"},{"location":"download/2.1/#maven","text":"Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.1.0 </version> </dependency> ... </dependencies>","title":"Maven"},{"location":"download/2.2/","text":"Download \u00b6 The simplest way to get a copy of Eclipse with Epsilon 2.2 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product. Update Sites \u00b6 Alternatively, you can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/2.2/ Interim http://download.eclipse.org/epsilon/interim/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . How often is the interim update site rebuilt? The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here Archived Update Sites \u00b6 Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.2/epsilon-2.2-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip Eclipse Marketplace \u00b6 If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop into a running instance of Eclipse. Source Code \u00b6 The source code of Epsilon is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.2 Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs . Maven \u00b6 Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.2.0 </version> </dependency> ... </dependencies> To use the latest SNAPSHOT (interim) version of Epsilon, please see the standalone example POM . Older versions \u00b6 Previous stable versions of Epsilon are available here . This website \u00b6 This article demonstrates how to download and manage the Epsilon website in your machine.","title":"Download"},{"location":"download/2.2/#download","text":"The simplest way to get a copy of Eclipse with Epsilon 2.2 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.","title":"Download"},{"location":"download/2.2/#update-sites","text":"Alternatively, you can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/2.2/ Interim http://download.eclipse.org/epsilon/interim/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . How often is the interim update site rebuilt? The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here","title":"Update Sites"},{"location":"download/2.2/#archived-update-sites","text":"Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.2/epsilon-2.2-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip","title":"Archived Update Sites"},{"location":"download/2.2/#eclipse-marketplace","text":"If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop into a running instance of Eclipse.","title":"Eclipse Marketplace"},{"location":"download/2.2/#source-code","text":"The source code of Epsilon is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.2 Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs .","title":"Source Code "},{"location":"download/2.2/#maven","text":"Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.2.0 </version> </dependency> ... </dependencies> To use the latest SNAPSHOT (interim) version of Epsilon, please see the standalone example POM .","title":"Maven"},{"location":"download/2.2/#older-versions","text":"Previous stable versions of Epsilon are available here .","title":"Older versions"},{"location":"download/2.2/#this-website","text":"This article demonstrates how to download and manage the Epsilon website in your machine.","title":"This website"},{"location":"download/2.3/","text":"Download \u00b6 Regression in recent versions of Eclipse The Epsilon language editors in version 2.3 throw a null pointer exception upon initialisation when installed on versions of Eclipse after 2021-12. This has been fixed in version 2.4 of Epsilon. The simplest way to get a copy of Eclipse with Epsilon 2.3 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product. Update Sites \u00b6 Alternatively, you can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/2.3/ Interim http://download.eclipse.org/epsilon/interim/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . How often is the interim update site rebuilt? The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here Archived Update Sites \u00b6 Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.3/epsilon-2.3-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip Eclipse Marketplace \u00b6 If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop into a running instance of Eclipse. Source Code \u00b6 The source code of Epsilon is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.3 Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs . Maven \u00b6 Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.3.0 </version> </dependency> ... </dependencies> To use the latest SNAPSHOT (interim) version of Epsilon, please see the standalone example POM . Older versions \u00b6 Previous stable versions of Epsilon are available here . This website \u00b6 This article demonstrates how to download and manage the Epsilon website in your machine.","title":"Download"},{"location":"download/2.3/#download","text":"Regression in recent versions of Eclipse The Epsilon language editors in version 2.3 throw a null pointer exception upon initialisation when installed on versions of Eclipse after 2021-12. This has been fixed in version 2.4 of Epsilon. The simplest way to get a copy of Eclipse with Epsilon 2.3 and all its dependencies installed, is to download the Eclipse Installer and select Epsilon. Note that you will need a Java Runtime Environment installed on your system. OS Eclipse Installer Windows http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-win64.exe Mac http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-mac64.dmg Linux http://www.eclipse.org/downloads/download.php?file=/oomph/products/eclipse-inst-linux64.tar.gz Can't find Epsilon? If you don't see Epsilon in the list, click on the three vertical bars on the top right, then Product Catalogs and check \"Eclipse.org Applications\". Epsilon should be near the bottom of the list (you can also use the search bar). If the Product Catalogs option is missing, switch to Advanced Mode and look for Epsilon under \"Eclipse.org Applications\" (if this category is missing, click on the small yellow folder icon in the top right corner and select it). Keep pressing Next (you don't need to change anything) and then Finish. Accept the licenses when prompted. Warning Please do not select the Epsilon project on the second page of the installer in Advanced Mode. This is for Epsilon developers only and may cause issues during installation of the Epsilon product.","title":"Download"},{"location":"download/2.3/#update-sites","text":"Alternatively, you can use the following update sites through the Help \u2192 Install new software menu in Eclipse to install (parts of) Epsilon. Site Location Stable http://download.eclipse.org/epsilon/updates/2.3/ Interim http://download.eclipse.org/epsilon/interim/ Eclipse failing to find dependencies? While Epsilon update sites contain references to all 3 rd party dependencies and shouldn't require installing any prerequisites separately, Eclipse's installation system (p2) can be temperamental and occasionally fail to find external dependencies. In this case, installation can fail with the following message: Cannot complete the install because one or more required items could not be found . When this happens, please untick the Contact all update sites during install to find required software option and try again. Alternatively, you can try installing Epsilon through the Eclipse installer (see above), which is more reliable. If none of this works for you, please post a message to the forum . How often is the interim update site rebuilt? The interim update site is rebuilt automatically with every push to the main branch of the Epsilon repo. Bugs fixed in the interim version (compared to the latest stable version) are listed here","title":"Update Sites"},{"location":"download/2.3/#archived-update-sites","text":"Below are also links to compressed versions of the Epsilon update sites for long-term archival and to support users who are behind corporate firewalls. Site Zip Archive Stable https://www.eclipse.org/downloads/download.php?file=/epsilon/updates/2.3/epsilon-2.3-site.zip Interim https://www.eclipse.org/downloads/download.php?file=/epsilon/interim/epsilon-interim-site.zip","title":"Archived Update Sites"},{"location":"download/2.3/#eclipse-marketplace","text":"If you prefer to install Epsilon through the Eclipse Marketplace, you can drag and drop into a running instance of Eclipse.","title":"Eclipse Marketplace"},{"location":"download/2.3/#source-code","text":"The source code of Epsilon is in the following Git repository. Type Location Repository https://github.com/eclipse/epsilon Release tag https://github.com/eclipse/epsilon/releases/tag/2.3 Additional projects which are experimental or have dependencies which are incompatible with the Eclipse Public License are available in Epsilon Labs .","title":"Source Code "},{"location":"download/2.3/#maven","text":"Epsilon JARs are available from Maven Central . For instance, to use the EOL engine JAR from your pom.xml : <dependencies> ... <dependency> <groupId> org.eclipse.epsilon </groupId> <artifactId> org.eclipse.epsilon.eol.engine </artifactId> <version> 2.3.0 </version> </dependency> ... </dependencies> To use the latest SNAPSHOT (interim) version of Epsilon, please see the standalone example POM .","title":"Maven"},{"location":"download/2.3/#older-versions","text":"Previous stable versions of Epsilon are available here .","title":"Older versions"},{"location":"download/2.3/#this-website","text":"This article demonstrates how to download and manage the Epsilon website in your machine.","title":"This website"},{"location":"download/all-versions/","text":"All Versions of Epsilon \u00b6 Version Eclipse Release Release Date Release Type 2.4 4.22 (2021-12) 6 March 2022 Scheduled release 2.3 4.19 (2021-03) 24 April 2021 Scheduled release 2.2 4.16 (2020-06) 4 September 2020 Scheduled release 2.1 4.16 (2020-06) 3 July 2020 Scheduled release 2.0 4.15 (2020-03) 30 May 2020 Major release (2.0 contained two significant regressions and was replaced by 2.1) 1.5.1 4.8 (Photon) 30 Sep 2018 Service release 1.5 4.8 (Photon) 12 Aug 2018 Scheduled release 1.4 4.6 (Neon) 6 Nov 2016 Scheduled release 1.3 4.5 (Mars) 8 Mar 2015 Scheduled release 1.2 4.4 (Luna) 25 Aug 2014 Scheduled release 1.1_SR1 4.3 (Kepler) 10 Sept 2013 Service release 1.1 4.3 (Kepler) 29 Aug 2013 Scheduled release 1.0 4.2 (Juno) 12 Nov 2012 Scheduled release","title":"All Versions of Epsilon"},{"location":"download/all-versions/#all-versions-of-epsilon","text":"Version Eclipse Release Release Date Release Type 2.4 4.22 (2021-12) 6 March 2022 Scheduled release 2.3 4.19 (2021-03) 24 April 2021 Scheduled release 2.2 4.16 (2020-06) 4 September 2020 Scheduled release 2.1 4.16 (2020-06) 3 July 2020 Scheduled release 2.0 4.15 (2020-03) 30 May 2020 Major release (2.0 contained two significant regressions and was replaced by 2.1) 1.5.1 4.8 (Photon) 30 Sep 2018 Service release 1.5 4.8 (Photon) 12 Aug 2018 Scheduled release 1.4 4.6 (Neon) 6 Nov 2016 Scheduled release 1.3 4.5 (Mars) 8 Mar 2015 Scheduled release 1.2 4.4 (Luna) 25 Aug 2014 Scheduled release 1.1_SR1 4.3 (Kepler) 10 Sept 2013 Service release 1.1 4.3 (Kepler) 29 Aug 2013 Scheduled release 1.0 4.2 (Juno) 12 Nov 2012 Scheduled release","title":"All Versions of Epsilon"},{"location":"playground/readme/","text":"Development Instructions \u00b6 The Playground uses webpack for compiling dependencies and custom JavaScript into a single bundle.js file under dist , which is then used in index.html . To rebuild bundle.js you need to run the following commands: npx webpack --mode=development for a development build (faster build, larger bundle.js ) npx webpack --mode=production before you push to GitHub (slower build, smaller bundle.js ) Testing \u00b6 We use Cypress for automated testing. Tests are stored under the cypress/e2e folder. To run a single test, you need to use the following command: npx cypress run --browser firefox --spec \"cypress/e2e/eol.cy.js\" To run all the end-to-end tests under cypress/e2e , you can use the following command: npx cypress run --browser firefox --spec \"cypress/e2e/*.cy.js\" Note: When the browser is not set to firefox , tests in download.cy.js can be flaky.","title":"Development Instructions"},{"location":"playground/readme/#development-instructions","text":"The Playground uses webpack for compiling dependencies and custom JavaScript into a single bundle.js file under dist , which is then used in index.html . To rebuild bundle.js you need to run the following commands: npx webpack --mode=development for a development build (faster build, larger bundle.js ) npx webpack --mode=production before you push to GitHub (slower build, smaller bundle.js )","title":"Development Instructions"},{"location":"playground/readme/#testing","text":"We use Cypress for automated testing. Tests are stored under the cypress/e2e folder. To run a single test, you need to use the following command: npx cypress run --browser firefox --spec \"cypress/e2e/eol.cy.js\" To run all the end-to-end tests under cypress/e2e , you can use the following command: npx cypress run --browser firefox --spec \"cypress/e2e/*.cy.js\" Note: When the browser is not set to firefox , tests in download.cy.js can be flaky.","title":"Testing"},{"location":"professional-services/","text":"Professional Services \u00b6 The organisations below offer professional support services (e.g. training, bespoke development, expertise) for Epsilon. United Kingdom \u00b6 Kinori Tech University of York Hungary \u00b6 BlackBelt If your organisation offers professional support services for Epsilon and you would like it to be listed here, please get in touch .","title":"Professional Services"},{"location":"professional-services/#professional-services","text":"The organisations below offer professional support services (e.g. training, bespoke development, expertise) for Epsilon.","title":"Professional Services"},{"location":"professional-services/#united-kingdom","text":"Kinori Tech University of York","title":"United Kingdom"},{"location":"professional-services/#hungary","text":"BlackBelt If your organisation offers professional support services for Epsilon and you would like it to be listed here, please get in touch .","title":"Hungary"},{"location":"users/","text":"Industry \u00b6 img { padding: 10px; } Below is a list of known industrial users of Epsilon (based on bug reports, forum messages, blog posts, tweets and published articles). If you'd like to report additional uses of Epsilon in industry or you've spotted any outdated content, please let us know . Sources \u00b6 BAE Systems [ 1 ], Bosch [ 1 ], NASA [ 1 , 2 , 3 , 4 ], THALES [ 1 , 2 , 3 ], Siemens [ 1 , 2 ], Rolls-Royce [ 1 , 2 , 3 , 4 , 5 ], IBM [ 1 , 2 , 3 , 4 , 5 ], Oracle [ 1 ], Blackbelt [ 1 , 2 ], Codebots [ 1 ], Raytheon [ 1 , 2 ], Atos [ 1 ], Ergon [ 1 ], Talend [ 1 ], Corpus [ 1 ], develop group [ 1 ], DevBoost [ 1 ], Academa [ 1 , 2 , 3 , 4 ], Intelliment [ 1 ], Maiborn Wolff [ 1 , 2 ]","title":"Industry"},{"location":"users/#industry","text":"img { padding: 10px; } Below is a list of known industrial users of Epsilon (based on bug reports, forum messages, blog posts, tweets and published articles). If you'd like to report additional uses of Epsilon in industry or you've spotted any outdated content, please let us know .","title":"Industry"},{"location":"users/#sources","text":"BAE Systems [ 1 ], Bosch [ 1 ], NASA [ 1 , 2 , 3 , 4 ], THALES [ 1 , 2 , 3 ], Siemens [ 1 , 2 ], Rolls-Royce [ 1 , 2 , 3 , 4 , 5 ], IBM [ 1 , 2 , 3 , 4 , 5 ], Oracle [ 1 ], Blackbelt [ 1 , 2 ], Codebots [ 1 ], Raytheon [ 1 , 2 ], Atos [ 1 ], Ergon [ 1 ], Talend [ 1 ], Corpus [ 1 ], develop group [ 1 ], DevBoost [ 1 ], Academa [ 1 , 2 , 3 , 4 ], Intelliment [ 1 ], Maiborn Wolff [ 1 , 2 ]","title":"Sources"},{"location":"users/education/","text":"Education \u00b6 img { padding: 10px; } Below is a list of institutions that use one or more components of Epsilon (e.g. EGL, Eugenia) as part of their modelling/MDE courses. If you'd like to report additional uses of Epsilon in taught courses or you've spotted any outdated content, please let us know . Sources \u00b6 University of York [ 1 ], University of Texas [ 1 ], University of Oslo [ 1 ], Universidad Autonoma de Madrid [ 1 ], McGill University [ 1 ], University of Kassel [ 1 ], University of Marburg [ 1 ], Technische Universiteit Eindhoven [ 1 ], Universitea Babes-Bolyai [ 1 ], Universidad de los Andes [ 1 ], Budapest University of Technology and Economics [ 1 ], Technical University of Dresden [ 1 ], University of Southern Denmark [ 1 ], Norwegian University of Science and Technology [ 1 ], University of Cadiz [ 1 ], McMaster University [ 1 ], University of Edinburgh [ 1 ], Antwerp University [ 1 ], King's College London [ 1 ]","title":"Education"},{"location":"users/education/#education","text":"img { padding: 10px; } Below is a list of institutions that use one or more components of Epsilon (e.g. EGL, Eugenia) as part of their modelling/MDE courses. If you'd like to report additional uses of Epsilon in taught courses or you've spotted any outdated content, please let us know .","title":"Education"},{"location":"users/education/#sources","text":"University of York [ 1 ], University of Texas [ 1 ], University of Oslo [ 1 ], Universidad Autonoma de Madrid [ 1 ], McGill University [ 1 ], University of Kassel [ 1 ], University of Marburg [ 1 ], Technische Universiteit Eindhoven [ 1 ], Universitea Babes-Bolyai [ 1 ], Universidad de los Andes [ 1 ], Budapest University of Technology and Economics [ 1 ], Technical University of Dresden [ 1 ], University of Southern Denmark [ 1 ], Norwegian University of Science and Technology [ 1 ], University of Cadiz [ 1 ], McMaster University [ 1 ], University of Edinburgh [ 1 ], Antwerp University [ 1 ], King's College London [ 1 ]","title":"Sources"},{"location":"users/open-source/","text":"Open Source Projects \u00b6 Below is a list of open-source projects that are using languages and tools provided by Epsilon. If you'd like your project to appear here or you've spotted any outdated content, please let us know . NASA CertWare : The CertWare workbench contributes several core modules supporting safety case models, and extends these with a service-based APIs for plugging new capabilities into the workbench for processing these models. SAFECAP : Safecap is an Eclipse-based tool for entering and analysing railway junction schemas. The tool can be used for the analysis of control table for junction signals, assessment of capacity impact of signal positioning and train detection circuit boundaries, and also for conducting semi-automatic or automatic changes to schema topology or control tables. T4UME : Uncertainty Modeling and Evaluation (UME) is a methodology that aims at detecting uncertainty caused by missing information on system models. UME aims at contributing to the Uncertainty Modeling (UM) standardization activity supported by the OMG focusing on models created with UML. Tool for UME (T4UME) is the companion supporting tool implemented on top of state of the art MDE technologies. EMF Rest : EMF-REST generates truly RESTful APIs for your EMF models. EMF-REST complements the existing (Java-based) API generation facilities EMF already provides and extends them to the Web. MTC Flow : MTC Flow s a tool which allows model-driven developers to design, develop, test and deploy Model Transformation Chains (MTCs). The tool offers a graphical DSL for defining MTC workflows independently of implementation technologies. Melanee : Melanee is a workbench for creating domain-specific languages which occupy an arbitrary number of ontological levels. It ships with a default general-purpose notation which is designed with the UML and Entity-Relationship diagrams in mind. JastEMF : JastEMF is a tool to support the integrated use of the JastAdd system - a rewriteable, circular, reference attribute grammar (ReCRAG) generator - and the Eclipse Modeling Framework (EMF) - a Java based metamodeling framework built around the Ecore metamodeling language. Tigerstripe : Tigerstripe is a framework for Model Driven Engineering (MDE) with special support for the Telecommunications Industry. HiLeS : The HiLeS2 Framework was developed to aid the Embedded System Designers during the design process. The HiLeS2 Framework purpose is to serve as a platform to create Embedded System Product Lines. It incorporates both tools developed by the group and open source tools to provide an Integrated Development Environment (IDE) suitable for system specification, product line construction and virtual prototype generation. EERCASE : The Enhanced Entity-Relationship (EER) Model is one of the most used modeling languages for the conceptual design of database. However, to the best of our knowledge, there are no metamodels and Computer-Aided Software Engineering (CASE) tool that provide support to code generation and schema validation from conceptual data model according to the EER classical notation (i.e., Chen/Elmasri and Navathe's notation - cf. Fig below). Aiming to overcome the previous shortcoming, we have proposed a metamodel and a CASE tool named EER MetaModel (EERMM) and EERCASE, respectively. metaDepth : metaDepth is a framework for deep meta-modelling that provide supports for an arbitrary number of ontological meta-levels. This makes MetaDepth especially useful to define multi-level languages. bflow* Toolbox : The bflow Toolbox is an open source tool kit for business process management. The objective of bflow is to explore new ways and scenarios for the development and use of modelling tools. Pongo MongoDB Generator : Pongo is a template-based Java POJO generator for MongoDB. Instead of using low-level DBObjects to interact with your MongoDB database, with Pongo you can define your data/domain model using Emfatic and then generate strongly-typed Java classes you can then use to work with your database at a more convenient level of abstraction. TENTE C# : TENTE is a contribution for SPL architectural design and implementation. This process integrates relevant advances, from an SPL point of view, for separation of concerns and MDD technologies. This project contains the TENTE code generators for the C# approach. Brics : The prime objective of BRICS is to structure and formalize the robot development process itself and to provide tools, models, and functional libraries, which help accelerating this process significantly. MIDE : MIDE is an IDE for working with UML Class Diagrams. It extends the Eclipse UML2 Editor and enables carrying out complex tasks in one click, and provides a pattern-matching engine for detecting design errors as soon as they are made Event-B : Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels. PhpNoDB : While having a database is essential for any large-scale website, it can be an overkill for smaller projects/prototypes where read-only access to a small dataset would be sufficient. To save you the trouble of setting up and managing a database if you don't really need one, phpnodb lets you capture your data in a Google Spreadsheet and then generate from it a standalone PHP class that contains an embedded copy of your data. Collaborative Modeling Framework : This modeling framework uses the MetaDepth framework to model and generate collaborative Android applications. The framework includes - among others - chat, Dropbox, Foursquare and geo components. Product Line Documentation Toolkit for Eclipse : The aim of the project is to create an Eclipse plugin to support text and visual editing and validating of DRL documents. DRL stands for 'Document Reuse Language' - a special document markup language incorporating docbook features, designed for creating documentation for a series of highly-interrelated software products, otherwise known as 'Product Line'. Context Manager Framework : Context Manager Framework is a ongoing work at Department of Engineering and Computer Science and Mathematics at University of L'Aquila. It includes model-based methodologies and tools to support the non-functional (a.k.a. extra-functional)aspects of context-aware software systems. UNC Chapel Hill Libraries : University of North Carolina at Chapel Hill Libraries open-source project. Library metadata models and mapping tools implemented in Eclipse Modelling Framework (EMF). MetaGem : MeTAGeM is a Meta-Tool for the Automatic Generation of Model Transformations that makes possible to put into practice the MDE (Model-Driven Engineering) principles for developing model transformations, defining model transformations as models, without considering details of the code implementation. AcEdit : Editor for Assurance Cases, Implementing the Goal Structuring Notation (GSN) and the OMG Argumentation Metamodel (ARM). The editor implements the GSN standard as specified at www.goalstructuringnotation.info and the ARM standard available from sysa.omg.org Ecore 2 Doctrine : Ecore 2 Doctrine Model-to-model transformer Unicaneer2Sql : An Eclipse plugin for model-driven development of databases. The application provides facilities to create graphical ER models and generates code for SLQ Sever and Oracle. Reflo : This project aims to provide a machine-assisted environment for developers model programs, using a dataflow notation. It also provides a rewriting system for dataflow graphs. Prediqt Editors : Two versions of a editor for the PREDIQT method, one created using GMF, the other created using Graphiti. Kybele GMF Gen : Kybele GMF Generator (also known as KybeleGMFgen) is a new Model-Driven Software Development (MDSD) tool for Eclipse Modeling Tools for creating, in only a few steps, graphical editors from manually annotated metamodels and customization files. MODEmbed : MODembed is an experimental IDE aiming to provide a more advanced toolchain for embedded software development. It provides a model-based approach for defining the whole compilation process. The project aims to create a full-featured IDE which can support every aspect of an embedded system design using a model-based approach. rFSM Modeling : The purpose of this project is to create a meta-model for the representation of rFSM programs. This project contains a meta-model of rFSM, a grammar which is only defined for testing purposes, a complete programming environment based on that Xtext grammar, and a Lua code generation based on the model of an rFSM program. HyperFlex : HyperFlex is a collection of Eclipse plugins that support the development of robotics software product lines, a family of similar applications that are built reusing a set of software components and share the same architecture. HyperFlex provides a set of tools for designing variability models and architectural models for the most spread Robotics Software Frameworks (ROS, Orocos and the cloud-based Rapyuta). FraMED : FRaMED is the First Role Modeling EDitor allowing the graphical specification of Role-based Software Systems by means of compartments (aka. contexts), objects, roles, and relationships. Additionally, it supports a varity of constraints upon roles and relationships. Tura : Tura provides support for model-driven development of JEE/JSF web applications. Tura provides a dedicated domain-specific language for modelling web applications, supporting editors and generators built using the EMF, GMF and Epsilon frameworks, and supports the full development lifecycle including code generation, testing, compilation, building, and deployment. MMINT : Model Management INTeractive (MMINT) is an Eclipse-based workbench for graphical, interactive model management. MMINT allows modelers to do rapid prototyping and exploratory modeling while seamlessly keeping track of all relevant artifacts in their workspace. MMINT is developed by the Software Engineering group at the University of Toronto, under the supervision of Professor Marsha Chechik. MDebugger : MDebugger is a platform-independent model-level debugger for UML-RT models. It provides live debugging features (e.g., breakpoints) to debug generated systems from UML-RT models without using any program debugger or referring to the generated source code. To make it platform-independent, it uses model transformation (i.e. the Epsilon Object Language) to add support for debugging capabilities to the models.","title":"Open-source Projects"},{"location":"users/open-source/#open-source-projects","text":"Below is a list of open-source projects that are using languages and tools provided by Epsilon. If you'd like your project to appear here or you've spotted any outdated content, please let us know . NASA CertWare : The CertWare workbench contributes several core modules supporting safety case models, and extends these with a service-based APIs for plugging new capabilities into the workbench for processing these models. SAFECAP : Safecap is an Eclipse-based tool for entering and analysing railway junction schemas. The tool can be used for the analysis of control table for junction signals, assessment of capacity impact of signal positioning and train detection circuit boundaries, and also for conducting semi-automatic or automatic changes to schema topology or control tables. T4UME : Uncertainty Modeling and Evaluation (UME) is a methodology that aims at detecting uncertainty caused by missing information on system models. UME aims at contributing to the Uncertainty Modeling (UM) standardization activity supported by the OMG focusing on models created with UML. Tool for UME (T4UME) is the companion supporting tool implemented on top of state of the art MDE technologies. EMF Rest : EMF-REST generates truly RESTful APIs for your EMF models. EMF-REST complements the existing (Java-based) API generation facilities EMF already provides and extends them to the Web. MTC Flow : MTC Flow s a tool which allows model-driven developers to design, develop, test and deploy Model Transformation Chains (MTCs). The tool offers a graphical DSL for defining MTC workflows independently of implementation technologies. Melanee : Melanee is a workbench for creating domain-specific languages which occupy an arbitrary number of ontological levels. It ships with a default general-purpose notation which is designed with the UML and Entity-Relationship diagrams in mind. JastEMF : JastEMF is a tool to support the integrated use of the JastAdd system - a rewriteable, circular, reference attribute grammar (ReCRAG) generator - and the Eclipse Modeling Framework (EMF) - a Java based metamodeling framework built around the Ecore metamodeling language. Tigerstripe : Tigerstripe is a framework for Model Driven Engineering (MDE) with special support for the Telecommunications Industry. HiLeS : The HiLeS2 Framework was developed to aid the Embedded System Designers during the design process. The HiLeS2 Framework purpose is to serve as a platform to create Embedded System Product Lines. It incorporates both tools developed by the group and open source tools to provide an Integrated Development Environment (IDE) suitable for system specification, product line construction and virtual prototype generation. EERCASE : The Enhanced Entity-Relationship (EER) Model is one of the most used modeling languages for the conceptual design of database. However, to the best of our knowledge, there are no metamodels and Computer-Aided Software Engineering (CASE) tool that provide support to code generation and schema validation from conceptual data model according to the EER classical notation (i.e., Chen/Elmasri and Navathe's notation - cf. Fig below). Aiming to overcome the previous shortcoming, we have proposed a metamodel and a CASE tool named EER MetaModel (EERMM) and EERCASE, respectively. metaDepth : metaDepth is a framework for deep meta-modelling that provide supports for an arbitrary number of ontological meta-levels. This makes MetaDepth especially useful to define multi-level languages. bflow* Toolbox : The bflow Toolbox is an open source tool kit for business process management. The objective of bflow is to explore new ways and scenarios for the development and use of modelling tools. Pongo MongoDB Generator : Pongo is a template-based Java POJO generator for MongoDB. Instead of using low-level DBObjects to interact with your MongoDB database, with Pongo you can define your data/domain model using Emfatic and then generate strongly-typed Java classes you can then use to work with your database at a more convenient level of abstraction. TENTE C# : TENTE is a contribution for SPL architectural design and implementation. This process integrates relevant advances, from an SPL point of view, for separation of concerns and MDD technologies. This project contains the TENTE code generators for the C# approach. Brics : The prime objective of BRICS is to structure and formalize the robot development process itself and to provide tools, models, and functional libraries, which help accelerating this process significantly. MIDE : MIDE is an IDE for working with UML Class Diagrams. It extends the Eclipse UML2 Editor and enables carrying out complex tasks in one click, and provides a pattern-matching engine for detecting design errors as soon as they are made Event-B : Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels. PhpNoDB : While having a database is essential for any large-scale website, it can be an overkill for smaller projects/prototypes where read-only access to a small dataset would be sufficient. To save you the trouble of setting up and managing a database if you don't really need one, phpnodb lets you capture your data in a Google Spreadsheet and then generate from it a standalone PHP class that contains an embedded copy of your data. Collaborative Modeling Framework : This modeling framework uses the MetaDepth framework to model and generate collaborative Android applications. The framework includes - among others - chat, Dropbox, Foursquare and geo components. Product Line Documentation Toolkit for Eclipse : The aim of the project is to create an Eclipse plugin to support text and visual editing and validating of DRL documents. DRL stands for 'Document Reuse Language' - a special document markup language incorporating docbook features, designed for creating documentation for a series of highly-interrelated software products, otherwise known as 'Product Line'. Context Manager Framework : Context Manager Framework is a ongoing work at Department of Engineering and Computer Science and Mathematics at University of L'Aquila. It includes model-based methodologies and tools to support the non-functional (a.k.a. extra-functional)aspects of context-aware software systems. UNC Chapel Hill Libraries : University of North Carolina at Chapel Hill Libraries open-source project. Library metadata models and mapping tools implemented in Eclipse Modelling Framework (EMF). MetaGem : MeTAGeM is a Meta-Tool for the Automatic Generation of Model Transformations that makes possible to put into practice the MDE (Model-Driven Engineering) principles for developing model transformations, defining model transformations as models, without considering details of the code implementation. AcEdit : Editor for Assurance Cases, Implementing the Goal Structuring Notation (GSN) and the OMG Argumentation Metamodel (ARM). The editor implements the GSN standard as specified at www.goalstructuringnotation.info and the ARM standard available from sysa.omg.org Ecore 2 Doctrine : Ecore 2 Doctrine Model-to-model transformer Unicaneer2Sql : An Eclipse plugin for model-driven development of databases. The application provides facilities to create graphical ER models and generates code for SLQ Sever and Oracle. Reflo : This project aims to provide a machine-assisted environment for developers model programs, using a dataflow notation. It also provides a rewriting system for dataflow graphs. Prediqt Editors : Two versions of a editor for the PREDIQT method, one created using GMF, the other created using Graphiti. Kybele GMF Gen : Kybele GMF Generator (also known as KybeleGMFgen) is a new Model-Driven Software Development (MDSD) tool for Eclipse Modeling Tools for creating, in only a few steps, graphical editors from manually annotated metamodels and customization files. MODEmbed : MODembed is an experimental IDE aiming to provide a more advanced toolchain for embedded software development. It provides a model-based approach for defining the whole compilation process. The project aims to create a full-featured IDE which can support every aspect of an embedded system design using a model-based approach. rFSM Modeling : The purpose of this project is to create a meta-model for the representation of rFSM programs. This project contains a meta-model of rFSM, a grammar which is only defined for testing purposes, a complete programming environment based on that Xtext grammar, and a Lua code generation based on the model of an rFSM program. HyperFlex : HyperFlex is a collection of Eclipse plugins that support the development of robotics software product lines, a family of similar applications that are built reusing a set of software components and share the same architecture. HyperFlex provides a set of tools for designing variability models and architectural models for the most spread Robotics Software Frameworks (ROS, Orocos and the cloud-based Rapyuta). FraMED : FRaMED is the First Role Modeling EDitor allowing the graphical specification of Role-based Software Systems by means of compartments (aka. contexts), objects, roles, and relationships. Additionally, it supports a varity of constraints upon roles and relationships. Tura : Tura provides support for model-driven development of JEE/JSF web applications. Tura provides a dedicated domain-specific language for modelling web applications, supporting editors and generators built using the EMF, GMF and Epsilon frameworks, and supports the full development lifecycle including code generation, testing, compilation, building, and deployment. MMINT : Model Management INTeractive (MMINT) is an Eclipse-based workbench for graphical, interactive model management. MMINT allows modelers to do rapid prototyping and exploratory modeling while seamlessly keeping track of all relevant artifacts in their workspace. MMINT is developed by the Software Engineering group at the University of Toronto, under the supervision of Professor Marsha Chechik. MDebugger : MDebugger is a platform-independent model-level debugger for UML-RT models. It provides live debugging features (e.g., breakpoints) to debug generated systems from UML-RT models without using any program debugger or referring to the generated source code. To make it platform-independent, it uses model transformation (i.e. the Epsilon Object Language) to add support for debugging capabilities to the models.","title":"Open Source Projects"}]}